require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');
const Stripe = require('stripe');
const OpenAI = require('openai');
const validator = require('validator');
const crypto = require('crypto');
const { Resend } = require('resend');
const { OAuth2Client } = require('google-auth-library');
const Anthropic = require('@anthropic-ai/sdk');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { TwitterApi } = require('twitter-api-v2');
const SibApiV3Sdk = require('@getbrevo/brevo');
const sgMail = require('@sendgrid/mail');
const Mailgun = require('mailgun.js');
const FormData = require('form-data');
const { MailerSend, EmailParams, Sender, Recipient } = require('mailersend');
const { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');
const cron = require('node-cron');
const {
  getFewShotExamples,
  getFewShotExamplesXML,
  checkAISlop,
  AI_SLOP_WORDS,
  AI_SLOP_PHRASES,
} = require('./promptExamples');

const app = express();
const PORT = process.env.PORT || 5000;

// PostgreSQL connection
if (!process.env.DATABASE_URL) {
  console.error('ERROR: DATABASE_URL environment variable is not set!');
  console.error('Please set DATABASE_URL in your environment variables.');
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

// Track database connection status
let dbConnected = false;

pool.on('error', err => {
  console.error('Unexpected PostgreSQL pool error:', err);
  dbConnected = false;
});

pool.on('connect', () => {
  console.log('PostgreSQL pool: client connected');
  dbConnected = true;
});

// Initialize services
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const resend = process.env.RESEND_API_KEY ? new Resend(process.env.RESEND_API_KEY) : null;
const googleClient = process.env.GOOGLE_CLIENT_ID
  ? new OAuth2Client(process.env.GOOGLE_CLIENT_ID)
  : null;
const anthropic = process.env.ANTHROPIC_API_KEY
  ? new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })
  : null;
const gemini = process.env.GEMINI_API_KEY
  ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY)
  : null;

// Twitter/X API Client (OAuth 1.0a for posting)
const twitterClient =
  process.env.TWITTER_API_KEY && process.env.TWITTER_ACCESS_TOKEN
    ? new TwitterApi({
        appKey: process.env.TWITTER_API_KEY,
        appSecret: process.env.TWITTER_API_SECRET,
        accessToken: process.env.TWITTER_ACCESS_TOKEN,
        accessSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET,
      })
    : null;

// Brevo (ex-Sendinblue) for marketing/outreach emails (300/day free)
let brevoApi = null;
if (process.env.BREVO_API_KEY) {
  brevoApi = new SibApiV3Sdk.TransactionalEmailsApi();
  brevoApi.setApiKey(SibApiV3Sdk.TransactionalEmailsApiApiKeys.apiKey, process.env.BREVO_API_KEY);
}

// SendGrid (100/day free forever)
if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  console.log('[SendGrid] Initialized');
}

// Mailgun (5000/month free for 3 months, then pay-as-you-go)
let mailgunClient = null;
if (process.env.MAILGUN_API_KEY && process.env.MAILGUN_DOMAIN) {
  const mailgun = new Mailgun(FormData);
  mailgunClient = mailgun.client({ username: 'api', key: process.env.MAILGUN_API_KEY });
  console.log('[Mailgun] Initialized');
}

// MailerSend (3000/month free = 100/day)
let mailerSendClient = null;
if (process.env.MAILERSEND_API_KEY) {
  mailerSendClient = new MailerSend({ apiKey: process.env.MAILERSEND_API_KEY });
  console.log('[MailerSend] Initialized');
}

// Amazon SES (62,000/month free if sending from EC2, otherwise $0.10/1000)
// Best option for scale - no daily limits, just monthly
let sesClient = null;
if (process.env.AWS_SES_ACCESS_KEY_ID && process.env.AWS_SES_SECRET_ACCESS_KEY) {
  sesClient = new SESClient({
    region: process.env.AWS_SES_REGION || 'eu-central-1',
    credentials: {
      accessKeyId: process.env.AWS_SES_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SES_SECRET_ACCESS_KEY,
    },
  });
  console.log('[Amazon SES] Initialized - Region:', process.env.AWS_SES_REGION || 'eu-central-1');
}

// ==========================================
// MULTI-PROVIDER EMAIL SYSTEM
// ==========================================
// Round-robin through providers to maximize daily email volume
// Priority: SES (unlimited) â†’ Brevo (300) â†’ MailerSend (100) â†’ others

const EMAIL_PROVIDER_LIMITS = {
  ses: 50000, // Effectively unlimited - $0.10/1000 emails
  brevo: 300,
  mailersend: 100, // 3000/month Ã· 30 days
  sendgrid: 100,
  mailgun: 166, // 5000/month Ã· 30 days
  resend: 100,
};

// Get today's email count per provider (cached for 5 min)
let providerCountCache = { counts: {}, lastUpdated: 0 };
async function getProviderCountsToday() {
  const now = Date.now();
  if (now - providerCountCache.lastUpdated < 300000) { // 5 min cache
    return providerCountCache.counts;
  }

  try {
    const result = await pool.query(`
      SELECT provider, COUNT(*) as count
      FROM email_logs
      WHERE sent_at >= CURRENT_DATE
        AND status = 'sent'
      GROUP BY provider
    `);

    const counts = { ses: 0, brevo: 0, mailersend: 0, sendgrid: 0, mailgun: 0, resend: 0 };
    result.rows.forEach(row => {
      if (counts.hasOwnProperty(row.provider)) {
        counts[row.provider] = parseInt(row.count);
      }
    });

    providerCountCache = { counts, lastUpdated: now };
    return counts;
  } catch (err) {
    console.error('[Email] Failed to get provider counts:', err.message);
    return { ses: 0, brevo: 0, mailersend: 0, sendgrid: 0, mailgun: 0, resend: 0 };
  }
}

// Select best provider with remaining capacity
async function selectEmailProvider() {
  const counts = await getProviderCountsToday();

  // Priority order: SES (unlimited) â†’ Brevo (300) â†’ MailerSend (100) â†’ others
  const providers = [
    { name: 'ses', available: sesClient !== null },
    { name: 'brevo', available: brevoApi !== null },
    { name: 'mailersend', available: mailerSendClient !== null },
    { name: 'mailgun', available: mailgunClient !== null },
    { name: 'sendgrid', available: process.env.SENDGRID_API_KEY !== undefined },
    { name: 'resend', available: resend !== null },
  ];

  for (const p of providers) {
    if (p.available && counts[p.name] < EMAIL_PROVIDER_LIMITS[p.name]) {
      const remaining = EMAIL_PROVIDER_LIMITS[p.name] - counts[p.name];
      console.log(`[Email] Selected ${p.name} (${counts[p.name]}/${EMAIL_PROVIDER_LIMITS[p.name]}, ${remaining} remaining)`);
      return p.name;
    }
  }

  // All providers exhausted - use Brevo anyway (might fail with quota error)
  console.warn('[Email] All providers at daily limit! Trying Brevo as fallback...');
  return brevoApi ? 'brevo' : 'resend';
}

// Email sender addresses (configurable via ENV)
const FROM_EMAIL = process.env.FROM_EMAIL || 'ReviewResponder <hello@tryreviewresponder.com>';
const OUTREACH_FROM_EMAIL =
  process.env.OUTREACH_FROM_EMAIL || 'Berend von ReviewResponder <outreach@tryreviewresponder.com>';

// ==========================================
// API COST TRACKING
// ==========================================
// Pricing per 1M tokens (input/output) or per request

const API_PRICING = {
  anthropic: {
    'claude-sonnet-4-20250514': { input: 3, output: 15 },
    'claude-3-5-haiku-20241022': { input: 0.8, output: 4 }, // Standard AI
    'claude-opus-4-5-20250514': { input: 15, output: 75 },
    'claude-opus-4-20250514': { input: 15, output: 75 },
  },
  openai: {
    'gpt-4o-mini': { input: 0.15, output: 0.6 }, // Fallback only
    'gpt-4o': { input: 2.5, output: 10 },
  },
  google: {
    'gemini-3-pro-preview': { input: 0, output: 0 }, // Free Tier / Student
    'gemini-2.5-pro': { input: 0, output: 0 },
  },
  google_places: { per_request: 0.017 }, // $17/1000 requests
  hunter: { per_request: 0.04 }, // After 50 free/mo
  serpapi: { per_request: 0.1 }, // After 100 free/mo
  brevo: { per_request: 0 }, // Free 300/day
  resend: { per_request: 0 }, // Free 100/day
  twitter: { per_request: 0 }, // Free Tier
};

// ==========================================
// TEST EMAIL FILTERING - Zentrale Konfiguration
// ==========================================
// Alle Test-Emails werden aus Analytics ausgeschlossen

// Explizite Test-Email-Adressen (manuell gepflegt)
const TEST_EMAILS = [
  // Test Accounts (zu lÃ¶schen/ignorieren)
  'reviewer@tryreviewresponder.com',
  'weviewvbtetsmail@gmail.com',
  'testemailsjsjdj@gmail.com',
  'testemaicewl@gmail.com',
  'testemailwvev@gmail.com',
  'testemaildw@gmail.com',
  'contestmail@gmail.com',
  'testemaiccecel@gmail.com',
  'testemail@gmail.com',
  'anothertestaccount@gmail.com',
  // Owner Accounts (alle Berend-Varianten)
  'berend.mainz@gmail.com',
  'berend.jakob.mainz@gmail.com',
  // Freunde (aus Metriken ausschlieÃŸen)
  'breihosen@gmail.com',
  'andrehoellering1732004@gmail.com',
  'clvalentini24@gmail.com',
  'penelopefier@gmail.com',
  'matiasaseff@hotmail.com',
  'lennart.schega@gmail.com',
  'tiniwi09@gmail.com',
  // Rolicupo - unklar ob echt, erstmal excluded
  'rolicupo.twitch@gmail.com',
  'rolicupo.games@gmail.com',
].map(e => e.toLowerCase());

// SQL LIKE Patterns fÃ¼r Test-Emails
const TEST_EMAIL_PATTERNS = [
  '%@web.de', // Owner's domain
  'test%', // Starts with test
  '%test@%', // Contains test@
  'asdf%', // Keyboard spam
  'qwer%', // Keyboard spam
  'asd@%', // Keyboard spam
  '%@test.%', // @test.* domain
  '%@example.%', // @example.* domain
  'admin@%', // admin@ prefix
  '%fake%', // Contains fake
  'a@%', // Single char a@
  'aa@%', // Double char aa@
  'aaa@%', // Triple char aaa@
];

/**
 * Generate SQL WHERE clause to exclude test emails
 * @param {string} emailColumn - Column name (default: 'email')
 * @returns {string} SQL AND clause
 */
function getTestEmailExcludeClause(emailColumn = 'email') {
  const patternClauses = TEST_EMAIL_PATTERNS.map(p => `${emailColumn} NOT LIKE '${p}'`).join(
    ' AND '
  );

  const explicitClauses = TEST_EMAILS.map(e => `LOWER(${emailColumn}) != '${e}'`).join(' AND ');

  return `AND ${patternClauses} AND ${explicitClauses}`;
}

/**
 * Check if an email is a test email (JavaScript version)
 * @param {string} email
 * @returns {boolean}
 */
function isTestEmail(email) {
  if (!email) return false;
  const lowerEmail = email.toLowerCase();

  // Check explicit list
  if (TEST_EMAILS.includes(lowerEmail)) return true;

  // Check patterns (convert SQL LIKE to regex)
  const patternChecks = [
    /@web\.de$/i,
    /^test/i,
    /test@/i,
    /^asdf/i,
    /^qwer/i,
    /^asd@/i,
    /@test\./i,
    /@example\./i,
    /^admin@/i,
    /fake/i,
    /^a@/i,
    /^aa@/i,
    /^aaa@/i,
  ];

  return patternChecks.some(regex => regex.test(lowerEmail));
}

/**
 * Log API call for cost tracking
 * @param {Object} params
 * @param {string} params.provider - 'anthropic', 'openai', 'google', 'google_places', etc.
 * @param {string} params.model - Model name (e.g., 'claude-sonnet-4-20250514')
 * @param {string} params.endpoint - API endpoint that triggered the call
 * @param {number} params.userId - User ID (null for system/cron calls)
 * @param {number} params.inputTokens - Input tokens used
 * @param {number} params.outputTokens - Output tokens used
 * @param {string} params.status - 'success' or 'error'
 * @param {string} params.error - Error message if failed
 * @param {Object} params.metadata - Additional metadata
 */
async function logApiCall({
  provider,
  model = null,
  endpoint = null,
  userId = null,
  inputTokens = 0,
  outputTokens = 0,
  status = 'success',
  error = null,
  metadata = null,
}) {
  try {
    const totalTokens = (inputTokens || 0) + (outputTokens || 0);
    let estimatedCost = 0;

    // Calculate cost based on provider
    if (provider === 'anthropic' || provider === 'openai' || provider === 'google') {
      const pricing = API_PRICING[provider]?.[model];
      if (pricing) {
        estimatedCost =
          ((inputTokens || 0) / 1_000_000) * pricing.input +
          ((outputTokens || 0) / 1_000_000) * pricing.output;
      }
    } else if (API_PRICING[provider]?.per_request) {
      estimatedCost = API_PRICING[provider].per_request;
    }

    await pool.query(
      `INSERT INTO api_call_logs (provider, model, endpoint, user_id, input_tokens, output_tokens, total_tokens, estimated_cost, status, error_message, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`,
      [
        provider,
        model,
        endpoint,
        userId,
        inputTokens || 0,
        outputTokens || 0,
        totalTokens,
        estimatedCost,
        status,
        error,
        metadata ? JSON.stringify(metadata) : null,
      ]
    );
  } catch (logError) {
    // Non-blocking - don't fail the main request if logging fails
    console.error('[logApiCall] Failed to log API call:', logError.message);
  }
}

// ==========================================
// UNIFIED EMAIL SYSTEM - Central Router
// ==========================================
// Routes emails to Brevo (marketing) or Resend (transactional)
// Logs all emails to email_logs table for dashboard

/**
 * Central email function with provider routing and logging
 * @param {Object} params
 * @param {string} params.to - Recipient email
 * @param {string} params.subject - Email subject
 * @param {string} params.html - HTML content
 * @param {string} params.type - 'transactional' | 'marketing' | 'outreach'
 * @param {string} params.campaign - Campaign identifier for tracking
 * @param {Array} params.tags - Additional tags for analytics
 * @param {string} params.from - Custom from address (optional)
 * @param {string} params.replyTo - Reply-to address (optional)
 * @param {boolean} params.addTrackingPixel - Add open tracking pixel (default: false for transactional)
 */
async function sendEmail({
  to,
  subject,
  html = null,
  text = null,
  type = 'transactional',
  campaign = null,
  tags = [],
  from = null,
  replyTo = null,
  addTrackingPixel = false,
}) {
  // MULTI-PROVIDER: Select best available provider with capacity
  let provider = await selectEmailProvider();
  let messageId = null;
  let error = null;

  // Convert text to HTML if only text provided
  let finalHtml =
    html ||
    (text
      ? `<pre style="font-family: Arial, sans-serif; white-space: pre-wrap;">${text}</pre>`
      : null);
  const finalText = text;

  // Add tracking pixel for marketing/outreach emails
  if (addTrackingPixel && campaign && finalHtml) {
    const BACKEND_URL = process.env.BACKEND_URL || 'https://review-responder.onrender.com';
    const trackingPixel = `<img src="${BACKEND_URL}/api/outreach/track-open?email=${encodeURIComponent(to)}&campaign=${encodeURIComponent(campaign)}" width="1" height="1" style="display:none;" alt="" />`;
    finalHtml = finalHtml + trackingPixel;
  }

  // Determine sender
  const fromAddress = from || (type === 'outreach' ? OUTREACH_FROM_EMAIL : FROM_EMAIL);

  // Parse from address into name/email parts
  const fromMatch = fromAddress.match(/^(.+?)\s*<(.+)>$/);
  const fromName = fromMatch ? fromMatch[1].trim() : 'ReviewResponder';
  const fromEmail = fromMatch ? fromMatch[2].trim() : fromAddress;

  // Track which providers we've tried (for fallback)
  const triedProviders = new Set();

  while (triedProviders.size < 4) { // Max 4 providers
    triedProviders.add(provider);

    try {
      // ========== AMAZON SES ==========
      if (provider === 'ses' && sesClient) {
        const command = new SendEmailCommand({
          Source: `${fromName} <${fromEmail}>`,
          Destination: {
            ToAddresses: [to],
          },
          Message: {
            Subject: {
              Data: subject,
              Charset: 'UTF-8',
            },
            Body: {
              ...(finalHtml && {
                Html: {
                  Data: finalHtml,
                  Charset: 'UTF-8',
                },
              }),
              ...(finalText && {
                Text: {
                  Data: finalText,
                  Charset: 'UTF-8',
                },
              }),
            },
          },
          ReplyToAddresses: replyTo ? [replyTo] : undefined,
        });

        const result = await sesClient.send(command);
        messageId = result.MessageId || `ses_${Date.now()}`;
        console.log(`[Amazon SES] ${type} email sent to ${to} (campaign: ${campaign || 'none'})`);
      }
      // ========== BREVO ==========
      else if (provider === 'brevo' && brevoApi) {
        const sendSmtpEmail = new SibApiV3Sdk.SendSmtpEmail();
        sendSmtpEmail.subject = subject;
        if (finalHtml) sendSmtpEmail.htmlContent = finalHtml;
        if (finalText) sendSmtpEmail.textContent = finalText;
        sendSmtpEmail.sender = { name: fromName, email: fromEmail };
        sendSmtpEmail.to = [{ email: to }];
        sendSmtpEmail.tags = [type, campaign, ...tags.map(t => t.value || t.name || t)].filter(Boolean);
        if (replyTo) sendSmtpEmail.replyTo = { email: replyTo };

        const result = await brevoApi.sendTransacEmail(sendSmtpEmail);
        messageId = result.body?.messageId || result.messageId;
        console.log(`[Brevo] ${type} email sent to ${to} (campaign: ${campaign || 'none'})`);
      }
      // ========== SENDGRID ==========
      else if (provider === 'sendgrid' && process.env.SENDGRID_API_KEY) {
        const msg = {
          to,
          from: { name: fromName, email: fromEmail },
          subject,
          html: finalHtml,
          text: finalText,
        };
        if (replyTo) msg.replyTo = replyTo;

        const result = await sgMail.send(msg);
        messageId = result[0]?.headers?.['x-message-id'] || `sg_${Date.now()}`;
        console.log(`[SendGrid] ${type} email sent to ${to} (campaign: ${campaign || 'none'})`);
      }
      // ========== MAILERSEND ==========
      else if (provider === 'mailersend' && mailerSendClient) {
        const sentFrom = new Sender(fromEmail, fromName);
        const recipients = [new Recipient(to)];

        const emailParams = new EmailParams()
          .setFrom(sentFrom)
          .setTo(recipients)
          .setSubject(subject);

        if (finalHtml) emailParams.setHtml(finalHtml);
        if (finalText) emailParams.setText(finalText);
        if (replyTo) emailParams.setReplyTo({ email: replyTo });

        const result = await mailerSendClient.email.send(emailParams);
        messageId = result?.headers?.['x-message-id'] || `ms_${Date.now()}`;
        console.log(`[MailerSend] ${type} email sent to ${to} (campaign: ${campaign || 'none'})`);
      }
      // ========== MAILGUN ==========
      else if (provider === 'mailgun' && mailgunClient) {
        const result = await mailgunClient.messages.create(process.env.MAILGUN_DOMAIN, {
          from: `${fromName} <${fromEmail}>`,
          to: [to],
          subject,
          html: finalHtml,
          text: finalText,
          'h:Reply-To': replyTo || undefined,
        });
        messageId = result.id;
        console.log(`[Mailgun] ${type} email sent to ${to} (campaign: ${campaign || 'none'})`);
      }
      // ========== RESEND ==========
      else if (provider === 'resend' && resend) {
        const resendTags = [...tags];
        if (campaign && !resendTags.find(t => t.name === 'campaign')) {
          resendTags.push({ name: 'campaign', value: campaign });
        }
        if (!resendTags.find(t => t.name === 'type')) {
          resendTags.push({ name: 'type', value: type });
        }

        const emailOptions = {
          from: fromAddress,
          to,
          subject,
          tags: resendTags,
        };
        if (finalHtml) emailOptions.html = finalHtml;
        if (finalText) emailOptions.text = finalText;
        if (replyTo) emailOptions.replyTo = replyTo;

        const result = await resend.emails.send(emailOptions);
        messageId = result.id;
        console.log(`[Resend] ${type} email sent to ${to} (campaign: ${campaign || 'none'})`);
      }
      // ========== NO PROVIDER ==========
      else {
        throw new Error(`Provider ${provider} not available`);
      }

      // SUCCESS - Log and return
      // Invalidate cache so next email picks fresh counts
      providerCountCache.lastUpdated = 0;

      // Log successful email to DB (non-blocking)
      pool.query(
        `INSERT INTO email_logs (to_email, subject, type, campaign, provider, status, message_id, sent_at)
         VALUES ($1, $2, $3, $4, $5, 'sent', $6, NOW())`,
        [to, subject.substring(0, 255), type, campaign, provider, messageId]
      ).catch(logErr => console.error('[Email Log] Failed to log:', logErr.message));

      // Log API call for cost tracking
      logApiCall({
        provider,
        endpoint: 'sendEmail',
        metadata: { type, campaign, to: to.substring(0, 50) },
      });

      return { success: true, provider, messageId };

    } catch (providerError) {
      console.error(`[${provider}] Failed: ${providerError.message}`);

      // Try next available provider
      const nextProviders = ['brevo', 'mailersend', 'mailgun', 'sendgrid', 'resend'].filter(p => !triedProviders.has(p));
      if (nextProviders.length === 0) {
        error = providerError.message;
        break;
      }

      // Find next provider that's actually available
      for (const next of nextProviders) {
        if (next === 'brevo' && brevoApi) { provider = next; break; }
        if (next === 'mailersend' && mailerSendClient) { provider = next; break; }
        if (next === 'sendgrid' && process.env.SENDGRID_API_KEY) { provider = next; break; }
        if (next === 'mailgun' && mailgunClient) { provider = next; break; }
        if (next === 'resend' && resend) { provider = next; break; }
      }
      console.log(`[Email] Falling back to ${provider}...`);
    }
  }

  // All providers failed
  console.error(`[Email] All providers failed for ${to}:`, error);

  // Log failed email to DB (non-blocking)
  pool.query(
    `INSERT INTO email_logs (to_email, subject, type, campaign, provider, status, error, sent_at)
     VALUES ($1, $2, $3, $4, $5, 'failed', $6, NOW())`,
    [to, subject.substring(0, 255), type, campaign, provider, error]
  ).catch(logErr => console.error('[Email Log] Failed to log error:', logErr.message));

  throw new Error(`All email providers failed: ${error}`);
}

// ==========================================
// ANTI-SPAM SYSTEM (Only for Outreach Emails)
// ==========================================
// WICHTIG: Diese Checks gelten NUR fÃ¼r Outreach/Marketing Emails!
// Transaktionale Emails (Passwort-Reset, Registrierung, etc.) sind NICHT betroffen.

const MAX_EMAILS_PER_WEEK = 4; // Max outreach emails per recipient per week

// Check if email format is valid
function isValidEmailFormat(email) {
  if (!email || typeof email !== 'string') return false;
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email.trim());
}

// Check if email is on suppression list (bounces, complaints)
async function isEmailSuppressed(email) {
  try {
    const result = await dbGet(
      'SELECT reason FROM email_suppressions WHERE LOWER(email_address) = LOWER($1)',
      [email]
    );
    return result ? { suppressed: true, reason: result.reason } : { suppressed: false };
  } catch (err) {
    // Table might not exist yet
    return { suppressed: false };
  }
}

// Check if we've sent too many emails to this recipient recently
async function isOverEmailFrequencyLimit(email) {
  try {
    const result = await dbGet(
      `SELECT COUNT(*) as count FROM email_logs
       WHERE LOWER(to_email) = LOWER($1)
       AND type = 'outreach'
       AND sent_at > NOW() - INTERVAL '7 days'`,
      [email]
    );
    const count = parseInt(result?.count || 0);
    return { overLimit: count >= MAX_EMAILS_PER_WEEK, count };
  } catch (err) {
    return { overLimit: false, count: 0 };
  }
}

// Add email to suppression list
async function suppressEmail(email, reason = 'bounce', details = null) {
  try {
    await pool.query(
      `INSERT INTO email_suppressions (email_address, reason, details, created_at)
       VALUES ($1, $2, $3, NOW())
       ON CONFLICT (email_address, reason) DO UPDATE SET details = $3, created_at = NOW()`,
      [email.toLowerCase(), reason, details]
    );
    console.log(`ðŸ“§ Suppressed: ${email} (${reason})`);
    return true;
  } catch (err) {
    console.error(`[suppressEmail] Error: ${err.message}`);
    return false;
  }
}

// Full anti-spam check for outreach emails
async function canSendOutreachEmail(email) {
  // 1. Format check
  if (!isValidEmailFormat(email)) {
    return { canSend: false, reason: 'invalid_format' };
  }

  // 2. Suppression check
  const suppression = await isEmailSuppressed(email);
  if (suppression.suppressed) {
    return { canSend: false, reason: `suppressed_${suppression.reason}` };
  }

  // 3. Frequency check
  const frequency = await isOverEmailFrequencyLimit(email);
  if (frequency.overLimit) {
    return { canSend: false, reason: `frequency_limit_${frequency.count}` };
  }

  return { canSend: true };
}

// ==========================================
// OUTREACH EMAIL HELPER - WITH OPEN TRACKING
// ==========================================
// Wrapper around sendEmail() for backwards compatibility
// Automatically adds tracking pixel and uses 'outreach' type
// Checks unsubscribe list before sending (CAN-SPAM compliance)
// INCLUDES ANTI-SPAM CHECKS (frequency cap, suppression list)

async function sendOutreachEmail({ to, subject, html, campaign = 'main', tags = [] }) {
  // ANTI-SPAM CHECK (only for outreach, not transactional!)
  try {
    const spamCheck = await canSendOutreachEmail(to);
    if (!spamCheck.canSend) {
      console.log(`ðŸ“§ Skipped (${spamCheck.reason}): ${to}`);
      return { success: false, skipped: true, reason: spamCheck.reason };
    }
  } catch (err) {
    console.log(`[Anti-Spam check] Warning: ${err.message}`);
  }

  // BOUNCE PREDICTION - Skip suspicious emails before sending
  try {
    const suspiciousCheck = isSuspiciousEmail(to);
    if (suspiciousCheck.suspicious) {
      console.log(`âš ï¸ Suspicious email skipped: ${to} (${suspiciousCheck.reason})`);
      // Track for analytics
      await dbQuery(
        `INSERT INTO outreach_skipped (email, reason, checked_at) VALUES ($1, $2, NOW())
         ON CONFLICT (email) DO UPDATE SET reason = $2, checked_at = NOW()`,
        [to, `suspicious:${suspiciousCheck.reason}`]
      ).catch(() => {}); // Table might not exist
      return { success: false, skipped: true, reason: `suspicious:${suspiciousCheck.reason}` };
    }
  } catch (err) {
    console.log(`[Bounce prediction] Warning: ${err.message}`);
  }

  // Check if email is unsubscribed before sending
  try {
    const unsubscribed = await dbGet('SELECT 1 FROM unsubscribes WHERE LOWER(email) = LOWER($1)', [
      to,
    ]);
    if (unsubscribed) {
      console.log(`ðŸ“§ Skipped (unsubscribed): ${to}`);
      return { success: false, skipped: true, reason: 'unsubscribed' };
    }
  } catch (err) {
    // Table might not exist yet on first run, continue with send
    console.log(`[Unsubscribe check] Warning: ${err.message}`);
  }

  // Add unsubscribe footer if not already present (CAN-SPAM compliance)
  let finalHtml = html;
  if (!html.includes('/api/outreach/unsubscribe')) {
    const baseUrl =
      process.env.NODE_ENV === 'production'
        ? 'https://review-responder.onrender.com'
        : 'http://localhost:3001';
    const unsubscribeLink = `${baseUrl}/api/outreach/unsubscribe?email=${encodeURIComponent(to)}`;
    const unsubscribeFooter = `
<br><br>
<div style="border-top: 1px solid #E5E7EB; padding-top: 16px; margin-top: 24px; font-size: 12px; color: #9CA3AF; text-align: center; line-height: 1.5;">
  <p style="margin: 0 0 8px 0;">You're receiving this because we thought ReviewResponder could help your business.</p>
  <p style="margin: 0;">Don't want to hear from us? <a href="${unsubscribeLink}" style="color: #6B7280; text-decoration: underline;">Unsubscribe instantly</a></p>
  <p style="margin: 12px 0 0 0; color: #D1D5DB;">ReviewResponder | Berlin, Germany</p>
</div>`;
    finalHtml = html + unsubscribeFooter;
  }

  return sendEmail({
    to,
    subject,
    html: finalHtml,
    type: 'outreach',
    campaign,
    tags,
    addTrackingPixel: true,
  });
}

// ==========================================
// EMAIL NOTIFICATION HELPER FUNCTIONS
// ==========================================

// Send Usage Alert Email (when user reaches 80% of limit)
async function sendUsageAlertEmail(user) {
  if (!resend && !brevoApi) return false;
  if (!user.email_usage_alerts) return false; // Respect user preference

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  try {
    await sendEmail({
      to: user.email,
      subject: "You've used 80% of your monthly responses",
      type: 'transactional',
      campaign: 'usage_alert',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
            .content { background: white; padding: 30px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
            .progress-bar { background: #E5E7EB; border-radius: 999px; height: 12px; margin: 20px 0; }
            .progress-fill { background: #F59E0B; border-radius: 999px; height: 12px; width: 80%; }
            .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
            .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>Usage Alert</h1>
              <p>You're running low on responses</p>
            </div>
            <div class="content">
              <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>

              <p>You've used <strong>80%</strong> of your monthly response limit on your <strong>${user.subscription_plan}</strong> plan.</p>

              <div class="progress-bar">
                <div class="progress-fill"></div>
              </div>

              <p>To ensure uninterrupted service, consider upgrading your plan:</p>

              <p style="text-align: center; margin: 30px 0;">
                <a href="${FRONTEND_URL}/pricing" class="cta-button">View Upgrade Options</a>
              </p>

              <p style="color: #6B7280; font-size: 14px;">Or continue using your remaining responses - they'll reset at the start of your next billing cycle.</p>
            </div>
            <div class="footer">
              <p>ReviewResponder - AI-Powered Review Responses</p>
              <p><a href="${FRONTEND_URL}/profile" style="color: #6B7280;">Manage notification preferences</a></p>
            </div>
          </div>
        </body>
        </html>
      `,
    });
    console.log(`[Email] Usage alert sent to ${user.email}`);
    return true;
  } catch (error) {
    console.error('[Email] Failed to send usage alert:', error.message);
    return false;
  }
}

// Send Flash Offer Email (when free user hits 20/20 limit)
// SAFEGUARDS: Max 1 per user ever, tracked via flash_offer_sent_at
async function sendFlashOfferEmail(user) {
  if (!resend && !brevoApi) return false;
  if (user.flash_offer_sent_at) return false; // Already sent
  if (user.subscription_plan !== 'free') return false; // Only for free users

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';
  // 2-hour expiry timestamp
  const expiresAt = new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString();
  const discountUrl = `${FRONTEND_URL}/pricing?discount=FLASH50&expires=${encodeURIComponent(expiresAt)}`;

  try {
    await sendEmail({
      to: user.email,
      subject: "Your responses are ready - 50% off expires in 2 hours",
      type: 'transactional',
      campaign: 'flash_offer',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
            .content { background: white; padding: 30px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
            .timer { background: #FEF2F2; border: 2px solid #EF4444; border-radius: 8px; padding: 20px; text-align: center; margin: 20px 0; }
            .timer-text { font-size: 24px; font-weight: bold; color: #EF4444; }
            .cta-button { display: inline-block; background: #EF4444; color: white; padding: 16px 32px; text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 18px; }
            .price { text-decoration: line-through; color: #9CA3AF; }
            .new-price { color: #EF4444; font-weight: bold; font-size: 24px; }
            .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>You've Hit Your Limit!</h1>
              <p>But here's a one-time offer just for you</p>
            </div>
            <div class="content">
              <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>

              <p>You've used all <strong>20 free responses</strong> - that means you've seen the value ReviewResponder brings to your business.</p>

              <div class="timer">
                <p style="margin: 0; color: #6B7280;">This offer expires in</p>
                <p class="timer-text">2 HOURS</p>
              </div>

              <p style="text-align: center;">
                <span class="price">$29/month</span><br>
                <span class="new-price">$14.50/month</span><br>
                <small style="color: #6B7280;">50% off your first month</small>
              </p>

              <p style="text-align: center; margin: 30px 0;">
                <a href="${discountUrl}" class="cta-button">Claim 50% Off Now</a>
              </p>

              <p style="color: #6B7280; font-size: 14px; text-align: center;">This is a one-time offer. Once it expires, it's gone forever.</p>
            </div>
            <div class="footer">
              <p>ReviewResponder - AI-Powered Review Responses</p>
            </div>
          </div>
        </body>
        </html>
      `,
    });
    console.log(`[Flash Offer] Sent to ${user.email}`);
    return true;
  } catch (error) {
    console.error('[Flash Offer] Failed to send:', error.message);
    return false;
  }
}

// Send Checkout Abandonment Email (when checkout session expires)
// SAFEGUARD: Max 1 per user per week
async function sendCheckoutAbandonmentEmail(user, plan) {
  if (!resend && !brevoApi) return false;

  // Check if we sent one recently (within 7 days)
  if (user.last_abandonment_email_at) {
    const daysSince = (Date.now() - new Date(user.last_abandonment_email_at).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 7) return false;
  }

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';
  const pricingUrl = `${FRONTEND_URL}/pricing?discount=COMEBACK20`;

  try {
    await sendEmail({
      to: user.email,
      subject: "Your checkout didn't complete - here's 20% off",
      type: 'transactional',
      campaign: 'checkout_abandonment',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
            .content { background: white; padding: 30px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
            .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
            .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>Something went wrong?</h1>
            </div>
            <div class="content">
              <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>

              <p>I noticed you started checking out for the <strong>${plan || 'Starter'}</strong> plan but didn't finish.</p>

              <p>No worries - here's <strong>20% off</strong> if you want to complete your upgrade:</p>

              <p style="text-align: center; margin: 30px 0;">
                <a href="${pricingUrl}" class="cta-button">Complete Your Upgrade (20% Off)</a>
              </p>

              <p style="color: #6B7280; font-size: 14px;">If you ran into any issues or have questions, just reply to this email. I'm here to help!</p>

              <p>Cheers,<br>Berend</p>
            </div>
            <div class="footer">
              <p>ReviewResponder - AI-Powered Review Responses</p>
            </div>
          </div>
        </body>
        </html>
      `,
    });
    console.log(`[Checkout Abandonment] Email sent to ${user.email}`);
    return true;
  } catch (error) {
    console.error('[Checkout Abandonment] Failed to send:', error.message);
    return false;
  }
}

// Send Plan Renewal Email (when subscription renews)
async function sendPlanRenewalEmail(user) {
  if (!resend && !brevoApi) return false;
  if (!user.email_billing_updates) return false; // Respect user preference

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  try {
    await sendEmail({
      to: user.email,
      subject: 'Your ReviewResponder subscription has renewed',
      type: 'transactional',
      campaign: 'billing',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
            .content { background: white; padding: 30px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
            .plan-box { background: #F0FDF4; border: 1px solid #10B981; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center; }
            .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
            .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>Subscription Renewed</h1>
              <p>Thank you for your continued support!</p>
            </div>
            <div class="content">
              <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>

              <p>Your ReviewResponder subscription has been successfully renewed.</p>

              <div class="plan-box">
                <p style="margin: 0; color: #059669; font-weight: 600;">Current Plan</p>
                <p style="margin: 10px 0 0 0; font-size: 24px; font-weight: bold;">${user.subscription_plan.charAt(0).toUpperCase() + user.subscription_plan.slice(1)}</p>
                <p style="margin: 5px 0 0 0; color: #6B7280;">Your response counter has been reset</p>
              </div>

              <p>Your monthly responses have been refreshed and you're ready to continue creating perfect review responses!</p>

              <p style="text-align: center; margin: 30px 0;">
                <a href="${FRONTEND_URL}/dashboard" class="cta-button">Go to Dashboard</a>
              </p>
            </div>
            <div class="footer">
              <p>ReviewResponder - AI-Powered Review Responses</p>
              <p><a href="${FRONTEND_URL}/profile" style="color: #6B7280;">Manage billing & notifications</a></p>
            </div>
          </div>
        </body>
        </html>
      `,
    });
    console.log(`[Email] Plan renewal sent to ${user.email}`);
    return true;
  } catch (error) {
    console.error('[Email] Failed to send plan renewal:', error.message);
    return false;
  }
}

// Middleware
app.use(helmet());

// CORS configuration - allow all origins for Chrome extension compatibility
// Security is handled via JWT tokens, not CORS
app.use(
  cors({
    origin: true, // Allow all origins - extension needs to work on any review site
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Admin-Key', 'X-API-Key'],
  })
);

// Stripe webhook needs raw body - must be before express.json()
app.post('/api/webhooks/stripe', express.raw({ type: 'application/json' }), handleStripeWebhook);

app.use(express.json());

// Rate limiting (increased for testing - 500 req/15min)
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 500,
  message: { error: 'Too many requests, please try again later.' },
});
app.use('/api/', limiter);

// Database helper functions
async function dbQuery(sql, params = []) {
  const client = await pool.connect();
  try {
    const result = await client.query(sql, params);
    return result;
  } finally {
    client.release();
  }
}

async function dbGet(sql, params = []) {
  const result = await dbQuery(sql, params);
  return result.rows[0] || null;
}

async function dbAll(sql, params = []) {
  const result = await dbQuery(sql, params);
  return result.rows;
}

// Initialize database tables
async function initDatabase() {
  try {
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        business_name TEXT,
        business_type TEXT,
        business_context TEXT,
        response_style TEXT,
        stripe_customer_id TEXT,
        subscription_status TEXT DEFAULT 'inactive',
        subscription_plan TEXT DEFAULT 'free',
        responses_used INTEGER DEFAULT 0,
        responses_limit INTEGER DEFAULT 20,
        current_period_start TIMESTAMP,
        current_period_end TIMESTAMP,
        onboarding_completed BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await dbQuery(`
      CREATE TABLE IF NOT EXISTS responses (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        review_text TEXT NOT NULL,
        review_rating INTEGER,
        review_platform TEXT,
        generated_response TEXT NOT NULL,
        tone TEXT DEFAULT 'professional',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await dbQuery(`
      CREATE TABLE IF NOT EXISTS support_requests (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT NOT NULL,
        subject TEXT NOT NULL,
        message TEXT NOT NULL,
        status TEXT DEFAULT 'new',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await dbQuery(`
      CREATE TABLE IF NOT EXISTS password_reset_tokens (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        token TEXT NOT NULL UNIQUE,
        expires_at TIMESTAMP NOT NULL,
        used BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await dbQuery(`
      CREATE TABLE IF NOT EXISTS response_templates (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        name TEXT NOT NULL,
        content TEXT NOT NULL,
        tone TEXT DEFAULT 'professional',
        platform TEXT DEFAULT 'google',
        category TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await dbQuery(`
      CREATE TABLE IF NOT EXISTS email_captures (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        discount_code TEXT DEFAULT 'WELCOME30',
        source TEXT DEFAULT 'exit_intent',
        converted BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add attribution columns to email_captures (for Widget Analytics)
    await dbQuery(`ALTER TABLE email_captures ADD COLUMN IF NOT EXISTS landing_page TEXT`);
    await dbQuery(`ALTER TABLE email_captures ADD COLUMN IF NOT EXISTS platform TEXT`);
    await dbQuery(`ALTER TABLE email_captures ADD COLUMN IF NOT EXISTS business_type TEXT`);

    // Public try usage tracking (for InstantDemoWidget analytics)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS public_try_usage (
        id SERIAL PRIMARY KEY,
        ip_hash TEXT NOT NULL,
        review_length INTEGER,
        tone TEXT,
        platform TEXT,
        business_type TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Personalized discount links
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS discount_links (
        id SERIAL PRIMARY KEY,
        token TEXT UNIQUE NOT NULL,
        discount_code TEXT NOT NULL,
        recipient_name TEXT,
        business_name TEXT,
        email TEXT,
        expires_at TIMESTAMP,
        views INTEGER DEFAULT 0,
        claimed BOOLEAN DEFAULT FALSE,
        source TEXT DEFAULT 'outreach',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Pre-registration drip email tracking
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS pre_registration_drips (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        email_day INTEGER NOT NULL,
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(email, email_day)
      )
    `);

    await dbQuery(`
      CREATE TABLE IF NOT EXISTS team_members (
        id SERIAL PRIMARY KEY,
        team_owner_id INTEGER NOT NULL REFERENCES users(id),
        member_email TEXT NOT NULL,
        member_user_id INTEGER REFERENCES users(id),
        role TEXT DEFAULT 'member',
        invite_token TEXT,
        invited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        accepted_at TIMESTAMP,
        UNIQUE(team_owner_id, member_email)
      )
    `);

    // API Keys table for public API access
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS api_keys (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        key_hash TEXT NOT NULL UNIQUE,
        key_prefix TEXT NOT NULL,
        name TEXT DEFAULT 'Default API Key',
        requests_today INTEGER DEFAULT 0,
        requests_total INTEGER DEFAULT 0,
        last_request_at TIMESTAMP,
        last_reset_date DATE DEFAULT CURRENT_DATE,
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add onboarding_completed column if it doesn't exist
    try {
      await dbQuery(`
        ALTER TABLE users ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE
      `);
    } catch (error) {
      // Column might already exist, that's okay
    }

    // User Feedback / Testimonials table
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS user_feedback (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
        comment TEXT,
        user_name TEXT,
        approved BOOLEAN DEFAULT FALSE,
        featured BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add feedback_submitted column to users table
    try {
      await dbQuery(`
        ALTER TABLE users ADD COLUMN IF NOT EXISTS feedback_submitted BOOLEAN DEFAULT FALSE
      `);
    } catch (error) {
      // Column might already exist
    }

    // Drip email tracking table
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS drip_emails (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        email_day INTEGER NOT NULL,
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, email_day)
      )
    `);

    // Blog articles table for SEO content generation
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS blog_articles (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        meta_description TEXT,
        keywords TEXT,
        topic TEXT,
        tone TEXT DEFAULT 'informative',
        word_count INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add public blog columns to blog_articles table
    try {
      await dbQuery(`ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS slug TEXT UNIQUE`);
      await dbQuery(
        `ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS is_published BOOLEAN DEFAULT FALSE`
      );
      await dbQuery(`ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS published_at TIMESTAMP`);
      await dbQuery(`ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS category TEXT`);
      await dbQuery(`ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS read_time_minutes INTEGER`);
      await dbQuery(
        `ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS view_count INTEGER DEFAULT 0`
      );
      await dbQuery(
        `ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS is_auto_generated BOOLEAN DEFAULT FALSE`
      );
      await dbQuery(
        `ALTER TABLE blog_articles ADD COLUMN IF NOT EXISTS author_name TEXT DEFAULT 'ReviewResponder Team'`
      );
      // Index for fast public blog queries
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_blog_published ON blog_articles(is_published, published_at DESC)`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Referrals table for referral system
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS referrals (
        id SERIAL PRIMARY KEY,
        referrer_id INTEGER NOT NULL REFERENCES users(id),
        referred_email TEXT NOT NULL,
        referred_user_id INTEGER REFERENCES users(id),
        status TEXT DEFAULT 'pending',
        reward_given BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        converted_at TIMESTAMP,
        UNIQUE(referrer_id, referred_email)
      )
    `);

    // Add referral columns to users table
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS referral_code TEXT UNIQUE`);
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS referred_by INTEGER REFERENCES users(id)`
      );
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS referral_credits INTEGER DEFAULT 0`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Add UTM tracking columns to users table for Google Ads attribution
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS utm_source TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS utm_medium TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS utm_campaign TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS utm_content TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS utm_term TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS landing_page TEXT`);
    } catch (error) {
      // Columns might already exist
    }

    // Outreach email tracking table
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS outreach_tracking (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        campaign TEXT NOT NULL,
        opened_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        ip_address TEXT,
        user_agent TEXT
      )
    `);

    // Add index for faster lookups
    try {
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_outreach_email ON outreach_tracking(email)`);
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_outreach_campaign ON outreach_tracking(campaign)`
      );
    } catch (error) {
      // Index might already exist
    }

    // Outreach click tracking table
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS outreach_clicks (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        campaign TEXT NOT NULL,
        clicked_url TEXT,
        clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        ip_address TEXT,
        user_agent TEXT
      )
    `);

    // Add indexes for click tracking
    try {
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_outreach_clicks_email ON outreach_clicks(email)`
      );
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_outreach_clicks_campaign ON outreach_clicks(campaign)`
      );
    } catch (error) {
      // Index might already exist
    }

    // Unified email logs table (for dashboard - tracks all emails from all providers)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS email_logs (
        id SERIAL PRIMARY KEY,
        to_email TEXT NOT NULL,
        subject TEXT,
        type TEXT NOT NULL,
        campaign TEXT,
        provider TEXT NOT NULL,
        status TEXT DEFAULT 'pending',
        message_id TEXT,
        error TEXT,
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        opened_at TIMESTAMP,
        clicked_at TIMESTAMP
      )
    `);

    // Add indexes for email logs
    try {
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_email_logs_type ON email_logs(type)`);
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_email_logs_provider ON email_logs(provider)`);
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_email_logs_sent_at ON email_logs(sent_at)`);
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_email_logs_campaign ON email_logs(campaign)`);
    } catch (error) {
      // Indexes might already exist
    }

    // API Call Logs for cost tracking
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS api_call_logs (
        id SERIAL PRIMARY KEY,
        provider VARCHAR(50) NOT NULL,
        model VARCHAR(100),
        endpoint VARCHAR(255),
        user_id INTEGER REFERENCES users(id),
        input_tokens INTEGER DEFAULT 0,
        output_tokens INTEGER DEFAULT 0,
        total_tokens INTEGER DEFAULT 0,
        estimated_cost DECIMAL(10,6) DEFAULT 0,
        status VARCHAR(20) DEFAULT 'success',
        error_message TEXT,
        metadata JSONB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Indexes for API call logs
    try {
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_api_logs_provider ON api_call_logs(provider)`);
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_api_logs_created ON api_call_logs(created_at)`);
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_api_logs_user ON api_call_logs(user_id)`);
    } catch (error) {
      // Indexes might already exist
    }

    // Demo generations table for personalized outreach demos
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS demo_generations (
        id SERIAL PRIMARY KEY,
        business_name TEXT NOT NULL,
        google_place_id TEXT,
        google_maps_url TEXT,
        city TEXT,
        google_rating DECIMAL(2,1),
        total_reviews INTEGER,
        scraped_reviews JSONB,
        demo_token TEXT UNIQUE NOT NULL,
        generated_responses JSONB,
        lead_id INTEGER REFERENCES outreach_leads(id),
        email_sent_at TIMESTAMP,
        email_opened_at TIMESTAMP,
        demo_page_viewed_at TIMESTAMP,
        converted_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Index for fast demo lookups
    try {
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_demo_token ON demo_generations(demo_token)`);
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_demo_lead ON demo_generations(lead_id)`);
    } catch (error) {
      // Index might already exist
    }

    // Affiliates table for affiliate/partner program
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS affiliates (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) UNIQUE,
        affiliate_code TEXT NOT NULL UNIQUE,
        commission_rate DECIMAL(5,2) DEFAULT 20.00,
        payout_method TEXT DEFAULT 'paypal',
        payout_email TEXT,
        total_earned DECIMAL(10,2) DEFAULT 0.00,
        total_paid DECIMAL(10,2) DEFAULT 0.00,
        pending_balance DECIMAL(10,2) DEFAULT 0.00,
        status TEXT DEFAULT 'pending',
        website TEXT,
        marketing_channels TEXT,
        audience_size TEXT,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        approved_at TIMESTAMP,
        CONSTRAINT valid_status CHECK (status IN ('pending', 'approved', 'rejected', 'suspended'))
      )
    `);

    // Affiliate clicks tracking
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS affiliate_clicks (
        id SERIAL PRIMARY KEY,
        affiliate_id INTEGER NOT NULL REFERENCES affiliates(id),
        ip_address TEXT,
        user_agent TEXT,
        referrer TEXT,
        clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Affiliate conversions (when referred user pays)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS affiliate_conversions (
        id SERIAL PRIMARY KEY,
        affiliate_id INTEGER NOT NULL REFERENCES affiliates(id),
        referred_user_id INTEGER NOT NULL REFERENCES users(id),
        subscription_plan TEXT NOT NULL,
        amount_paid DECIMAL(10,2) NOT NULL,
        commission_amount DECIMAL(10,2) NOT NULL,
        commission_rate DECIMAL(5,2) NOT NULL,
        stripe_invoice_id TEXT,
        status TEXT DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        paid_at TIMESTAMP,
        CONSTRAINT conversion_status CHECK (status IN ('pending', 'approved', 'paid', 'refunded'))
      )
    `);

    // Affiliate payouts
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS affiliate_payouts (
        id SERIAL PRIMARY KEY,
        affiliate_id INTEGER NOT NULL REFERENCES affiliates(id),
        amount DECIMAL(10,2) NOT NULL,
        payout_method TEXT NOT NULL,
        payout_email TEXT NOT NULL,
        status TEXT DEFAULT 'pending',
        transaction_id TEXT,
        notes TEXT,
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        processed_at TIMESTAMP,
        CONSTRAINT payout_status CHECK (status IN ('pending', 'processing', 'completed', 'failed'))
      )
    `);

    // Add affiliate_id column to users table for tracking who referred them
    try {
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS affiliate_id INTEGER REFERENCES affiliates(id)`
      );
    } catch (error) {
      // Column might already exist
    }

    // Add indexes for affiliate tables
    try {
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_affiliate_clicks ON affiliate_clicks(affiliate_id)`
      );
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_affiliate_conversions ON affiliate_conversions(affiliate_id)`
      );
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_affiliate_payouts ON affiliate_payouts(affiliate_id)`
      );
    } catch (error) {
      // Indexes might already exist
    }

    // Add OAuth columns for Google Sign-In
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS oauth_provider TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS oauth_id TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS profile_picture TEXT`);
      await dbQuery(`ALTER TABLE users ALTER COLUMN password DROP NOT NULL`);
    } catch (error) {
      // Columns might already exist or password column already nullable
    }

    // Add Smart AI / Standard AI usage tracking columns
    try {
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS smart_responses_used INTEGER DEFAULT 0`
      );
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS standard_responses_used INTEGER DEFAULT 0`
      );
      await dbQuery(
        `ALTER TABLE responses ADD COLUMN IF NOT EXISTS ai_model VARCHAR(20) DEFAULT 'standard'`
      );
      // Migrate existing usage to standard (backward compatibility)
      await dbQuery(
        `UPDATE users SET standard_responses_used = responses_used WHERE smart_responses_used = 0 AND standard_responses_used = 0 AND responses_used > 0`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Add email notification preferences columns
    try {
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS email_weekly_summary BOOLEAN DEFAULT TRUE`
      );
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS email_usage_alerts BOOLEAN DEFAULT TRUE`
      );
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS email_billing_updates BOOLEAN DEFAULT TRUE`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Add email change columns for secure email updates
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS email_change_token TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS email_change_new_email TEXT`);
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS email_change_expires_at TIMESTAMP`);
    } catch (error) {
      // Columns might already exist
    }

    // Add email verification columns (optional banner-based verification)
    try {
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verified BOOLEAN DEFAULT FALSE`
      );
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verification_token TEXT`);
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verification_expires_at TIMESTAMP`
      );
      // Flash offer tracking for limit-hit users
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS flash_offer_sent_at TIMESTAMP`
      );
      // Checkout abandonment tracking
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS last_abandonment_email_at TIMESTAMP`
      );
      // Magic link user tracking
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS created_via_magic_link BOOLEAN DEFAULT FALSE`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Add ai_response column to user_feedback for "dogfooding" section
    try {
      await dbQuery(`ALTER TABLE user_feedback ADD COLUMN IF NOT EXISTS ai_response TEXT`);
    } catch (error) {
      // Column might already exist
    }

    // Add business_name column to user_feedback for testimonial display
    try {
      await dbQuery(`ALTER TABLE user_feedback ADD COLUMN IF NOT EXISTS business_name TEXT`);
    } catch (error) {
      // Column might already exist
    }

    // Add AI context generation rate limiting columns
    try {
      await dbQuery(
        `ALTER TABLE users ADD COLUMN IF NOT EXISTS context_generations_today INTEGER DEFAULT 0`
      );
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS context_gen_reset_date TEXT`);
    } catch (error) {
      // Columns might already exist
    }

    // Add bonus_responses column for micro-pricing ($5 for 10 responses)
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS bonus_responses INTEGER DEFAULT 0`);
    } catch (error) {
      // Column might already exist
    }

    // Exit Surveys for conversion optimization
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS exit_surveys (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        reason TEXT NOT NULL,
        context TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Hot Demo Visitor tracking (Phase 3a)
    try {
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS demo_view_count INTEGER DEFAULT 0`
      );
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS hot_demo_followup_sent_at TIMESTAMP`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Exit Survey Response tracking (Phase 3b)
    try {
      await dbQuery(
        `ALTER TABLE exit_surveys ADD COLUMN IF NOT EXISTS response_sent_at TIMESTAMP`
      );
    } catch (error) {
      // Column might already exist
    }

    // === SALES AUTOMATION TABLES ===

    // Yelp Review Audit Leads
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS yelp_leads (
        id SERIAL PRIMARY KEY,
        business_name VARCHAR(255) NOT NULL,
        yelp_url TEXT,
        city VARCHAR(100),
        category VARCHAR(100),
        total_reviews INTEGER DEFAULT 0,
        owner_responses INTEGER DEFAULT 0,
        response_rate DECIMAL(5,2) DEFAULT 0,
        website VARCHAR(255),
        phone VARCHAR(50),
        email VARCHAR(255),
        email_source VARCHAR(50),
        email_sent BOOLEAN DEFAULT FALSE,
        email_sent_at TIMESTAMP,
        email_opened BOOLEAN DEFAULT FALSE,
        replied BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Competitor Leads (G2 negative reviews)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS competitor_leads (
        id SERIAL PRIMARY KEY,
        company_name VARCHAR(255) NOT NULL,
        reviewer_name VARCHAR(255),
        reviewer_title VARCHAR(255),
        competitor VARCHAR(100) NOT NULL,
        star_rating INTEGER,
        review_title TEXT,
        complaint_summary TEXT,
        review_date DATE,
        g2_url TEXT,
        website VARCHAR(255),
        email VARCHAR(255),
        email_source VARCHAR(50),
        email_sent BOOLEAN DEFAULT FALSE,
        email_sent_at TIMESTAMP,
        email_opened BOOLEAN DEFAULT FALSE,
        followup_sent BOOLEAN DEFAULT FALSE,
        followup_sent_at TIMESTAMP,
        replied BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add followup columns if missing (migration)
    await dbQuery(
      `ALTER TABLE competitor_leads ADD COLUMN IF NOT EXISTS followup_sent BOOLEAN DEFAULT FALSE`
    );
    await dbQuery(
      `ALTER TABLE competitor_leads ADD COLUMN IF NOT EXISTS followup_sent_at TIMESTAMP`
    );

    // LinkedIn Outreach Tracking
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS linkedin_outreach (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        title VARCHAR(255),
        company VARCHAR(255),
        location VARCHAR(255),
        linkedin_url TEXT NOT NULL,
        connection_sent BOOLEAN DEFAULT FALSE,
        connection_sent_at TIMESTAMP,
        connection_accepted BOOLEAN DEFAULT FALSE,
        connection_accepted_at TIMESTAMP,
        message_sent BOOLEAN DEFAULT FALSE,
        message_sent_at TIMESTAMP,
        followup_sent BOOLEAN DEFAULT FALSE,
        followup_sent_at TIMESTAMP,
        replied BOOLEAN DEFAULT FALSE,
        notes TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Agency Partnership Leads (Clutch.co)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS agency_leads (
        id SERIAL PRIMARY KEY,
        agency_name VARCHAR(255) NOT NULL,
        website VARCHAR(255),
        clutch_url TEXT,
        clutch_rating DECIMAL(3,2),
        num_reviews INTEGER,
        services TEXT,
        location VARCHAR(255),
        min_project_size VARCHAR(50),
        hourly_rate VARCHAR(50),
        employees VARCHAR(50),
        contact_name VARCHAR(255),
        email VARCHAR(255),
        email_source VARCHAR(50),
        email_sequence INTEGER DEFAULT 0,
        last_email_sent TIMESTAMP,
        email_opened BOOLEAN DEFAULT FALSE,
        replied BOOLEAN DEFAULT FALSE,
        interested BOOLEAN,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add indexes for sales automation tables
    try {
      await dbQuery(`CREATE INDEX IF NOT EXISTS idx_yelp_leads_city ON yelp_leads(city)`);
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_yelp_leads_email_sent ON yelp_leads(email_sent)`
      );
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_competitor_leads_competitor ON competitor_leads(competitor)`
      );
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_linkedin_outreach_sent ON linkedin_outreach(connection_sent)`
      );
      await dbQuery(
        `CREATE INDEX IF NOT EXISTS idx_agency_leads_sequence ON agency_leads(email_sequence)`
      );
    } catch (error) {
      // Indexes might already exist
    }

    // Add demo columns to linkedin_outreach for LinkedIn Demo Outreach feature
    try {
      await dbQuery(`ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS demo_token TEXT`);
      await dbQuery(`ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS demo_url TEXT`);
      await dbQuery(`ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS connection_note TEXT`);
      await dbQuery(`ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS business_name TEXT`);
      await dbQuery(`ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS google_place_id TEXT`);
      await dbQuery(
        `ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS google_rating DECIMAL(2,1)`
      );
      await dbQuery(
        `ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS demo_viewed_at TIMESTAMP`
      );
      await dbQuery(
        `ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS converted_at TIMESTAMP`
      );
    } catch (error) {
      // Columns might already exist
    }

    // Claude CLI Account Usage tracking (for Night-Burst account rotation)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS claude_account_usage (
        id SERIAL PRIMARY KEY,
        account_name VARCHAR(50) NOT NULL,
        email VARCHAR(255),
        date DATE NOT NULL,
        tokens_today BIGINT DEFAULT 0,
        tokens_week BIGINT DEFAULT 0,
        messages_today INTEGER DEFAULT 0,
        sessions_today INTEGER DEFAULT 0,
        synced_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(account_name, date)
      )
    `);

    console.log('ðŸ“Š Database initialized');
  } catch (error) {
    console.error('Database initialization error:', error);
    throw error;
  }
}

// JWT middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) return res.status(401).json({ error: 'Access denied' });

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
};

// API Key authentication middleware (for public API)
const authenticateApiKey = async (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  if (!apiKey) {
    return res.status(401).json({ error: 'API key required. Include X-API-Key header.' });
  }

  try {
    const keyHash = crypto.createHash('sha256').update(apiKey).digest('hex');
    const keyRecord = await dbGet(
      `SELECT ak.*, u.email, u.subscription_plan, u.subscription_status, u.business_name, u.business_type, u.business_context, u.response_style
       FROM api_keys ak
       JOIN users u ON ak.user_id = u.id
       WHERE ak.key_hash = $1 AND ak.is_active = TRUE`,
      [keyHash]
    );

    if (!keyRecord) {
      return res.status(401).json({ error: 'Invalid API key' });
    }

    if (keyRecord.subscription_plan !== 'unlimited' || keyRecord.subscription_status !== 'active') {
      return res.status(403).json({ error: 'API access requires an active Unlimited plan' });
    }

    const today = new Date().toISOString().split('T')[0];
    let requestsToday = keyRecord.requests_today;

    if (keyRecord.last_reset_date !== today) {
      await dbQuery(`UPDATE api_keys SET requests_today = 0, last_reset_date = $1 WHERE id = $2`, [
        today,
        keyRecord.id,
      ]);
      requestsToday = 0;
    }

    if (requestsToday >= 100) {
      return res.status(429).json({
        error: 'Rate limit exceeded. Maximum 100 requests per day.',
        reset_at: 'midnight UTC',
      });
    }

    await dbQuery(
      `UPDATE api_keys SET requests_today = requests_today + 1, requests_total = requests_total + 1, last_request_at = NOW() WHERE id = $1`,
      [keyRecord.id]
    );

    req.apiKeyUser = {
      id: keyRecord.user_id,
      email: keyRecord.email,
      subscription_plan: keyRecord.subscription_plan,
      business_name: keyRecord.business_name,
      business_type: keyRecord.business_type,
      business_context: keyRecord.business_context,
      response_style: keyRecord.response_style,
    };

    next();
  } catch (error) {
    console.error('API key auth error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
};

// Plan limits (monthly and yearly pricing)
// Smart AI = Claude (better quality), Standard = GPT-4o-mini (fast & cheap)
const PLAN_LIMITS = {
  free: {
    smartResponses: 3, // Claude - teaser to show quality
    standardResponses: 17, // GPT-4o-mini
    responses: 20, // Total (for backward compatibility)
    price: 0,
    teamMembers: 0,
  },
  starter: {
    smartResponses: 100,
    standardResponses: 200,
    responses: 300,
    price: 2900,
    yearlyPrice: 27840, // 20% off: $29 * 12 * 0.8 = $278.40
    priceId: process.env.STRIPE_STARTER_PRICE_ID,
    yearlyPriceId: process.env.STRIPE_STARTER_YEARLY_PRICE_ID,
    teamMembers: 0,
  },
  professional: {
    smartResponses: 300,
    standardResponses: 500,
    responses: 800,
    price: 4900,
    yearlyPrice: 47040, // 20% off: $49 * 12 * 0.8 = $470.40
    priceId: process.env.STRIPE_PRO_PRICE_ID,
    yearlyPriceId: process.env.STRIPE_PRO_YEARLY_PRICE_ID,
    teamMembers: 3,
  },
  unlimited: {
    smartResponses: 999999,
    standardResponses: 999999,
    responses: 999999,
    price: 9900,
    yearlyPrice: 95040, // 20% off: $99 * 12 * 0.8 = $950.40
    priceId: process.env.STRIPE_UNLIMITED_PRICE_ID,
    yearlyPriceId: process.env.STRIPE_UNLIMITED_YEARLY_PRICE_ID,
    teamMembers: 10,
  },
};

// ============ AUTH ROUTES ============

app.post('/api/auth/register', async (req, res) => {
  try {
    const {
      email,
      password,
      businessName,
      referralCode,
      affiliateCode,
      utmSource,
      utmMedium,
      utmCampaign,
      utmContent,
      utmTerm,
      landingPage,
      ref, // Demo conversion tracking: ref=demo_{token}
    } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    if (!validator.isEmail(email)) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    if (password.length < 8) {
      return res.status(400).json({ error: 'Password must be at least 8 characters' });
    }

    // Case-insensitive email check
    const existingUser = await dbGet('SELECT id FROM users WHERE LOWER(email) = LOWER($1)', [
      email,
    ]);
    if (existingUser) {
      return res.status(400).json({ error: 'Email already registered' });
    }

    // Check for valid referral code
    let referrerId = null;
    if (referralCode) {
      const referrer = await dbGet('SELECT id FROM users WHERE referral_code = $1', [
        referralCode.toUpperCase(),
      ]);
      if (referrer) {
        referrerId = referrer.id;
      }
    }

    // Check for valid affiliate code (for 20% recurring commission)
    let affiliateId = null;
    if (affiliateCode) {
      const affiliate = await dbGet(
        'SELECT id FROM affiliates WHERE affiliate_code = $1 AND status = $2',
        [affiliateCode.toUpperCase(), 'approved']
      );
      if (affiliate) {
        affiliateId = affiliate.id;
      }
    }

    const hashedPassword = await bcrypt.hash(password, 12);

    // Generate unique referral code for new user
    let newUserReferralCode;
    let attempts = 0;
    do {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      newUserReferralCode = 'REF-';
      for (let i = 0; i < 8; i++) {
        newUserReferralCode += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      const existing = await dbGet('SELECT id FROM users WHERE referral_code = $1', [
        newUserReferralCode,
      ]);
      if (!existing) break;
      attempts++;
    } while (attempts < 10);

    // Create Stripe customer
    const customer = await stripe.customers.create({
      email,
      metadata: {
        business_name: businessName || '',
        referred_by: referrerId || '',
        affiliate_id: affiliateId || '',
      },
    });

    const result = await dbQuery(
      `INSERT INTO users (email, password, business_name, stripe_customer_id, responses_limit, referral_code, referred_by, affiliate_id, utm_source, utm_medium, utm_campaign, utm_content, utm_term, landing_page)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) RETURNING id`,
      [
        email,
        hashedPassword,
        businessName || '',
        customer.id,
        PLAN_LIMITS.free.responses,
        newUserReferralCode,
        referrerId,
        affiliateId,
        utmSource || null,
        utmMedium || null,
        utmCampaign || null,
        utmContent || null,
        utmTerm || null,
        landingPage || null,
      ]
    );

    const userId = result.rows[0].id;

    // Create referral record if user was referred
    if (referrerId) {
      await dbQuery(
        `INSERT INTO referrals (referrer_id, referred_email, referred_user_id, status)
         VALUES ($1, $2, $3, 'registered')
         ON CONFLICT (referrer_id, referred_email) DO UPDATE SET referred_user_id = $3, status = 'registered'`,
        [referrerId, email, userId]
      );
      console.log(`âœ… User ${email} registered via referral from user ${referrerId}`);
    }

    // Log affiliate registration
    if (affiliateId) {
      console.log(`ðŸ¤ User ${email} registered via affiliate ID ${affiliateId}`);
    }

    // Track demo conversion if user came from demo page
    if (ref && ref.startsWith('demo_')) {
      const demoToken = ref.replace('demo_', '');
      try {
        await dbQuery(
          'UPDATE demo_generations SET converted_at = NOW() WHERE demo_token = $1 AND converted_at IS NULL',
          [demoToken]
        );
        console.log(`ðŸŽ¯ Demo conversion tracked: ${demoToken} -> user ${email}`);
      } catch (demoErr) {
        console.error('Failed to track demo conversion:', demoErr.message);
      }
    }

    // Generate email verification token and send verification email
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    await dbQuery(
      `UPDATE users SET email_verification_token = $1, email_verification_expires_at = $2 WHERE id = $3`,
      [verificationToken, verificationExpires, userId]
    );

    // Send verification email (non-blocking - user can still use app)
    if (resend || brevoApi) {
      const verifyUrl = `${process.env.FRONTEND_URL || 'https://tryreviewresponder.com'}/verify-email?token=${verificationToken}`;
      try {
        await sendEmail({
          to: email,
          subject: 'Verify your email - ReviewResponder',
          type: 'transactional',
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
                <h1 style="color: white; margin: 0;">Welcome to ReviewResponder!</h1>
              </div>
              <div style="padding: 30px; background: #f9fafb;">
                <p style="font-size: 16px; color: #374151;">Hi${businessName ? ' ' + businessName : ''},</p>
                <p style="font-size: 16px; color: #374151;">Thanks for signing up! Please verify your email address to get the most out of ReviewResponder.</p>
                <div style="text-align: center; margin: 30px 0;">
                  <a href="${verifyUrl}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">Verify Email</a>
                </div>
                <p style="font-size: 14px; color: #6b7280;">Or copy this link: <a href="${verifyUrl}" style="color: #667eea;">${verifyUrl}</a></p>
                <p style="font-size: 14px; color: #6b7280;">This link expires in 24 hours.</p>
                <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;">
                <p style="font-size: 12px; color: #9ca3af;">You're receiving this email because you signed up for ReviewResponder. If you didn't sign up, you can ignore this email.</p>
              </div>
            </div>
          `,
        });
        console.log(`[Email] Verification email sent to ${email}`);
      } catch (emailError) {
        console.error('Failed to send verification email:', emailError);
        // Don't fail registration if email fails - user can resend later
      }
    }

    const token = jwt.sign({ id: userId, email }, process.env.JWT_SECRET, { expiresIn: '7d' });

    res.status(201).json({
      token,
      user: {
        id: userId,
        email,
        businessName,
        plan: 'free',
        responsesUsed: 0,
        responsesLimit: PLAN_LIMITS.free.responses,
        onboardingCompleted: false,
        referralCode: newUserReferralCode,
        emailVerified: false,
      },
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Verify email endpoint
app.get('/api/auth/verify-email', async (req, res) => {
  try {
    const { token } = req.query;

    if (!token) {
      return res.status(400).json({ error: 'Verification token required' });
    }

    const user = await dbGet(
      `SELECT id, email, email_verified, email_verification_expires_at
       FROM users WHERE email_verification_token = $1`,
      [token]
    );

    if (!user) {
      return res.status(400).json({ error: 'Invalid verification token' });
    }

    if (user.email_verified) {
      return res.json({ success: true, message: 'Email already verified', alreadyVerified: true });
    }

    if (new Date() > new Date(user.email_verification_expires_at)) {
      return res
        .status(400)
        .json({ error: 'Verification token has expired. Please request a new one.' });
    }

    // Mark email as verified and clear token
    await dbQuery(
      `UPDATE users SET email_verified = TRUE, email_verification_token = NULL, email_verification_expires_at = NULL WHERE id = $1`,
      [user.id]
    );

    console.log(`âœ… Email verified for user ${user.email}`);
    res.json({ success: true, message: 'Email verified successfully' });
  } catch (error) {
    console.error('Verify email error:', error);
    res.status(500).json({ error: 'Failed to verify email' });
  }
});

// Resend verification email
app.post('/api/auth/resend-verification', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet(
      'SELECT id, email, email_verified, business_name FROM users WHERE id = $1',
      [req.user.id]
    );

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    if (user.email_verified) {
      return res.json({ success: true, message: 'Email already verified' });
    }

    // Generate new verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    await dbQuery(
      `UPDATE users SET email_verification_token = $1, email_verification_expires_at = $2 WHERE id = $3`,
      [verificationToken, verificationExpires, user.id]
    );

    // Send verification email
    if (resend || brevoApi) {
      const verifyUrl = `${process.env.FRONTEND_URL || 'https://tryreviewresponder.com'}/verify-email?token=${verificationToken}`;
      try {
        await sendEmail({
          to: user.email,
          subject: 'Verify your email - ReviewResponder',
          type: 'transactional',
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
                <h1 style="color: white; margin: 0;">Verify Your Email</h1>
              </div>
              <div style="padding: 30px; background: #f9fafb;">
                <p style="font-size: 16px; color: #374151;">Hi${user.business_name ? ' ' + user.business_name : ''},</p>
                <p style="font-size: 16px; color: #374151;">Click the button below to verify your email address.</p>
                <div style="text-align: center; margin: 30px 0;">
                  <a href="${verifyUrl}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">Verify Email</a>
                </div>
                <p style="font-size: 14px; color: #6b7280;">Or copy this link: <a href="${verifyUrl}" style="color: #667eea;">${verifyUrl}</a></p>
                <p style="font-size: 14px; color: #6b7280;">This link expires in 24 hours.</p>
              </div>
            </div>
          `,
        });
        console.log(`[Email] Verification email resent to ${user.email}`);
        res.json({ success: true, message: 'Verification email sent' });
      } catch (emailError) {
        console.error('Failed to resend verification email:', emailError);
        res.status(500).json({ error: 'Failed to send verification email' });
      }
    } else {
      res.status(500).json({ error: 'Email service not configured' });
    }
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({ error: 'Failed to resend verification email' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Case-insensitive email lookup
    const user = await dbGet('SELECT * FROM users WHERE LOWER(email) = LOWER($1)', [email]);
    if (!user) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }

    // Check if user has a password (OAuth users don't have one)
    if (!user.password) {
      return res.status(400).json({ error: 'Please sign in with Google' });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }

    // Check if user is a team member to get effective plan
    const teamMembership = await dbGet(
      `SELECT tm.*, u.email as owner_email, u.business_name as owner_business,
              u.subscription_plan as owner_plan, u.subscription_status as owner_status
       FROM team_members tm
       JOIN users u ON tm.team_owner_id = u.id
       WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
      [user.id]
    );

    let effectivePlan = user.subscription_plan || 'free';
    let effectiveStatus = user.subscription_status;
    let teamInfo = null;

    if (teamMembership) {
      effectivePlan = teamMembership.owner_plan || 'free';
      effectiveStatus = teamMembership.owner_status;
      teamInfo = {
        isTeamMember: true,
        teamOwnerEmail: teamMembership.owner_email,
        teamOwnerBusiness: teamMembership.owner_business,
        role: teamMembership.role,
      };
    }

    const token = jwt.sign({ id: user.id, email: user.email }, process.env.JWT_SECRET, {
      expiresIn: '7d',
    });

    res.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        businessName: user.business_name,
        plan: effectivePlan,
        ownPlan: user.subscription_plan,
        responsesUsed: user.responses_used,
        responsesLimit: user.responses_limit,
        subscriptionStatus: effectiveStatus,
        ownSubscriptionStatus: user.subscription_status,
        onboardingCompleted: user.onboarding_completed,
        teamInfo: teamInfo,
        emailVerified: user.email_verified || false,
      },
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

app.get('/api/auth/me', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if user is a team member to get effective plan
    const teamMembership = await dbGet(
      `SELECT tm.*, u.email as owner_email, u.business_name as owner_business,
              u.subscription_plan as owner_plan, u.subscription_status as owner_status,
              u.smart_responses_used as owner_smart_used, u.standard_responses_used as owner_standard_used
       FROM team_members tm
       JOIN users u ON tm.team_owner_id = u.id
       WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
      [req.user.id]
    );

    let effectivePlan = user.subscription_plan || 'free';
    let effectiveStatus = user.subscription_status;
    let teamInfo = null;

    if (teamMembership) {
      effectivePlan = teamMembership.owner_plan || 'free';
      effectiveStatus = teamMembership.owner_status;
      teamInfo = {
        isTeamMember: true,
        teamOwnerEmail: teamMembership.owner_email,
        teamOwnerBusiness: teamMembership.owner_business,
        role: teamMembership.role,
      };
    }

    res.json({
      user: {
        id: user.id,
        email: user.email,
        businessName: user.business_name,
        businessType: user.business_type,
        businessContext: user.business_context,
        responseStyle: user.response_style,
        plan: effectivePlan,
        ownPlan: user.subscription_plan,
        responsesUsed: user.responses_used,
        responsesLimit: user.responses_limit,
        subscriptionStatus: effectiveStatus,
        ownSubscriptionStatus: user.subscription_status,
        onboardingCompleted: user.onboarding_completed,
        referralCode: user.referral_code,
        referralCredits: user.referral_credits || 0,
        // Profile page additions
        createdAt: user.created_at,
        oauthProvider: user.oauth_provider,
        profilePicture: user.profile_picture,
        hasPassword: !!user.password,
        // Notification preferences
        emailWeeklySummary: user.email_weekly_summary ?? true,
        emailUsageAlerts: user.email_usage_alerts ?? true,
        emailBillingUpdates: user.email_billing_updates ?? true,
        // Smart/Standard AI usage
        smartResponsesUsed: user.smart_responses_used || 0,
        standardResponsesUsed: user.standard_responses_used || 0,
        // Team info
        teamInfo: teamInfo,
        // Email verification
        emailVerified: user.email_verified || false,
      },
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Failed to get user' });
  }
});

// Complete onboarding
app.put('/api/auth/complete-onboarding', authenticateToken, async (req, res) => {
  try {
    await dbQuery('UPDATE users SET onboarding_completed = TRUE WHERE id = $1', [req.user.id]);

    res.json({ success: true, message: 'Onboarding completed' });
  } catch (error) {
    console.error('Complete onboarding error:', error);
    res.status(500).json({ error: 'Failed to complete onboarding' });
  }
});

// Update business profile
app.put('/api/auth/profile', authenticateToken, async (req, res) => {
  try {
    const { businessName, businessType, businessContext, responseStyle } = req.body;

    await dbQuery(
      `UPDATE users SET business_name = $1, business_type = $2, business_context = $3, response_style = $4 WHERE id = $5`,
      [
        businessName || '',
        businessType || '',
        businessContext || '',
        responseStyle || '',
        req.user.id,
      ]
    );

    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    res.json({
      success: true,
      user: {
        id: user.id,
        email: user.email,
        businessName: user.business_name,
        businessType: user.business_type,
        businessContext: user.business_context,
        responseStyle: user.response_style,
        plan: user.subscription_plan,
        responsesUsed: user.responses_used,
        responsesLimit: user.responses_limit,
      },
    });
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

// ============ AI PERSONALIZATION ============

// Generate Business Context or Response Style with AI
app.post('/api/personalization/generate-context', authenticateToken, async (req, res) => {
  try {
    const { keywords, businessType, businessName, field, structured } = req.body;

    if (!keywords || keywords.trim().length === 0) {
      return res.status(400).json({ error: 'Keywords are required' });
    }

    if (!field || !['context', 'style', 'sample_review'].includes(field)) {
      return res
        .status(400)
        .json({ error: 'Field must be "context", "style", or "sample_review"' });
    }

    // Check if Anthropic is available
    if (!anthropic) {
      return res.status(503).json({ error: 'AI service not available' });
    }

    // Rate limiting: Max 10 generations per day per user
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    const today = new Date().toISOString().split('T')[0];

    // Reset counter if new day
    if (user.context_gen_reset_date !== today) {
      await dbQuery(
        'UPDATE users SET context_generations_today = 0, context_gen_reset_date = $1 WHERE id = $2',
        [today, req.user.id]
      );
    } else if ((user.context_generations_today || 0) >= 10) {
      return res.status(429).json({
        error: 'Daily limit reached (10 generations). Try again tomorrow.',
        remaining: 0,
      });
    }

    // Build the prompt based on field type
    let systemPrompt;
    let userMessage;

    if (field === 'context') {
      if (structured) {
        // Profile Page: Structured output with XML tags and placeholders
        // Using Anthropic prompt engineering best practices with XML tags
        systemPrompt = `<role>You create structured business profiles that help AI generate personalized review responses.</role>

<context>
Business Type: ${businessType || 'General Business'}
Business Name: ${businessName || 'the business'}
</context>

<instructions>
Create a business profile with EXACTLY these 3 sections. Use the keywords provided, but add helpful placeholders for any missing information.

Output format - use these EXACT headers:

YOUR STORY:
[Write 1-2 sentences about who runs the business, when/how it started, and why]

WHAT CUSTOMERS LOVE:
[List 3-5 specific things - dishes, services, products, atmosphere]

SIGN RESPONSES AS:
[Name for review signatures]
</instructions>

<placeholder_rules>
For ANY section where the user didn't provide enough info, add a placeholder like this:
â†’ Use brackets with examples: [ADD YOUR INFO - examples: "option 1", "option 2", "option 3"]

Examples of good placeholders:
- [YOUR FOUNDING YEAR - e.g., "since 1985", "est. 2010", "for over 20 years"]
- [YOUR SPECIALTIES - e.g., "wood-fired pizza", "organic coffee", "same-day repairs"]
- [YOUR NAME - e.g., "Marco", "The Smith Family", "Dr. Sarah & Team"]

The placeholders help users know exactly what info to add for better AI responses.
</placeholder_rules>

<output_format>
Write in first person plural (we, our).
Keep it authentic - avoid corporate buzzwords.
Output ONLY the 3 sections, no introduction or explanation.
</output_format>`;
      } else {
        // Onboarding: Simple flowing text (unchanged)
        systemPrompt = `You help a business owner create a professional description of their business.
This description will be used to personalize AI-generated responses to customer reviews.

Business Type: ${businessType || 'General Business'}
Business Name: ${businessName || 'the business'}

Create a professional business description (2-3 sentences) based on the keywords.
Focus on: unique selling points, atmosphere, what makes the business special.
Keep it authentic and not too promotional.
AVOID phrases like "We strive" or "We are committed".
Write in first person plural (we, our).
Respond ONLY with the generated text, no introduction or explanation.`;
      }
      userMessage = `Keywords: ${keywords.trim()}`;
    } else if (field === 'style') {
      // Response Style with XML tags for better AI parsing
      systemPrompt = `<role>You create response style guidelines using XML tags for clear structure.</role>

<context>
Business Type: ${businessType || 'General Business'}
Business Name: ${businessName || 'the business'}
</context>

<instructions>
Create response style guidelines based on the keywords. Use XML tags to structure the output.

Output format - use these EXACT XML tags:

<always>
- Things to always include in responses (2-3 bullet points)
</always>

<never>
- Things to never do or say (2-3 bullet points)
</never>

<style>
- Tone and style preferences (2-3 bullet points)
</style>

<signoff>
- How to sign off responses (1 line)
</signoff>
</instructions>

<rules>
- Each section should have 2-3 concise bullet points
- Keep points short and actionable
- Use the keywords provided to customize the guidelines
- Output ONLY the XML tags with content, no introduction
</rules>`;
      userMessage = `Keywords: ${keywords.trim()}`;
    } else if (field === 'sample_review') {
      // Generate a sample review that references the business context
      systemPrompt = `You create a realistic 5-star customer review for a business.
The review should subtly reference the business's unique features.

Business Type: ${businessType || 'General Business'}
Business Name: ${businessName || 'the business'}

Create an authentic, positive customer review (2 sentences MAX - keep it SHORT).
- Mention 1 specific detail from the business description
- Sound like a real customer (natural, not promotional)
Respond ONLY with the review text, no quotes.`;
      userMessage = `Business description: ${keywords.trim()}`;
    }

    // Use Claude Sonnet for best quality
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      messages: [{ role: 'user', content: `${systemPrompt}\n\n${userMessage}` }],
    });

    const generated = response.content[0].text.trim();

    // Update daily counter
    await dbQuery(
      'UPDATE users SET context_generations_today = COALESCE(context_generations_today, 0) + 1 WHERE id = $1',
      [req.user.id]
    );

    // Get remaining generations
    const remaining = 10 - ((user.context_generations_today || 0) + 1);

    res.json({
      generated,
      remaining: Math.max(0, remaining),
      tokensUsed: response.usage?.input_tokens + response.usage?.output_tokens || 0,
    });
  } catch (error) {
    console.error('Context generation error:', error);
    res.status(500).json({ error: 'Failed to generate context. Please try again.' });
  }
});

// ============ PROFILE & ACCOUNT MANAGEMENT ============

// Change Password (or Set Password for OAuth users)
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!newPassword) {
      return res.status(400).json({ error: 'New password required' });
    }

    if (newPassword.length < 8) {
      return res.status(400).json({ error: 'New password must be at least 8 characters' });
    }

    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // OAuth user - can always set/change password without current (Google is their primary auth)
    if (user.oauth_provider) {
      const hashedPassword = await bcrypt.hash(newPassword, 12);
      await dbQuery('UPDATE users SET password = $1 WHERE id = $2', [hashedPassword, req.user.id]);
      return res.json({
        success: true,
        message: 'Password set successfully! You can now login with email & password.',
      });
    }

    // Non-OAuth user - require current password
    if (!currentPassword) {
      return res.status(400).json({ error: 'Current password required' });
    }

    // Verify current password
    const validPassword = await bcrypt.compare(currentPassword, user.password);
    if (!validPassword) {
      return res.status(400).json({ error: 'Current password is incorrect' });
    }

    // Hash and save new password
    const hashedPassword = await bcrypt.hash(newPassword, 12);
    await dbQuery('UPDATE users SET password = $1 WHERE id = $2', [hashedPassword, req.user.id]);

    res.json({ success: true, message: 'Password changed successfully' });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({ error: 'Failed to change password' });
  }
});

// Request Email Change
app.post('/api/auth/change-email-request', authenticateToken, async (req, res) => {
  try {
    const { newEmail, password } = req.body;

    if (!newEmail || !validator.isEmail(newEmail)) {
      return res.status(400).json({ error: 'Valid email address required' });
    }

    // Check if email already exists
    const existing = await dbGet('SELECT id FROM users WHERE LOWER(email) = LOWER($1)', [newEmail]);
    if (existing) {
      return res.status(400).json({ error: 'This email is already in use' });
    }

    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Verify password if user has one (not pure OAuth)
    if (user.password) {
      if (!password) {
        return res.status(400).json({ error: 'Password required for verification' });
      }
      const validPassword = await bcrypt.compare(password, user.password);
      if (!validPassword) {
        return res.status(400).json({ error: 'Password is incorrect' });
      }
    }

    // Generate token
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    // Save token
    await dbQuery(
      `UPDATE users SET
        email_change_token = $1,
        email_change_new_email = $2,
        email_change_expires_at = $3
      WHERE id = $4`,
      [token, newEmail.toLowerCase(), expiresAt, req.user.id]
    );

    // Send confirmation email
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    const confirmUrl = `${frontendUrl}/confirm-email?token=${token}`;

    if (resend) {
      try {
        await resend.emails.send({
          from: FROM_EMAIL,
          to: newEmail,
          subject: 'Confirm Your New Email - ReviewResponder',
          html: `
            <h2>Confirm Your Email Change</h2>
            <p>Hi there,</p>
            <p>You requested to change your ReviewResponder account email to <strong>${newEmail}</strong>.</p>
            <p>Click the button below to confirm this change:</p>
            <p><a href="${confirmUrl}" style="background: #4f46e5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">Confirm Email Change</a></p>
            <p>Or copy this link: ${confirmUrl}</p>
            <p>This link will expire in 24 hours. If you didn't request this, you can safely ignore this email.</p>
            <p>Best regards,<br>ReviewResponder Team</p>
          `,
        });
      } catch (emailError) {
        console.error('Email send error:', emailError);
      }
    }

    res.json({
      success: true,
      message: `Confirmation email sent to ${newEmail}. Please check your inbox.`,
    });
  } catch (error) {
    console.error('Change email request error:', error);
    res.status(500).json({ error: 'Failed to process email change request' });
  }
});

// Confirm Email Change
app.post('/api/auth/confirm-email-change', async (req, res) => {
  try {
    const { token } = req.body;

    if (!token) {
      return res.status(400).json({ error: 'Token is required' });
    }

    // Validate token
    const user = await dbGet(
      `SELECT * FROM users
       WHERE email_change_token = $1
         AND email_change_expires_at > NOW()`,
      [token]
    );

    if (!user) {
      return res.status(400).json({ error: 'Invalid or expired confirmation link' });
    }

    const newEmail = user.email_change_new_email;

    // Check again if email is taken (race condition protection)
    const existing = await dbGet(
      'SELECT id FROM users WHERE LOWER(email) = LOWER($1) AND id != $2',
      [newEmail, user.id]
    );
    if (existing) {
      return res.status(400).json({ error: 'This email is already in use' });
    }

    // Update email
    await dbQuery(
      `UPDATE users SET
        email = $1,
        email_change_token = NULL,
        email_change_new_email = NULL,
        email_change_expires_at = NULL
      WHERE id = $2`,
      [newEmail, user.id]
    );

    // Update Stripe customer email
    if (user.stripe_customer_id) {
      try {
        await stripe.customers.update(user.stripe_customer_id, { email: newEmail });
      } catch (stripeError) {
        console.error('Stripe email update error:', stripeError);
      }
    }

    console.log(`âœ… User ${user.id} changed email from ${user.email} to ${newEmail}`);

    res.json({
      success: true,
      message: 'Email changed successfully',
      newEmail,
    });
  } catch (error) {
    console.error('Confirm email change error:', error);
    res.status(500).json({ error: 'Failed to confirm email change' });
  }
});

// Get Notification Settings
app.get('/api/settings/notifications', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet(
      'SELECT email_weekly_summary, email_usage_alerts, email_billing_updates FROM users WHERE id = $1',
      [req.user.id]
    );

    res.json({
      emailWeeklySummary: user.email_weekly_summary ?? true,
      emailUsageAlerts: user.email_usage_alerts ?? true,
      emailBillingUpdates: user.email_billing_updates ?? true,
    });
  } catch (error) {
    console.error('Get notification settings error:', error);
    res.status(500).json({ error: 'Failed to get notification settings' });
  }
});

// Update Notification Settings
app.put('/api/settings/notifications', authenticateToken, async (req, res) => {
  try {
    const { emailWeeklySummary, emailUsageAlerts, emailBillingUpdates } = req.body;

    await dbQuery(
      `UPDATE users SET
        email_weekly_summary = $1,
        email_usage_alerts = $2,
        email_billing_updates = $3
      WHERE id = $4`,
      [
        emailWeeklySummary ?? true,
        emailUsageAlerts ?? true,
        emailBillingUpdates ?? true,
        req.user.id,
      ]
    );

    res.json({
      success: true,
      message: 'Notification settings updated',
    });
  } catch (error) {
    console.error('Update notification settings error:', error);
    res.status(500).json({ error: 'Failed to update notification settings' });
  }
});

// Delete Account
app.delete('/api/auth/delete-account', authenticateToken, async (req, res) => {
  try {
    const { password, confirmation } = req.body;

    // Require typing DELETE
    if (confirmation !== 'DELETE') {
      return res.status(400).json({
        error: 'Please type DELETE to confirm account deletion',
      });
    }

    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Verify password if user has one
    if (user.password) {
      if (!password) {
        return res.status(400).json({ error: 'Password required for verification' });
      }
      const validPassword = await bcrypt.compare(password, user.password);
      if (!validPassword) {
        return res.status(400).json({ error: 'Password is incorrect' });
      }
    }

    // Cancel Stripe subscription and delete customer
    if (user.stripe_customer_id) {
      try {
        // Cancel all active subscriptions
        const subscriptions = await stripe.subscriptions.list({
          customer: user.stripe_customer_id,
          status: 'active',
        });

        for (const sub of subscriptions.data) {
          await stripe.subscriptions.cancel(sub.id);
        }

        // Delete Stripe customer
        await stripe.customers.del(user.stripe_customer_id);
        console.log(`ðŸ—‘ï¸ Deleted Stripe customer ${user.stripe_customer_id}`);
      } catch (stripeError) {
        console.error('Stripe cleanup error:', stripeError);
        // Continue with account deletion even if Stripe cleanup fails
      }
    }

    // Delete all user data
    await dbQuery('DELETE FROM responses WHERE user_id = $1', [req.user.id]);
    await dbQuery('DELETE FROM response_templates WHERE user_id = $1', [req.user.id]);
    await dbQuery('DELETE FROM team_members WHERE team_owner_id = $1 OR member_user_id = $1', [
      req.user.id,
    ]);
    await dbQuery('DELETE FROM api_keys WHERE user_id = $1', [req.user.id]);
    await dbQuery('DELETE FROM blog_articles WHERE user_id = $1', [req.user.id]);
    await dbQuery('DELETE FROM referrals WHERE referrer_id = $1', [req.user.id]);
    await dbQuery('DELETE FROM user_feedback WHERE user_id = $1', [req.user.id]);
    await dbQuery('DELETE FROM drip_emails WHERE user_id = $1', [req.user.id]);

    // Delete the user
    await dbQuery('DELETE FROM users WHERE id = $1', [req.user.id]);

    console.log(`ðŸ—‘ï¸ User ${user.email} (ID: ${user.id}) deleted their account`);

    res.json({
      success: true,
      message: 'Account deleted successfully',
    });
  } catch (error) {
    console.error('Delete account error:', error);
    res.status(500).json({ error: 'Failed to delete account' });
  }
});

// Google OAuth Sign-In
app.post('/api/auth/google', async (req, res) => {
  try {
    const { credential, referralCode, affiliateCode, utmParams, ref } = req.body;

    if (!credential) {
      return res.status(400).json({ error: 'Google credential is required' });
    }

    if (!googleClient) {
      return res
        .status(500)
        .json({ error: 'Google Sign-In is not configured. Please contact support.' });
    }

    // Verify the Google ID token
    let ticket;
    try {
      ticket = await googleClient.verifyIdToken({
        idToken: credential,
        audience: process.env.GOOGLE_CLIENT_ID,
      });
    } catch (verifyError) {
      console.error('Google token verification failed:', verifyError);
      return res.status(401).json({ error: 'Invalid Google credential' });
    }

    const payload = ticket.getPayload();
    const googleId = payload['sub'];
    const email = payload['email'];
    const name = payload['name'] || '';
    const picture = payload['picture'] || null;

    if (!email) {
      return res.status(400).json({ error: 'Email not provided by Google' });
    }

    // Check if user already exists (by email or Google ID)
    let user = await dbGet('SELECT * FROM users WHERE LOWER(email) = LOWER($1) OR oauth_id = $2', [
      email,
      googleId,
    ]);

    if (user) {
      // Existing user - update OAuth info and mark email as verified (Google verified it)
      if (!user.oauth_provider) {
        await dbQuery(
          'UPDATE users SET oauth_provider = $1, oauth_id = $2, profile_picture = $3, email_verified = TRUE WHERE id = $4',
          ['google', googleId, picture, user.id]
        );
      } else {
        // Update profile picture and ensure email is verified for Google users
        await dbQuery(
          'UPDATE users SET profile_picture = $1, email_verified = TRUE WHERE id = $2',
          [picture, user.id]
        );
      }

      // Check if user is a team member to get effective plan
      const teamMembership = await dbGet(
        `SELECT tm.*, u.email as owner_email, u.business_name as owner_business,
                u.subscription_plan as owner_plan, u.subscription_status as owner_status
         FROM team_members tm
         JOIN users u ON tm.team_owner_id = u.id
         WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
        [user.id]
      );

      let effectivePlan = user.subscription_plan || 'free';
      let effectiveStatus = user.subscription_status;
      let teamInfo = null;

      if (teamMembership) {
        effectivePlan = teamMembership.owner_plan || 'free';
        effectiveStatus = teamMembership.owner_status;
        teamInfo = {
          isTeamMember: true,
          teamOwnerEmail: teamMembership.owner_email,
          teamOwnerBusiness: teamMembership.owner_business,
          role: teamMembership.role,
        };
      }

      // Generate JWT token
      const token = jwt.sign({ id: user.id, email: user.email }, process.env.JWT_SECRET, {
        expiresIn: '7d',
      });

      return res.json({
        token,
        user: {
          id: user.id,
          email: user.email,
          businessName: user.business_name,
          businessType: user.business_type,
          businessContext: user.business_context,
          responseStyle: user.response_style,
          plan: effectivePlan,
          ownPlan: user.subscription_plan,
          responsesUsed: user.responses_used,
          responsesLimit: user.responses_limit,
          subscriptionStatus: effectiveStatus,
          ownSubscriptionStatus: user.subscription_status,
          onboardingCompleted: user.onboarding_completed,
          profilePicture: picture,
          referralCode: user.referral_code,
          teamInfo: teamInfo,
          emailVerified: true, // Google OAuth users are always verified
        },
      });
    }

    // New user - create account
    const newReferralCode = 'REF-' + crypto.randomBytes(4).toString('hex').toUpperCase();

    // Create Stripe customer
    let stripeCustomerId = null;
    try {
      const customer = await stripe.customers.create({
        email: email,
        name: name,
        metadata: { source: 'google_oauth' },
      });
      stripeCustomerId = customer.id;
    } catch (stripeError) {
      console.error('Stripe customer creation failed:', stripeError);
    }

    // Handle referral
    let referredById = null;
    if (referralCode) {
      const referrer = await dbGet('SELECT id FROM users WHERE referral_code = $1', [referralCode]);
      if (referrer) {
        referredById = referrer.id;
      }
    }

    // Handle affiliate
    let affiliateId = null;
    if (affiliateCode) {
      const affiliate = await dbGet(
        'SELECT id FROM affiliates WHERE code = $1 AND is_active = TRUE',
        [affiliateCode]
      );
      if (affiliate) {
        affiliateId = affiliate.id;
        await dbQuery(
          'INSERT INTO affiliate_clicks (affiliate_id, ip_address, user_agent) VALUES ($1, $2, $3)',
          [affiliateId, req.ip, req.headers['user-agent']]
        );
      }
    }

    // Insert new user (email_verified = true for Google OAuth users)
    const result = await dbQuery(
      `INSERT INTO users (
        email, password, business_name, oauth_provider, oauth_id, profile_picture,
        stripe_customer_id, referral_code, referred_by, affiliate_id,
        utm_source, utm_medium, utm_campaign, utm_content, utm_term, landing_page,
        email_verified
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17) RETURNING *`,
      [
        email,
        null, // No password for OAuth users
        name,
        'google',
        googleId,
        picture,
        stripeCustomerId,
        newReferralCode,
        referredById,
        affiliateId,
        utmParams?.utm_source || null,
        utmParams?.utm_medium || null,
        utmParams?.utm_campaign || null,
        utmParams?.utm_content || null,
        utmParams?.utm_term || null,
        utmParams?.landing_page || null,
        true, // Google has already verified the email
      ]
    );

    const newUser = result.rows[0];

    // Track demo conversion if user came from demo page
    if (ref && ref.startsWith('demo_')) {
      const demoToken = ref.replace('demo_', '');
      try {
        await dbQuery(
          'UPDATE demo_generations SET converted_at = NOW() WHERE demo_token = $1 AND converted_at IS NULL',
          [demoToken]
        );
        console.log(`ðŸŽ¯ Demo conversion tracked (Google OAuth): ${demoToken} -> user ${email}`);
      } catch (demoErr) {
        console.error('Failed to track demo conversion:', demoErr.message);
      }
    }

    // Generate JWT token
    const token = jwt.sign({ id: newUser.id, email: newUser.email }, process.env.JWT_SECRET, {
      expiresIn: '7d',
    });

    res.status(201).json({
      token,
      user: {
        id: newUser.id,
        email: newUser.email,
        businessName: newUser.business_name,
        plan: 'free',
        responsesUsed: 0,
        responsesLimit: 20,
        onboardingCompleted: false,
        profilePicture: picture,
        referralCode: newReferralCode,
        emailVerified: true, // Google OAuth users are always verified
      },
    });
  } catch (error) {
    console.error('Google auth error:', error);
    res.status(500).json({ error: 'Google sign-in failed. Please try again.' });
  }
});

// Password Reset - Request
app.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;

    if (!email || !validator.isEmail(email)) {
      return res.status(400).json({ error: 'Valid email is required' });
    }

    // Case-insensitive email lookup
    const user = await dbGet('SELECT id, email FROM users WHERE LOWER(email) = LOWER($1)', [email]);

    // Always return success to prevent email enumeration
    if (!user) {
      return res.json({
        success: true,
        message: 'If an account exists, a reset link will be sent.',
      });
    }

    // Delete any existing tokens for this user
    await dbQuery('DELETE FROM password_reset_tokens WHERE user_id = $1', [user.id]);

    // Generate secure token
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    await dbQuery(
      'INSERT INTO password_reset_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)',
      [user.id, token, expiresAt]
    );

    // Build reset URL
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    const resetUrl = `${frontendUrl}/reset-password?token=${token}`;

    // Send email if email provider is configured
    if ((resend || brevoApi) && process.env.NODE_ENV === 'production') {
      try {
        await sendEmail({
          to: user.email,
          subject: 'Reset Your Password - ReviewResponder',
          type: 'transactional',
          html: `
            <h2>Reset Your Password</h2>
            <p>Hi there,</p>
            <p>You requested a password reset for your ReviewResponder account. Click the link below to set a new password:</p>
            <p><a href="${resetUrl}" style="background: #4f46e5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">Reset Password</a></p>
            <p>Or copy this link: ${resetUrl}</p>
            <p>This link will expire in 1 hour. If you didn't request this, you can safely ignore this email.</p>
            <p>Best regards,<br>ReviewResponder Team</p>
          `,
        });
        console.log(`[Email] Password reset email sent to ${email}`);
      } catch (emailError) {
        console.error('Email send error:', emailError);
        // Continue anyway - don't reveal email sending failed
      }
    } else {
      // Development mode or email not configured
      console.log(`[Email] Password reset requested for ${email}`);
      console.log(`[Email] Reset URL: ${resetUrl}`);
      if (!resend && !brevoApi) {
        console.log('[Email] No email provider configured');
      }
    }

    res.json({ success: true, message: 'If an account exists, a reset link will be sent.' });
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({ error: 'Failed to process request' });
  }
});

// Password Reset - Reset with Token
app.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { token, password } = req.body;

    if (!token || !password) {
      return res.status(400).json({ error: 'Token and password are required' });
    }

    if (password.length < 8) {
      return res.status(400).json({ error: 'Password must be at least 8 characters' });
    }

    // Find valid token
    const resetToken = await dbGet(
      `SELECT * FROM password_reset_tokens
       WHERE token = $1 AND used = FALSE AND expires_at > NOW()`,
      [token]
    );

    if (!resetToken) {
      return res
        .status(400)
        .json({ error: 'Invalid or expired reset link. Please request a new one.' });
    }

    // Hash new password and update user
    const hashedPassword = await bcrypt.hash(password, 12);
    await dbQuery('UPDATE users SET password = $1 WHERE id = $2', [
      hashedPassword,
      resetToken.user_id,
    ]);

    // Mark token as used
    await dbQuery('UPDATE password_reset_tokens SET used = TRUE WHERE id = $1', [resetToken.id]);

    console.log(`âœ… Password reset successful for user ID ${resetToken.user_id}`);

    res.json({
      success: true,
      message: 'Password has been reset successfully. You can now log in.',
    });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({ error: 'Failed to reset password' });
  }
});

// ============ USER-GENERATED REVIEW CACHE (Crowdsourcing) ============
// Every Chrome Extension user contributes reviews to our cache
// This creates a network effect: more users = more cached reviews = less API costs

app.post('/api/reviews/contribute', async (req, res) => {
  try {
    const { reviews, businessName, placeId, city, platform } = req.body;

    if (!reviews || !Array.isArray(reviews) || reviews.length === 0) {
      return res.status(400).json({ error: 'No reviews provided' });
    }

    if (!placeId && !businessName) {
      return res.status(400).json({ error: 'placeId or businessName required' });
    }

    // Normalize reviews to our format
    const normalizedReviews = reviews.slice(0, 20).map((r) => ({
      text: r.text || r.reviewText || '',
      rating: parseInt(r.rating || r.reviewRating) || 0,
      author: r.author || r.reviewerName || 'Anonymous',
      date: r.date || new Date().toISOString(),
      source: platform || 'user_contributed',
      review_link: r.link || null,
      review_id: r.id || null,
    }));

    // Try to get or create place_id
    let googlePlaceId = placeId;
    if (!googlePlaceId && businessName && city) {
      try {
        const placeInfo = await lookupPlaceId(businessName, city);
        googlePlaceId = placeInfo.placeId;
      } catch (e) {
        // Can't find place, use business name hash as fallback
        googlePlaceId = `user_${Buffer.from(businessName).toString('base64').slice(0, 20)}`;
      }
    }

    // Check if we already have recent reviews for this place
    const existing = await dbQuery(
      `SELECT id, scraped_reviews FROM demo_generations
       WHERE google_place_id = $1
       AND created_at > NOW() - INTERVAL '90 days'
       ORDER BY created_at DESC LIMIT 1`,
      [googlePlaceId]
    );

    if (existing.rows.length > 0) {
      // Merge with existing reviews (add new ones, avoid duplicates)
      const existingReviews = JSON.parse(existing.rows[0].scraped_reviews || '[]');
      const existingTexts = new Set(existingReviews.map((r) => r.text?.slice(0, 50)));

      const newReviews = normalizedReviews.filter(
        (r) => !existingTexts.has(r.text?.slice(0, 50))
      );

      if (newReviews.length > 0) {
        const mergedReviews = [...existingReviews, ...newReviews].slice(0, 30);
        await dbQuery(
          `UPDATE demo_generations SET scraped_reviews = $1 WHERE id = $2`,
          [JSON.stringify(mergedReviews), existing.rows[0].id]
        );
        console.log(`[USER-CACHE] Added ${newReviews.length} new reviews for ${businessName}`);
      }

      return res.json({
        success: true,
        message: `Added ${newReviews.length} new reviews to cache`,
        cached: true,
      });
    }

    // Create new cache entry
    await dbQuery(
      `INSERT INTO demo_generations
       (business_name, google_place_id, city, scraped_reviews, demo_token, generated_responses)
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [
        businessName || 'Unknown Business',
        googlePlaceId,
        city || 'Unknown',
        JSON.stringify(normalizedReviews),
        `user_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        JSON.stringify([]),
      ]
    );

    console.log(`[USER-CACHE] Created new cache with ${normalizedReviews.length} reviews for ${businessName}`);

    res.json({
      success: true,
      message: `Cached ${normalizedReviews.length} reviews`,
      cached: true,
      bonus: 'Thanks for contributing! This helps everyone get faster demos.',
    });
  } catch (error) {
    console.error('[USER-CACHE] Error:', error);
    res.status(500).json({ error: 'Failed to cache reviews' });
  }
});

// ============ RESPONSE GENERATION ============

// Alias for Chrome extension (shorter path)
app.post('/api/generate', authenticateToken, (req, res) => generateResponseHandler(req, res));

// Main response generation endpoint
app.post('/api/responses/generate', authenticateToken, (req, res) =>
  generateResponseHandler(req, res)
);

// ========== RESPONSE QUALITY SCORING ==========
function evaluateResponseQuality(response, reviewText, tone, reviewRating) {
  let score = 70; // Base score
  const feedback = [];
  const suggestions = [];

  // 1. Length Check (ideal: 100-400 chars)
  const len = response.length;
  if (len >= 100 && len <= 400) {
    score += 10;
    feedback.push('Good length');
  } else if (len < 80) {
    score -= 10;
    suggestions.push('Response is quite short');
  } else if (len > 500) {
    score -= 5;
    suggestions.push('Consider shortening for better engagement');
  }

  // 2. Personalization (references review content)
  const reviewWords = reviewText
    .toLowerCase()
    .split(/\s+/)
    .filter(w => w.length > 4);
  const responseWords = response.toLowerCase();
  const matchedWords = reviewWords.filter(
    w =>
      responseWords.includes(w) &&
      !['their', 'about', 'would', 'could', 'should', 'which', 'there'].includes(w)
  );
  if (matchedWords.length >= 2) {
    score += 10;
    feedback.push('Personalized response');
  } else if (matchedWords.length === 0) {
    suggestions.push('Add specific details from the review');
  }

  // 3. Avoid generic openings
  const genericStarts = [
    'dear customer',
    'dear valued',
    'thank you for your feedback',
    'we appreciate your',
  ];
  const lowerResponse = response.toLowerCase();
  const hasGenericStart = genericStarts.some(g => lowerResponse.startsWith(g));
  if (!hasGenericStart) {
    score += 5;
  } else {
    suggestions.push('Avoid generic openings');
  }

  // 4. Call to action / invitation
  const ctaPhrases = [
    'visit',
    'return',
    'come back',
    'see you',
    'welcome back',
    'next time',
    'look forward',
    'contact',
    'reach out',
    'call us',
    'email',
  ];
  const hasCTA = ctaPhrases.some(p => lowerResponse.includes(p));
  if (hasCTA) {
    score += 5;
    feedback.push('Includes call to action');
  }

  // 5. Appropriate for rating (negative reviews need more empathy)
  if (reviewRating && reviewRating <= 2) {
    const empathyWords = [
      'sorry',
      'apologize',
      'understand',
      'concerned',
      'disappointing',
      'frustrating',
    ];
    const hasEmpathy = empathyWords.some(w => lowerResponse.includes(w));
    if (hasEmpathy) {
      score += 5;
      feedback.push('Shows empathy for negative experience');
    } else if (tone === 'apologetic') {
      suggestions.push('Add more empathetic language');
    }
  }

  // 6. No defensive language
  const defensiveWords = [
    'but actually',
    'however you',
    "that's not true",
    'you must have',
    'impossible',
  ];
  const hasDefensive = defensiveWords.some(w => lowerResponse.includes(w));
  if (hasDefensive) {
    score -= 15;
    suggestions.push('Avoid defensive language');
  }

  // Determine level
  let level = 'good';
  if (score >= 85) level = 'excellent';
  else if (score < 70) level = 'needs_work';

  // Cap score between 0 and 100
  score = Math.max(0, Math.min(100, score));

  return {
    score,
    level,
    feedback: feedback.length > 0 ? feedback.join(', ') : 'Solid response',
    suggestions,
  };
}

async function generateResponseHandler(req, res) {
  try {
    const {
      reviewText,
      reviewRating,
      platform,
      tone,
      outputLanguage,
      businessName,
      customInstructions,
      responseLength,
      includeEmojis,
      aiModel = 'auto',
      templateContent,
    } = req.body;

    if (!reviewText || reviewText.trim().length === 0) {
      return res.status(400).json({ error: 'Review text is required' });
    }

    // Check usage limits (with team support)
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Check if user is a team member
    const teamMembership = await dbGet(
      `SELECT tm.*, u.id as owner_id, u.subscription_plan as owner_plan, u.smart_responses_used as owner_smart_used, u.standard_responses_used as owner_standard_used, u.business_name as owner_business, u.business_type as owner_business_type, u.business_context as owner_context, u.response_style as owner_style
       FROM team_members tm
       JOIN users u ON tm.team_owner_id = u.id
       WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
      [req.user.id]
    );

    let usageOwner = user; // Who's usage we check/update
    let isTeamMember = false;
    let effectivePlan = user.subscription_plan || 'free';

    if (teamMembership) {
      isTeamMember = true;
      effectivePlan = teamMembership.owner_plan || 'free';
      // All team members can generate responses (simplified role system)
      // Use team owner's usage limits
      usageOwner = {
        id: teamMembership.owner_id,
        subscription_plan: teamMembership.owner_plan,
        smart_responses_used: teamMembership.owner_smart_used || 0,
        standard_responses_used: teamMembership.owner_standard_used || 0,
        business_name: teamMembership.owner_business,
        business_type: teamMembership.owner_business_type,
        business_context: teamMembership.owner_context,
        response_style: teamMembership.owner_style,
      };
    }

    // Get plan limits
    const planLimits = PLAN_LIMITS[effectivePlan] || PLAN_LIMITS.free;
    const smartUsed = usageOwner.smart_responses_used || 0;
    const standardUsed = usageOwner.standard_responses_used || 0;
    const smartRemaining = planLimits.smartResponses - smartUsed;
    const standardRemaining = planLimits.standardResponses - standardUsed;
    const bonusRemaining = usageOwner.bonus_responses || 0; // Micro-pricing: $5 for 10 responses

    // Determine which AI model to use
    let useModel = 'standard'; // Default: GPT-4o-mini
    let useBonusResponse = false; // Track if we're using a bonus response

    if (aiModel === 'smart') {
      // User explicitly wants Smart AI (Claude)
      if (smartRemaining <= 0) {
        return res.status(403).json({
          error: 'No Smart AI responses remaining',
          smartRemaining: 0,
          standardRemaining,
          bonusRemaining,
          suggestion:
            standardRemaining > 0
              ? 'Switch to Standard AI'
              : bonusRemaining > 0
                ? 'Use bonus responses'
                : 'Upgrade your plan',
        });
      }
      useModel = 'smart';
    } else if (aiModel === 'auto') {
      // Auto: Smart if available, otherwise Standard
      useModel = smartRemaining > 0 ? 'smart' : 'standard';

      if (useModel === 'standard' && standardRemaining <= 0) {
        // Check if user has bonus responses from micro-pricing
        if (bonusRemaining > 0) {
          useBonusResponse = true;
          // Still use standard model but deduct from bonus pool
        } else {
          return res.status(403).json({
            error: 'No responses remaining',
            smartRemaining: 0,
            standardRemaining: 0,
            bonusRemaining: 0,
            upgrade: !isTeamMember,
            showUpgradeModal: true, // Frontend should show the upgrade modal
            message: isTeamMember
              ? 'Your team has reached the monthly response limit. Contact your team owner.'
              : 'You have reached your monthly response limit. Please upgrade your plan to continue.',
          });
        }
      }
    } else {
      // Standard explicitly chosen
      if (standardRemaining <= 0) {
        // Check bonus responses as fallback
        if (bonusRemaining > 0) {
          useBonusResponse = true;
        } else {
          return res.status(403).json({
            error: 'No Standard responses remaining',
            smartRemaining,
            standardRemaining: 0,
            bonusRemaining: 0,
            suggestion: smartRemaining > 0 ? 'Switch to Smart AI' : 'Upgrade your plan',
          });
        }
      }
    }

    // ========== OPTIMIZED PROMPT SYSTEM ==========

    // Rating-specific strategies for better responses
    const ratingStrategies = {
      5: {
        goal: 'Reinforce positive feelings, encourage return visit',
        approach:
          'Express genuine gratitude, mention something specific from their review, invite them back',
        length: '2-3 sentences',
        avoid: 'Being too generic or effusive',
      },
      4: {
        goal: 'Thank them while subtly showing you care about perfection',
        approach:
          'Appreciate their feedback, acknowledge room for improvement without being defensive',
        length: '2-3 sentences',
        avoid: 'Ignoring their slight criticism',
      },
      3: {
        goal: 'Show you take feedback seriously',
        approach:
          'Acknowledge their mixed experience, express desire to do better, invite them to give you another chance',
        length: '3-4 sentences',
        avoid: 'Being dismissive or overly apologetic',
      },
      2: {
        goal: 'Recover the relationship',
        approach:
          'Sincerely acknowledge disappointment, take responsibility, offer concrete resolution',
        length: '3-4 sentences',
        avoid: 'Making excuses or being defensive',
      },
      1: {
        goal: 'Damage control, show professionalism to future readers',
        approach:
          'Acknowledge frustration, take ownership, apologize specifically, offer direct contact to resolve',
        length: '4-5 sentences',
        avoid: 'Arguing, making excuses, passive-aggressive tone',
      },
    };

    // Enhanced tone definitions with examples
    const toneDefinitions = {
      professional: {
        description: 'Professional and courteous - polished but warm',
        goodExample: 'We really appreciate you sharing this. Our team takes great pride in...',
        avoidExample: 'Thank you for your feedback. We value your input.',
      },
      friendly: {
        description: 'Warm and personable - like a friend who runs a great business',
        goodExample: 'You just made our day! We loved having you...',
        avoidExample: 'Dear valued customer, we appreciate your kind words.',
      },
      formal: {
        description: 'Formal and business-appropriate - for upscale brands',
        goodExample: 'We are honored by your gracious review. Our commitment to excellence...',
        avoidExample: 'Hey thanks for the review!',
      },
      apologetic: {
        description: 'Empathetic and solution-focused - takes ownership',
        goodExample: 'We completely understand your frustration, and we take this seriously...',
        avoidExample: 'We apologize for any inconvenience this may have caused.',
      },
    };

    // ========== PERFECTED PROMPT - CLAUDE STYLE ==========

    // Response length mapping
    const lengthInstructions = {
      short: '1-2 sentences. Be concise.',
      medium: '2-3 sentences. Balanced length.',
      detailed: '4-5 sentences. More thorough.',
    };
    const lengthInstruction = lengthInstructions[responseLength] || lengthInstructions.medium;

    // Emoji instruction
    const emojiInstruction = includeEmojis
      ? 'You MAY include 1-2 relevant emojis if appropriate.'
      : 'Do NOT use any emojis.';

    // ========== ANTHROPIC BEST PRACTICES 2025: Full XML Structure ==========
    // @see https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/claude-4-best-practices
    // @see https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/use-xml-tags

    // Build AI-Slop avoidance section with explicit examples
    const avoidPatternsSection = `
<avoid_patterns>
CRITICAL: Your response will be rejected if it sounds AI-generated.

<forbidden_phrases>
${AI_SLOP_PHRASES.slice(0, 8)
  .map(p => `- "${p}"`)
  .join('\n')}
</forbidden_phrases>

<forbidden_words>
${AI_SLOP_WORDS.join(', ')}
</forbidden_words>

<replacements>
- Instead of "Thank you for your feedback" â†’ "Glad you enjoyed [specific thing]"
- Instead of "We appreciate you taking the time" â†’ "Nice to hear about [detail]"
- Instead of "Sorry for any inconvenience" â†’ "That's on us, we'll fix it"
- Instead of "We value your input" â†’ Just address the specific issue
</replacements>

<forbidden_starts>
Never start your response with: "Here's", "Let me", "I want to", "First", "Thank you for"
</forbidden_starts>
</avoid_patterns>`;

    const writingStyleInstructions = `
<voice>
You are the business owner speaking directly to a customer.
Write like you'd text a regular who just left a review.
Warm but not gushing. Confident but not arrogant. Human, not corporate.
</voice>

<style_rules>
- Length: ${lengthInstruction}
- Maximum one exclamation mark (zero is fine)
- Always use contractions (we're, you'll, that's, don't)
- Reference something specific from their review
- ${emojiInstruction}
</style_rules>

<good_response_patterns>
These sound human:
- "Glad the [specific thing] worked for you."
- "Nice to hear about [detail]. We [relevant fact]."
- "That's on us. Email me directly and we'll fix it."
- "[Name] will love hearing this."
</good_response_patterns>

${avoidPatternsSection}

<output_format>
Write the response directly.
No quotes around the response.
No "Response:" prefix.
No explanations.
Just the text you would post as the review response.
</output_format>`;

    // Get rating strategy
    const getRatingStrategy = rating => {
      if (!rating) return null;
      return ratingStrategies[rating] || ratingStrategies[3];
    };

    // Build the optimized prompt
    const ratingStrategy = getRatingStrategy(reviewRating);
    const toneConfig = toneDefinitions[tone] || toneDefinitions.professional;
    const isNegative = reviewRating && reviewRating <= 2;

    // Language mapping for output language selection
    const languageNames = {
      en: 'English',
      de: 'German',
      es: 'Spanish',
      fr: 'French',
      it: 'Italian',
      pt: 'Portuguese',
      nl: 'Dutch',
      pl: 'Polish',
      ru: 'Russian',
      zh: 'Chinese',
      ja: 'Japanese',
      ko: 'Korean',
      ar: 'Arabic',
      tr: 'Turkish',
      sv: 'Swedish',
      da: 'Danish',
      no: 'Norwegian',
      fi: 'Finnish',
    };

    // Build language instruction
    const languageInstruction =
      !outputLanguage || outputLanguage === 'auto'
        ? 'You MUST respond in the EXACT SAME language as the review. If the review is in English, respond in English. If German, respond in German. Match the review language exactly.'
        : `You MUST write the response in ${languageNames[outputLanguage] || 'English'}.`;

    // Build business context section (use team owner's context if team member)
    const contextUser = isTeamMember ? usageOwner : user;

    // Industry-specific examples - matches business type for better relevance
    // Now using XML format per Anthropic Best Practices
    const fewShotExamplesXMLContent = getFewShotExamplesXML(contextUser?.business_type);

    // ========== ANTHROPIC BEST PRACTICES: Full XML System Message ==========
    // Claude 4 follows instructions literally - be explicit about everything

    const effectiveBusinessName = businessName || contextUser.business_name || 'a business';
    const effectiveBusinessType = contextUser.business_type || 'local business';

    const systemMessage = `<role>
You are the owner of ${effectiveBusinessName}, a ${effectiveBusinessType}.
You are personally responding to a customer review on ${platform || 'Google'}.
</role>

<context>
Platform: ${platform || 'Google'}
Review Rating: ${reviewRating ? `${reviewRating} stars` : 'Not specified'}
${contextUser.business_context ? `\n<business_details>\n${contextUser.business_context}\n</business_details>` : ''}
${contextUser.response_style ? `\n<custom_style>\n${contextUser.response_style}\n</custom_style>` : ''}
</context>

${
  templateContent
    ? `<template_reference>
Use this as a style guide. Match its tone and structure:
"${templateContent}"
</template_reference>
`
    : ''
}
${writingStyleInstructions}

${fewShotExamplesXMLContent}

<language_instruction>
${languageInstruction}
</language_instruction>`;

    const userMessage = `${reviewRating ? `[${reviewRating} stars] ` : ''}${reviewText}${ratingStrategy ? `\n\n(${ratingStrategy.length})` : ''}${customInstructions ? `\n\nIMPORTANT - Follow these instructions: ${customInstructions}` : ''}`;

    // Generate response using selected AI model
    let generatedResponse;

    if (useModel === 'smart' && anthropic) {
      // Use Claude for Smart AI - with auto-fallback to GPT-4o-mini on error
      try {
        const response = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 350,
          system: systemMessage,
          messages: [{ role: 'user', content: userMessage }],
        });
        generatedResponse = response.content[0].text.trim();

        // Log API call for cost tracking
        logApiCall({
          provider: 'anthropic',
          model: 'claude-sonnet-4-20250514',
          endpoint: '/api/generate',
          userId: req.user?.id,
          inputTokens: response.usage?.input_tokens || 0,
          outputTokens: response.usage?.output_tokens || 0,
        });
      } catch (claudeError) {
        // Auto-fallback to GPT-4o-mini if Claude fails (out of credits, rate limit, etc.)
        console.warn(`[Claude Fallback] ${claudeError.message} - using GPT-4o-mini`);
        useModel = 'standard';
        const completion = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemMessage },
            { role: 'user', content: userMessage },
          ],
          max_tokens: 350,
          temperature: 0.6,
        });
        generatedResponse = completion.choices[0].message.content.trim();
        logApiCall({
          provider: 'openai',
          model: 'gpt-4o-mini',
          endpoint: '/api/generate (claude-fallback)',
          userId: req.user?.id,
          inputTokens: completion.usage?.prompt_tokens || 0,
          outputTokens: completion.usage?.completion_tokens || 0,
        });
      }
    } else {
      // Use Claude Haiku for Standard AI (better quality than GPT-4o-mini)
      if (anthropic) {
        try {
          const response = await anthropic.messages.create({
            model: 'claude-3-5-haiku-20241022',
            max_tokens: 350,
            system: systemMessage,
            messages: [{ role: 'user', content: userMessage }],
          });
          generatedResponse = response.content[0].text.trim();

          logApiCall({
            provider: 'anthropic',
            model: 'claude-3-5-haiku-20241022',
            endpoint: '/api/generate (standard)',
            userId: req.user?.id,
            inputTokens: response.usage?.input_tokens || 0,
            outputTokens: response.usage?.output_tokens || 0,
          });
        } catch (haikuError) {
          // Fallback to GPT-4o-mini if Haiku fails
          console.warn(`[Haiku Fallback] ${haikuError.message} - using GPT-4o-mini`);
          const completion = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: systemMessage },
              { role: 'user', content: userMessage },
            ],
            max_tokens: 350,
            temperature: 0.6,
          });
          generatedResponse = completion.choices[0].message.content.trim();

          logApiCall({
            provider: 'openai',
            model: 'gpt-4o-mini',
            endpoint: '/api/generate (haiku-fallback)',
            userId: req.user?.id,
            inputTokens: completion.usage?.prompt_tokens || 0,
            outputTokens: completion.usage?.completion_tokens || 0,
          });
        }
      } else {
        // Fallback to GPT-4o-mini if no Anthropic key
        const completion = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemMessage },
            { role: 'user', content: userMessage },
          ],
          max_tokens: 350,
          temperature: 0.6,
        });
        generatedResponse = completion.choices[0].message.content.trim();

        logApiCall({
          provider: 'openai',
          model: 'gpt-4o-mini',
          endpoint: '/api/generate (no-anthropic)',
          userId: req.user?.id,
          inputTokens: completion.usage?.prompt_tokens || 0,
          outputTokens: completion.usage?.completion_tokens || 0,
        });
      }

      // Mark as standard
      useModel = 'standard';
    }

    // Apply AI slop filter to clean up typical AI phrases
    generatedResponse = cleanAISlop(generatedResponse);

    // Check if this is an onboarding demo request (don't count usage or save to history)
    const isOnboardingDemo = req.body.isOnboarding === true && user.onboarding_completed === false;

    // Usage owner for tracking
    const usageOwnerId = isTeamMember ? usageOwner.id : req.user.id;

    let updatedOwner;
    let updatedPlanLimits;
    let totalUsed;
    let totalLimit;

    if (!isOnboardingDemo) {
      // Save response with AI model info
      await dbQuery(
        `INSERT INTO responses (user_id, review_text, review_rating, review_platform, generated_response, tone, ai_model)
         VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [
          req.user.id,
          reviewText,
          reviewRating || null,
          platform || 'google',
          generatedResponse,
          tone || 'professional',
          useModel,
        ]
      );

      // Update the correct usage counter
      if (useBonusResponse) {
        // Deduct from bonus responses (micro-pricing)
        await dbQuery(
          'UPDATE users SET bonus_responses = GREATEST(0, bonus_responses - 1), responses_used = responses_used + 1 WHERE id = $1',
          [usageOwnerId]
        );
      } else if (useModel === 'smart') {
        await dbQuery(
          'UPDATE users SET smart_responses_used = smart_responses_used + 1, responses_used = responses_used + 1 WHERE id = $1',
          [usageOwnerId]
        );
      } else {
        await dbQuery(
          'UPDATE users SET standard_responses_used = standard_responses_used + 1, responses_used = responses_used + 1 WHERE id = $1',
          [usageOwnerId]
        );
      }

      updatedOwner = await dbGet('SELECT * FROM users WHERE id = $1', [usageOwnerId]);
      updatedPlanLimits = PLAN_LIMITS[updatedOwner.subscription_plan || 'free'] || PLAN_LIMITS.free;
      totalUsed =
        (updatedOwner.smart_responses_used || 0) + (updatedOwner.standard_responses_used || 0);
      totalLimit = updatedPlanLimits.responses;

      const usagePercent = Math.round((totalUsed / totalLimit) * 100);
      const previousTotal = totalUsed - 1;
      const previousPercent = Math.round((previousTotal / totalLimit) * 100);

      // Send alert if just crossed 80% threshold (send to owner)
      if (
        usagePercent >= 80 &&
        previousPercent < 80 &&
        updatedOwner.subscription_plan !== 'unlimited'
      ) {
        const canSendAlert =
          !updatedOwner.last_usage_alert_sent ||
          new Date(updatedOwner.last_usage_alert_sent) < new Date(Date.now() - 24 * 60 * 60 * 1000);

        if (canSendAlert && process.env.NODE_ENV === 'production') {
          sendUsageAlertEmail(updatedOwner).then(sent => {
            if (sent) {
              dbQuery('UPDATE users SET last_usage_alert_sent = NOW() WHERE id = $1', [
                usageOwnerId,
              ]);
            }
          });
        }
      }

      // Send Flash Offer if FREE user just hit 100% (20/20)
      // SAFEGUARDS: Only once per user ever, only for free plan
      if (
        updatedOwner.subscription_plan === 'free' &&
        totalUsed >= totalLimit &&
        previousTotal < totalLimit &&
        !updatedOwner.flash_offer_sent_at &&
        process.env.NODE_ENV === 'production'
      ) {
        sendFlashOfferEmail(updatedOwner).then(sent => {
          if (sent) {
            dbQuery('UPDATE users SET flash_offer_sent_at = NOW() WHERE id = $1', [usageOwnerId]);
            console.log(`[Flash Offer] Triggered for user ${updatedOwner.email} (hit ${totalUsed}/${totalLimit})`);
          }
        });
      }
    } else {
      // Onboarding demo: return current usage without incrementing
      updatedOwner = usageOwner;
      updatedPlanLimits = planLimits;
      totalUsed =
        (usageOwner.smart_responses_used || 0) + (usageOwner.standard_responses_used || 0);
      totalLimit = planLimits.responses;
    }

    // Evaluate response quality
    const quality = evaluateResponseQuality(generatedResponse, reviewText, tone, reviewRating);

    res.json({
      response: generatedResponse,
      aiModel: useModel,
      quality, // NEW: Quality score object
      usedBonusResponse: useBonusResponse, // Track if bonus response was used
      usage: {
        smart: {
          used: updatedOwner.smart_responses_used || 0,
          limit: updatedPlanLimits.smartResponses,
        },
        standard: {
          used: updatedOwner.standard_responses_used || 0,
          limit: updatedPlanLimits.standardResponses,
        },
        bonus: {
          remaining: updatedOwner.bonus_responses || 0, // Micro-pricing bonus
        },
        total: {
          used: totalUsed,
          limit: totalLimit,
        },
      },
      // Backward compatibility
      responsesUsed: totalUsed,
      responsesLimit: totalLimit,
      isTeamUsage: isTeamMember,
    });
  } catch (error) {
    console.error('Generation error:', error);
    res.status(500).json({ error: 'Failed to generate response' });
  }
}

// ========== RESPONSE VARIATIONS (3 Options) ==========
app.post('/api/generate-variations', authenticateToken, async (req, res) => {
  try {
    const {
      reviewText,
      reviewRating,
      platform,
      tone,
      outputLanguage,
      businessName,
      responseLength,
      includeEmojis,
      templateContent,
    } = req.body;

    if (!reviewText || reviewText.trim().length === 0) {
      return res.status(400).json({ error: 'Review text is required' });
    }

    // Check usage limits (requires 3 responses)
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    const planLimits = PLAN_LIMITS[user.subscription_plan || 'free'] || PLAN_LIMITS.free;
    const totalUsed = (user.smart_responses_used || 0) + (user.standard_responses_used || 0);
    const remaining = planLimits.responses - totalUsed;

    // Need at least 3 credits for variations
    if (remaining < 3) {
      return res.status(403).json({
        error: 'Not enough responses remaining',
        message: `Variations requires 3 response credits. You have ${remaining} remaining.`,
        upgrade: true,
      });
    }

    // Variation styles - each creates a slightly different response
    const variationStyles = [
      {
        name: 'concise',
        instruction: 'Keep the response brief and to the point (2-3 sentences max).',
        temp: 0.5,
      },
      {
        name: 'detailed',
        instruction: 'Include specific details and a personal touch. Be warm and conversational.',
        temp: 0.7,
      },
      {
        name: 'actionable',
        instruction: 'Focus on solutions and next steps. Include a clear call to action.',
        temp: 0.6,
      },
    ];

    // Language map
    const languageNames = {
      en: 'English',
      de: 'German',
      es: 'Spanish',
      fr: 'French',
      it: 'Italian',
      pt: 'Portuguese',
      nl: 'Dutch',
      pl: 'Polish',
      ru: 'Russian',
      zh: 'Chinese',
      ja: 'Japanese',
      ko: 'Korean',
    };

    const languageInstruction =
      !outputLanguage || outputLanguage === 'auto'
        ? 'Respond in the EXACT SAME language as the review.'
        : `Respond in ${languageNames[outputLanguage] || 'English'}.`;

    // Tone map
    const toneStyles = {
      professional: 'Professional and courteous',
      friendly: 'Warm and friendly',
      formal: 'Formal and polished',
      apologetic: 'Empathetic and apologetic',
    };
    const toneStyle = toneStyles[tone] || toneStyles.professional;

    // Template style guide if provided
    const templateGuide = templateContent
      ? `\nTEMPLATE STYLE GUIDE: Use this template as a style reference. Match its tone, structure, and approach, but adapt the content to the specific review:\n"${templateContent}"`
      : '';

    // Generate all 3 variations in parallel using Claude Haiku
    const variationPromises = variationStyles.map(async (style, index) => {
      const systemMessage = `You are responding to a customer review for ${businessName || 'our business'}. Tone: ${toneStyle}. ${style.instruction} ${languageInstruction}${templateGuide}`;

      const userMessage = `${reviewRating ? `[${reviewRating} star review] ` : ''}${reviewText}`;

      let rawResponse;
      if (anthropic) {
        try {
          const response = await anthropic.messages.create({
            model: 'claude-3-5-haiku-20241022',
            max_tokens: 350,
            system: systemMessage,
            messages: [{ role: 'user', content: userMessage }],
          });
          rawResponse = response.content[0].text.trim();
        } catch {
          // Fallback to GPT-4o-mini
          const completion = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: systemMessage },
              { role: 'user', content: userMessage },
            ],
            max_tokens: 350,
            temperature: style.temp,
          });
          rawResponse = completion.choices[0].message.content.trim();
        }
      } else {
        const completion = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemMessage },
            { role: 'user', content: userMessage },
          ],
          max_tokens: 350,
          temperature: style.temp,
        });
        rawResponse = completion.choices[0].message.content.trim();
      }

      const generatedResponse = cleanAISlop(rawResponse);
      const quality = evaluateResponseQuality(generatedResponse, reviewText, tone, reviewRating);

      return {
        id: index + 1,
        style: style.name,
        response: generatedResponse,
        quality,
      };
    });

    const variations = await Promise.all(variationPromises);

    // Save only the first variation to history (user can save others manually)
    await dbQuery(
      `INSERT INTO responses (user_id, review_text, review_rating, review_platform, generated_response, tone, ai_model)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        req.user.id,
        reviewText,
        reviewRating || null,
        platform || 'google',
        variations[0].response,
        tone || 'professional',
        'standard',
      ]
    );

    // Update usage (count as 3 responses)
    await dbQuery(
      'UPDATE users SET standard_responses_used = standard_responses_used + 3, responses_used = responses_used + 3 WHERE id = $1',
      [req.user.id]
    );

    const updatedUser = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    const updatedTotalUsed =
      (updatedUser.smart_responses_used || 0) + (updatedUser.standard_responses_used || 0);

    res.json({
      variations,
      usage: {
        used: updatedTotalUsed,
        limit: planLimits.responses,
        creditsUsed: 3,
      },
    });
  } catch (error) {
    console.error('Variations generation error:', error);
    res.status(500).json({ error: 'Failed to generate variations' });
  }
});

// Bulk Response Generation (Paid plans only: Starter/Pro/Unlimited)
app.post('/api/generate-bulk', authenticateToken, async (req, res) => {
  try {
    const { reviews, tone, platform, outputLanguage, aiModel = 'auto' } = req.body;

    // Validate input
    if (!reviews || !Array.isArray(reviews) || reviews.length === 0) {
      return res.status(400).json({ error: 'Reviews array is required' });
    }

    if (reviews.length > 20) {
      return res.status(400).json({ error: 'Maximum 20 reviews per batch' });
    }

    // Check user plan (Paid plans only: Starter/Pro/Unlimited) with team support
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Check if user is a team member
    const teamMembership = await dbGet(
      `SELECT tm.*, u.id as owner_id, u.subscription_plan as owner_plan, u.smart_responses_used as owner_smart_used, u.standard_responses_used as owner_standard_used, u.business_name as owner_business, u.business_type as owner_business_type, u.business_context as owner_context
       FROM team_members tm
       JOIN users u ON tm.team_owner_id = u.id
       WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
      [req.user.id]
    );

    let usageOwner = user;
    let isTeamMember = false;
    let effectivePlan = user.subscription_plan;

    if (teamMembership) {
      isTeamMember = true;
      // All team members can generate (simplified role system)
      usageOwner = {
        id: teamMembership.owner_id,
        smart_responses_used: teamMembership.owner_smart_used || 0,
        standard_responses_used: teamMembership.owner_standard_used || 0,
        business_name: teamMembership.owner_business,
        business_type: teamMembership.owner_business_type,
        business_context: teamMembership.owner_context,
      };
      effectivePlan = teamMembership.owner_plan;
    }

    if (!['starter', 'professional', 'unlimited'].includes(effectivePlan)) {
      return res.status(403).json({
        error: 'Bulk generation is only available for paid plans (Starter, Pro, Unlimited)',
        upgrade: !isTeamMember,
        requiredPlan: 'starter',
      });
    }

    // Get plan limits and check usage
    const planLimits = PLAN_LIMITS[effectivePlan] || PLAN_LIMITS.free;
    const smartUsed = usageOwner.smart_responses_used || 0;
    const standardUsed = usageOwner.standard_responses_used || 0;
    const smartRemaining = planLimits.smartResponses - smartUsed;
    const standardRemaining = planLimits.standardResponses - standardUsed;
    const reviewCount = reviews.filter(r => r.trim()).length;

    // Determine which AI model to use for bulk
    let useModel = 'standard'; // Default for bulk: Standard (faster, cheaper)

    if (aiModel === 'smart') {
      if (smartRemaining < reviewCount) {
        return res.status(403).json({
          error: `Not enough Smart AI responses. You need ${reviewCount} but only have ${smartRemaining} left.`,
          suggestion:
            standardRemaining >= reviewCount ? 'Switch to Standard AI' : 'Upgrade your plan',
        });
      }
      useModel = 'smart';
    } else if (aiModel === 'auto') {
      // For bulk, prefer standard to save smart responses for single generations
      useModel =
        standardRemaining >= reviewCount
          ? 'standard'
          : smartRemaining >= reviewCount
            ? 'smart'
            : 'standard';

      if (standardRemaining < reviewCount && smartRemaining < reviewCount) {
        return res.status(403).json({
          error: `Not enough responses remaining. You need ${reviewCount} but only have ${Math.max(smartRemaining, standardRemaining)} left.`,
          upgrade: !isTeamMember,
        });
      }
    } else {
      if (standardRemaining < reviewCount) {
        return res.status(403).json({
          error: `Not enough Standard responses. You need ${reviewCount} but only have ${standardRemaining} left.`,
          suggestion: smartRemaining >= reviewCount ? 'Switch to Smart AI' : 'Upgrade your plan',
        });
      }
    }

    // ========== OPTIMIZED BULK PROMPT SYSTEM ==========

    // Reuse optimized prompt components
    const bulkRatingStrategies = {
      5: {
        goal: 'Reinforce positive feelings',
        approach: 'Express genuine gratitude, mention specifics',
        length: '2-3 sentences',
      },
      4: {
        goal: 'Thank while showing you care',
        approach: 'Appreciate feedback, acknowledge room for improvement',
        length: '2-3 sentences',
      },
      3: {
        goal: 'Show you take feedback seriously',
        approach: 'Acknowledge mixed experience, invite them back',
        length: '3-4 sentences',
      },
      2: {
        goal: 'Recover the relationship',
        approach: 'Take responsibility, offer resolution',
        length: '3-4 sentences',
      },
      1: {
        goal: 'Damage control',
        approach: 'Acknowledge frustration, offer direct contact',
        length: '4-5 sentences',
      },
    };

    const bulkToneDefinitions = {
      professional: {
        description: 'Professional and courteous - polished but warm',
        avoid: 'Thank you for your feedback',
      },
      friendly: {
        description: 'Warm and personable - like a friend',
        avoid: 'Dear valued customer',
      },
      formal: { description: 'Formal and business-appropriate', avoid: 'Hey thanks!' },
      apologetic: {
        description: 'Empathetic and solution-focused',
        avoid: 'We apologize for any inconvenience',
      },
    };

    // Claude-style instructions for bulk (XML tags + positive framing)
    const bulkWritingStyle = `<output_format>
Write response directly. No quotes. No "Response:" prefix.
</output_format>

<voice>
You're the business owner, not customer service. Write like you'd text a regular customer.
</voice>

<style_guide>
Write responses like:
- "Glad the [specific thing] worked."
- "Nice to hear about [detail]."
- "That's on us. We'll fix it."

Keep it: Short sentences. Contractions (we're, you'll). Max 1 exclamation mark. Reference their specific details.
</style_guide>

<avoid_ai_patterns>
No gushing (thrilled, delighted, amazing). No corporate speak (leverage, embark).
Instead of "Thank you for your feedback" â†’ "Glad you enjoyed [specific thing]"
</avoid_ai_patterns>`;

    const bulkLanguageNames = {
      en: 'English',
      de: 'German',
      es: 'Spanish',
      fr: 'French',
      it: 'Italian',
      pt: 'Portuguese',
      nl: 'Dutch',
      pl: 'Polish',
      ru: 'Russian',
      zh: 'Chinese',
      ja: 'Japanese',
      ko: 'Korean',
      ar: 'Arabic',
      tr: 'Turkish',
      sv: 'Swedish',
      da: 'Danish',
      no: 'Norwegian',
      fi: 'Finnish',
    };

    const bulkLanguageInstruction =
      !outputLanguage || outputLanguage === 'auto'
        ? 'Respond in the SAME language as the review.'
        : `Respond in ${bulkLanguageNames[outputLanguage] || 'English'}.`;

    const contextUser = isTeamMember ? usageOwner : user;

    // Process all reviews in parallel
    const generateSingleResponse = async (reviewText, index) => {
      if (!reviewText.trim()) {
        return { index, success: false, error: 'Empty review' };
      }

      try {
        const bulkSystemMessage = `You're a small business owner responding to reviews. Not a customer service rep - the owner.

BUSINESS: ${contextUser.business_name || 'Our business'}${contextUser.business_type ? ` (${contextUser.business_type})` : ''}
${contextUser.business_context ? `About: ${contextUser.business_context}` : ''}
${contextUser.response_style ? `IMPORTANT - Follow these custom instructions: ${contextUser.response_style}` : ''}

${bulkWritingStyle}

LANGUAGE: ${bulkLanguageInstruction}`;

        const bulkUserMessage = `[Review] ${reviewText}`;

        let generatedResponse;

        if (useModel === 'smart' && anthropic) {
          // Use Claude for Smart AI - with auto-fallback
          try {
            const response = await anthropic.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 350,
              system: bulkSystemMessage,
              messages: [{ role: 'user', content: bulkUserMessage }],
            });
            generatedResponse = response.content[0].text.trim();

            logApiCall({
              provider: 'anthropic',
              model: 'claude-sonnet-4-20250514',
              endpoint: '/api/generate-bulk',
              userId: req.user?.id,
              inputTokens: response.usage?.input_tokens || 0,
              outputTokens: response.usage?.output_tokens || 0,
            });
          } catch (claudeError) {
            console.warn(`[Claude Fallback] Bulk: ${claudeError.message} - using GPT-4o-mini`);
            useModel = 'standard';
            const completion = await openai.chat.completions.create({
              model: 'gpt-4o-mini',
              messages: [
                { role: 'system', content: bulkSystemMessage },
                { role: 'user', content: bulkUserMessage },
              ],
              max_tokens: 350,
              temperature: 0.6,
            });
            generatedResponse = completion.choices[0].message.content.trim();
            logApiCall({
              provider: 'openai',
              model: 'gpt-4o-mini',
              endpoint: '/api/generate-bulk (claude-fallback)',
              userId: req.user?.id,
              inputTokens: completion.usage?.prompt_tokens || 0,
              outputTokens: completion.usage?.completion_tokens || 0,
            });
          }
        } else {
          // Use GPT-4o-mini for Standard AI
          const completion = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: bulkSystemMessage },
              { role: 'user', content: bulkUserMessage },
            ],
            max_tokens: 350,
            temperature: 0.6,
            presence_penalty: 0.1,
            frequency_penalty: 0.1,
          });
          generatedResponse = completion.choices[0].message.content.trim();

          // Log API call for cost tracking
          logApiCall({
            provider: 'openai',
            model: 'gpt-4o-mini',
            endpoint: '/api/generate-bulk',
            userId: req.user?.id,
            inputTokens: completion.usage?.prompt_tokens || 0,
            outputTokens: completion.usage?.completion_tokens || 0,
          });
        }

        // Apply AI slop filter to clean up typical AI phrases
        generatedResponse = cleanAISlop(generatedResponse);

        // Save to database with AI model
        await dbQuery(
          `INSERT INTO responses (user_id, review_text, review_platform, generated_response, tone, ai_model)
           VALUES ($1, $2, $3, $4, $5, $6)`,
          [
            req.user.id,
            reviewText,
            platform || 'google',
            generatedResponse,
            tone || 'professional',
            useModel,
          ]
        );

        return {
          index,
          success: true,
          review: reviewText,
          response: generatedResponse,
          aiModel: useModel,
        };
      } catch (error) {
        console.error(`Error generating response for review ${index}:`, error);
        return {
          index,
          success: false,
          review: reviewText,
          error: 'Failed to generate response',
        };
      }
    };

    // Process all reviews in parallel
    const results = await Promise.all(
      reviews.map((review, index) => generateSingleResponse(review, index))
    );

    // Count successful generations
    const successCount = results.filter(r => r.success).length;

    // Update usage count for the account owner (team owner if team member)
    const usageOwnerId = isTeamMember ? usageOwner.id : req.user.id;

    // Update correct usage counter based on model used
    if (useModel === 'smart') {
      await dbQuery(
        'UPDATE users SET smart_responses_used = smart_responses_used + $1, responses_used = responses_used + $1 WHERE id = $2',
        [successCount, usageOwnerId]
      );
    } else {
      await dbQuery(
        'UPDATE users SET standard_responses_used = standard_responses_used + $1, responses_used = responses_used + $1 WHERE id = $2',
        [successCount, usageOwnerId]
      );
    }

    const updatedOwner = await dbGet('SELECT * FROM users WHERE id = $1', [usageOwnerId]);
    const updatedPlanLimits =
      PLAN_LIMITS[updatedOwner.subscription_plan || 'free'] || PLAN_LIMITS.free;

    res.json({
      isTeamUsage: isTeamMember,
      aiModel: useModel,
      results: results.sort((a, b) => a.index - b.index),
      summary: {
        total: reviews.length,
        successful: successCount,
        failed: reviews.length - successCount,
      },
      usage: {
        smart: {
          used: updatedOwner.smart_responses_used || 0,
          limit: updatedPlanLimits.smartResponses,
        },
        standard: {
          used: updatedOwner.standard_responses_used || 0,
          limit: updatedPlanLimits.standardResponses,
        },
      },
      responsesUsed:
        (updatedOwner.smart_responses_used || 0) + (updatedOwner.standard_responses_used || 0),
      responsesLimit: updatedPlanLimits.responses,
    });
  } catch (error) {
    console.error('Bulk generation error:', error);
    res.status(500).json({ error: 'Failed to generate bulk responses' });
  }
});

app.get('/api/responses/history', authenticateToken, async (req, res) => {
  try {
    // Plan-Check: Response History is Starter+ only
    const user = await dbGet('SELECT subscription_plan FROM users WHERE id = $1', [req.user.id]);
    if (user.subscription_plan === 'free') {
      return res.status(403).json({
        error: 'Response history is available for Starter plans and above',
        upgrade: true,
      });
    }

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;

    const responses = await dbAll(
      `SELECT * FROM responses WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3`,
      [req.user.id, limit, offset]
    );

    const total = await dbGet('SELECT COUNT(*) as count FROM responses WHERE user_id = $1', [
      req.user.id,
    ]);

    res.json({
      responses,
      pagination: {
        page,
        limit,
        total: parseInt(total.count),
        pages: Math.ceil(parseInt(total.count) / limit),
      },
    });
  } catch (error) {
    console.error('History error:', error);
    res.status(500).json({ error: 'Failed to get history' });
  }
});

// ============ STRIPE BILLING ============

app.post('/api/billing/create-checkout', authenticateToken, async (req, res) => {
  try {
    const { plan, billing = 'monthly', discountCode } = req.body;

    if (!PLAN_LIMITS[plan] || plan === 'free') {
      return res.status(400).json({ error: 'Invalid plan' });
    }

    const planConfig = PLAN_LIMITS[plan];
    const isYearly = billing === 'yearly';
    const priceId = isYearly ? planConfig.yearlyPriceId : planConfig.priceId;

    if (!priceId) {
      return res.status(400).json({ error: `${billing} billing not available for this plan` });
    }

    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Check for discount code
    let discounts = [];
    const upperDiscountCode = discountCode ? discountCode.toUpperCase() : '';

    if (upperDiscountCode === 'EARLY50') {
      // Create a 50% off coupon for early adopters (valid for 12 months)
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 50,
          duration: 'repeating',
          duration_in_months: 12,
          id: `EARLY50_${Date.now()}_${user.id}`,
          metadata: {
            campaign: 'early_adopter',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
      } catch (err) {
        console.log('Coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    } else if (upperDiscountCode === 'HUNTLAUNCH') {
      // Product Hunt Launch - 60% off for first 24 hours
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 60,
          duration: 'once', // Only first payment
          id: `HUNTLAUNCH_${Date.now()}_${user.id}`,
          redeem_by: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // Valid for 24 hours
          metadata: {
            campaign: 'product_hunt_launch',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
      } catch (err) {
        console.log('HUNTLAUNCH coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    } else if (upperDiscountCode === 'DEMOFOLLOWUP') {
      // Demo follow-up - 30% off for 48 hours
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 30,
          duration: 'repeating',
          duration_in_months: 3,
          id: `DEMOFOLLOWUP_${Date.now()}_${user.id}`,
          redeem_by: Math.floor(Date.now() / 1000) + 48 * 60 * 60, // Valid for 48 hours
          metadata: {
            campaign: 'demo_followup',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
      } catch (err) {
        console.log('DEMOFOLLOWUP coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    } else if (upperDiscountCode === 'WELCOME30' || upperDiscountCode === 'DEMO30') {
      // Welcome/Demo signup - 30% off for 7 days (first 3 months)
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 30,
          duration: 'repeating',
          duration_in_months: 3,
          id: `WELCOME30_${Date.now()}_${user.id}`,
          redeem_by: Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60, // Valid for 7 days
          metadata: {
            campaign: upperDiscountCode === 'DEMO30' ? 'demo_signup' : 'welcome_email',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
      } catch (err) {
        console.log('WELCOME30/DEMO30 coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    } else if (upperDiscountCode === 'FLASH50') {
      // Flash Offer - 50% off first month, 24h expiry (sent when user hits limit)
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 50,
          duration: 'once', // Only first payment
          id: `FLASH50_${Date.now()}_${user.id}`,
          redeem_by: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // Valid for 24 hours
          metadata: {
            campaign: 'flash_offer_limit_hit',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
        console.log(`[Flash Offer] Coupon FLASH50 created for user ${user.id}`);
      } catch (err) {
        console.log('FLASH50 coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    } else if (upperDiscountCode === 'COMEBACK20') {
      // Checkout Abandonment - 20% off, 7 days expiry
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 20,
          duration: 'once', // Only first payment
          id: `COMEBACK20_${Date.now()}_${user.id}`,
          redeem_by: Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60, // Valid for 7 days
          metadata: {
            campaign: 'checkout_abandonment',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
        console.log(`[Checkout Abandonment] Coupon COMEBACK20 created for user ${user.id}`);
      } catch (err) {
        console.log('COMEBACK20 coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    } else if (upperDiscountCode === 'HOTLEAD40') {
      // Hot Demo Visitor - 40% off, 48h expiry (sent when demo viewed 3+ times)
      try {
        const coupon = await stripe.coupons.create({
          percent_off: 40,
          duration: 'once', // Only first payment
          id: `HOTLEAD40_${Date.now()}_${user.id}`,
          redeem_by: Math.floor(Date.now() / 1000) + 48 * 60 * 60, // Valid for 48 hours
          metadata: {
            campaign: 'hot_demo_visitor',
            user_id: user.id.toString(),
          },
        });
        discounts = [
          {
            coupon: coupon.id,
          },
        ];
        console.log(`[Hot Demo Visitor] Coupon HOTLEAD40 created for user ${user.id}`);
      } catch (err) {
        console.log('HOTLEAD40 coupon creation error:', err);
        // Continue without discount if coupon fails
      }
    }

    const sessionConfig = {
      customer: user.stripe_customer_id,
      // Let Stripe automatically show all payment methods enabled in Dashboard
      // (Card, PayPal, SEPA, Link, Apple Pay, Google Pay)
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: `${process.env.FRONTEND_URL}/dashboard?success=true`,
      cancel_url: `${process.env.FRONTEND_URL}/pricing?canceled=true`,
      metadata: {
        userId: user.id.toString(),
        plan,
        billing,
      },
    };

    // Add discounts if available
    if (discounts.length > 0) {
      sessionConfig.discounts = discounts;
    }

    const session = await stripe.checkout.sessions.create(sessionConfig);

    res.json({ url: session.url });
  } catch (error) {
    console.error('Checkout error:', error);
    res.status(500).json({ error: 'Failed to create checkout session' });
  }
});

app.post('/api/billing/portal', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT stripe_customer_id FROM users WHERE id = $1', [req.user.id]);

    // Check if user has no Stripe customer (admin-upgraded)
    if (!user.stripe_customer_id) {
      return res.status(400).json({
        error: 'No Stripe subscription',
        noStripeCustomer: true,
      });
    }

    const session = await stripe.billingPortal.sessions.create({
      customer: user.stripe_customer_id,
      return_url: `${process.env.FRONTEND_URL}/dashboard`,
    });

    res.json({ url: session.url });
  } catch (error) {
    console.error('Portal error:', error);
    res.status(500).json({ error: 'Failed to create portal session' });
  }
});

// Micro-Pricing: Buy 10 responses for $5 (one-time payment, no subscription)
app.post('/api/billing/buy-responses', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT email, stripe_customer_id FROM users WHERE id = $1', [
      req.user.id,
    ]);

    // Create or retrieve Stripe customer
    let customerId = user.stripe_customer_id;
    if (!customerId) {
      const customer = await stripe.customers.create({ email: user.email });
      customerId = customer.id;
      await pool.query('UPDATE users SET stripe_customer_id = $1 WHERE id = $2', [
        customerId,
        req.user.id,
      ]);
    }

    // Check if Response Pack price exists in env
    const priceId = process.env.STRIPE_RESPONSE_PACK_PRICE_ID;
    if (!priceId) {
      console.error('[buy-responses] STRIPE_RESPONSE_PACK_PRICE_ID not configured');
      return res.status(500).json({ error: 'Response pack not configured. Contact support.' });
    }

    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      mode: 'payment', // One-time payment, NOT subscription
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      success_url: `${process.env.FRONTEND_URL}/dashboard?pack=success`,
      cancel_url: `${process.env.FRONTEND_URL}/pricing`,
      metadata: {
        userId: req.user.id.toString(),
        type: 'response_pack',
        responses: '10',
      },
    });

    res.json({ url: session.url });
  } catch (error) {
    console.error('[buy-responses] Error:', error);
    res.status(500).json({ error: 'Failed to create checkout session' });
  }
});

// Self-service plan change for testing (bypasses Stripe)
// WARNING: ADMIN-ONLY! Requires ADMIN_SECRET to prevent abuse
app.post('/api/admin/self-set-plan', authenticateToken, async (req, res) => {
  try {
    // SECURITY: Require ADMIN_SECRET
    const adminSecret = req.query.key || req.body.key || req.headers['x-admin-key'];
    if (!adminSecret || !safeCompare(adminSecret, process.env.ADMIN_SECRET || '')) {
      console.log(`âš ï¸ Unauthorized self-set-plan attempt by user ${req.user.id}`);
      return res.status(403).json({ error: 'Admin key required' });
    }

    const { plan } = req.body;
    const validPlans = ['free', 'starter', 'professional', 'unlimited'];

    if (!validPlans.includes(plan)) {
      return res.status(400).json({ error: 'Invalid plan' });
    }

    // Update plan (same logic as admin/set-plan)
    const limits = PLAN_LIMITS[plan];
    await pool.query(
      `
      UPDATE users SET
        subscription_plan = $1,
        subscription_status = $2,
        responses_limit = $3,
        responses_used = 0,
        smart_responses_used = 0,
        standard_responses_used = 0
      WHERE id = $4
    `,
      [plan, plan === 'free' ? 'inactive' : 'active', limits.responses, req.user.id]
    );

    console.log(`[ADMIN] Self-service plan change: User ${req.user.id} changed to ${plan}`);
    res.json({ success: true, plan });
  } catch (error) {
    console.error('Self-set-plan error:', error);
    res.status(500).json({ error: 'Failed to change plan' });
  }
});

// Stripe webhook handler
async function handleStripeWebhook(req, res) {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object;
        const userId = session.metadata.userId;
        const type = session.metadata.type;

        // Handle Response Pack purchase (one-time payment)
        if (type === 'response_pack') {
          const responses = parseInt(session.metadata.responses) || 10;
          await dbQuery(
            `UPDATE users SET bonus_responses = COALESCE(bonus_responses, 0) + $1 WHERE id = $2`,
            [responses, userId]
          );
          console.log(
            `ðŸ’° Response Pack purchased: User ${userId} got +${responses} bonus responses`
          );
          break;
        }

        // Handle subscription purchase
        const plan = session.metadata.plan;
        if (!plan || !PLAN_LIMITS[plan]) {
          console.error(`Invalid plan in webhook: ${plan}`);
          break;
        }

        await dbQuery(
          `UPDATE users SET subscription_status = 'active', subscription_plan = $1, responses_limit = $2, responses_used = 0 WHERE id = $3`,
          [plan, PLAN_LIMITS[plan].responses, userId]
        );

        // Process referral reward if user was referred
        const paidUser = await dbGet('SELECT referred_by FROM users WHERE id = $1', [userId]);
        if (paidUser && paidUser.referred_by) {
          const referral = await dbGet(
            'SELECT * FROM referrals WHERE referrer_id = $1 AND referred_user_id = $2 AND reward_given = FALSE',
            [paidUser.referred_by, userId]
          );

          if (referral) {
            await dbQuery(
              `UPDATE referrals SET status = 'converted', converted_at = NOW(), reward_given = TRUE WHERE id = $1`,
              [referral.id]
            );
            await dbQuery(
              `UPDATE users SET referral_credits = referral_credits + 1 WHERE id = $1`,
              [paidUser.referred_by]
            );
            console.log(
              `ðŸŽ‰ Referral reward! User ${paidUser.referred_by} earned 1 credit for referring user ${userId}`
            );
          }
        }
        break;
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object;
        const user = await dbGet('SELECT id FROM users WHERE stripe_customer_id = $1', [
          subscription.customer,
        ]);

        if (user) {
          const status = subscription.status === 'active' ? 'active' : 'inactive';
          await dbQuery(
            `UPDATE users SET subscription_status = $1, current_period_start = $2, current_period_end = $3 WHERE id = $4`,
            [
              status,
              new Date(subscription.current_period_start * 1000),
              new Date(subscription.current_period_end * 1000),
              user.id,
            ]
          );
        }
        break;
      }

      case 'checkout.session.expired': {
        // User started checkout but didn't complete
        const session = event.data.object;
        const userId = session.metadata?.userId;
        const plan = session.metadata?.plan;

        if (userId && process.env.NODE_ENV === 'production') {
          const user = await dbGet('SELECT * FROM users WHERE id = $1', [userId]);
          if (user && user.subscription_plan === 'free') {
            sendCheckoutAbandonmentEmail(user, plan).then(sent => {
              if (sent) {
                dbQuery('UPDATE users SET last_abandonment_email_at = NOW() WHERE id = $1', [userId]);
              }
            });
            console.log(`[Checkout Abandoned] User ${userId} didn't complete ${plan} checkout`);
          }
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        const user = await dbGet('SELECT id FROM users WHERE stripe_customer_id = $1', [
          subscription.customer,
        ]);

        if (user) {
          await dbQuery(
            `UPDATE users SET subscription_status = 'inactive', subscription_plan = 'free', responses_limit = $1 WHERE id = $2`,
            [PLAN_LIMITS.free.responses, user.id]
          );
        }
        break;
      }

      case 'invoice.paid': {
        const invoice = event.data.object;
        const user = await dbGet('SELECT * FROM users WHERE stripe_customer_id = $1', [
          invoice.customer,
        ]);

        if (user && user.subscription_plan !== 'free') {
          await dbQuery('UPDATE users SET responses_used = 0 WHERE id = $1', [user.id]);

          // Send plan renewal email
          if (process.env.NODE_ENV === 'production') {
            sendPlanRenewalEmail(user);
          }
          console.log(`ðŸ“§ Plan renewed for user ${user.id} (${user.subscription_plan})`);

          // Process affiliate commission (20% recurring)
          if (user.affiliate_id) {
            const affiliate = await dbGet(
              'SELECT * FROM affiliates WHERE id = $1 AND status = $2',
              [user.affiliate_id, 'approved']
            );

            if (affiliate) {
              const amountPaid = (invoice.amount_paid || 0) / 100; // Convert from cents to dollars
              const commissionRate = parseFloat(affiliate.commission_rate) || 20;
              const commissionAmount = amountPaid * (commissionRate / 100);

              if (commissionAmount > 0) {
                // Create affiliate conversion record
                await dbQuery(
                  `INSERT INTO affiliate_conversions (affiliate_id, referred_user_id, subscription_plan, amount_paid, commission_amount, commission_rate, stripe_invoice_id, status)
                   VALUES ($1, $2, $3, $4, $5, $6, $7, 'approved')`,
                  [
                    affiliate.id,
                    user.id,
                    user.subscription_plan,
                    amountPaid,
                    commissionAmount,
                    commissionRate,
                    invoice.id,
                  ]
                );

                // Update affiliate totals
                await dbQuery(
                  `UPDATE affiliates SET total_earned = total_earned + $1, pending_balance = pending_balance + $1 WHERE id = $2`,
                  [commissionAmount, affiliate.id]
                );

                console.log(
                  `ðŸ’° Affiliate commission: $${commissionAmount.toFixed(2)} for affiliate ${affiliate.affiliate_code} (User ${user.id} paid $${amountPaid.toFixed(2)})`
                );
              }
            }
          }
        }
        break;
      }
    }
  } catch (error) {
    console.error('Webhook processing error:', error);
    return res.status(500).json({ error: 'Webhook processing failed' });
  }

  res.json({ received: true });
}

// ============ SUPPORT ============

app.post('/api/support/contact', async (req, res) => {
  try {
    const { name, email, subject, message } = req.body;

    if (!name || !email || !subject || !message) {
      return res.status(400).json({ error: 'All fields are required' });
    }

    if (!validator.isEmail(email)) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    await dbQuery(
      `INSERT INTO support_requests (name, email, subject, message) VALUES ($1, $2, $3, $4)`,
      [name, email, subject, message]
    );

    console.log(`ðŸ“¬ New support request from ${email}: ${subject}`);

    // Email-Benachrichtigung an Admin
    if (resend) {
      try {
        await resend.emails.send({
          from: FROM_EMAIL,
          replyTo: email, // Antwort geht direkt an den User
          to: 'berend.jakob.mainz@gmail.com',
          subject: `[Support] ${subject}`,
          html: `
            <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #4F46E5;">Neue Support-Anfrage</h2>
              <p><strong>Von:</strong> ${name}</p>
              <p><strong>Email:</strong> ${email}</p>
              <p><strong>Betreff:</strong> ${subject}</p>
              <hr style="border: none; border-top: 1px solid #E5E7EB; margin: 20px 0;">
              <p><strong>Nachricht:</strong></p>
              <p style="white-space: pre-wrap;">${message}</p>
              <hr style="border: none; border-top: 1px solid #E5E7EB; margin: 20px 0;">
              <p style="color: #6B7280; font-size: 14px;">
                Antworte direkt auf diese Email - sie geht an ${email}
              </p>
            </div>
          `,
        });
        console.log(`ðŸ“§ Support notification sent to admin for: ${email}`);
      } catch (emailError) {
        console.error('Failed to send support notification:', emailError);
      }
    }

    res.json({ success: true, message: 'Message received. We will respond within 24 hours.' });
  } catch (error) {
    console.error('Support error:', error);
    res.status(500).json({ error: 'Failed to send message' });
  }
});

// ============ USAGE STATS ============

app.get('/api/stats', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Check if user is a team member (usage comes from team owner)
    let usageOwner = user;
    let isTeamMember = false;
    const teamMembership = await dbGet(
      `SELECT tm.*, u.id as owner_id, u.subscription_plan as owner_plan, u.subscription_status as owner_status,
              u.smart_responses_used as owner_smart_used, u.standard_responses_used as owner_standard_used,
              u.responses_used as owner_responses_used, u.responses_limit as owner_responses_limit
       FROM team_members tm
       JOIN users u ON tm.team_owner_id = u.id
       WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
      [req.user.id]
    );
    if (teamMembership) {
      isTeamMember = true;
      usageOwner = {
        id: teamMembership.owner_id,
        subscription_plan: teamMembership.owner_plan,
        subscription_status: teamMembership.owner_status,
        smart_responses_used: teamMembership.owner_smart_used || 0,
        standard_responses_used: teamMembership.owner_standard_used || 0,
        responses_used: teamMembership.owner_responses_used || 0,
        responses_limit: teamMembership.owner_responses_limit || 0,
      };
    }

    // Determine effective plan
    const effectivePlan = isTeamMember ? usageOwner.subscription_plan : user.subscription_plan;
    const planLimits = PLAN_LIMITS[effectivePlan] || PLAN_LIMITS.free;

    // Get smart/standard usage
    const smartUsed = usageOwner.smart_responses_used || 0;
    const standardUsed = usageOwner.standard_responses_used || 0;
    const totalUsed = smartUsed + standardUsed;
    const totalLimit = planLimits.responses;

    const totalResponses = await dbGet(
      'SELECT COUNT(*) as count FROM responses WHERE user_id = $1',
      [req.user.id]
    );

    const thisMonth = await dbGet(
      `SELECT COUNT(*) as count FROM responses WHERE user_id = $1 AND created_at >= date_trunc('month', CURRENT_DATE)`,
      [req.user.id]
    );

    const byPlatform = await dbAll(
      `SELECT review_platform, COUNT(*) as count FROM responses WHERE user_id = $1 GROUP BY review_platform`,
      [req.user.id]
    );

    const byRating = await dbAll(
      `SELECT review_rating, COUNT(*) as count FROM responses WHERE user_id = $1 AND review_rating IS NOT NULL GROUP BY review_rating`,
      [req.user.id]
    );

    // Count responses by AI model this month
    const byAiModel = await dbAll(
      `SELECT COALESCE(ai_model, 'standard') as ai_model, COUNT(*) as count
       FROM responses WHERE user_id = $1 AND created_at >= date_trunc('month', CURRENT_DATE)
       GROUP BY COALESCE(ai_model, 'standard')`,
      [req.user.id]
    );

    res.json({
      usage: {
        smart: {
          used: smartUsed,
          limit: planLimits.smartResponses,
          remaining: Math.max(0, planLimits.smartResponses - smartUsed),
        },
        standard: {
          used: standardUsed,
          limit: planLimits.standardResponses,
          remaining: Math.max(0, planLimits.standardResponses - standardUsed),
        },
        total: {
          used: totalUsed,
          limit: totalLimit,
          remaining: Math.max(0, totalLimit - totalUsed),
        },
        // Backward compatibility
        used: totalUsed,
        limit: totalLimit,
        remaining: Math.max(0, totalLimit - totalUsed),
      },
      stats: {
        totalResponses: parseInt(totalResponses.count),
        thisMonth: parseInt(thisMonth.count),
        byPlatform,
        byRating,
        byAiModel,
      },
      subscription: {
        plan: effectivePlan,
        status: isTeamMember ? usageOwner.subscription_status : user.subscription_status,
      },
      isTeamMember,
      hasSmartAI: !!anthropic,
      // For password management (OAuth users may not have password)
      hasPassword: !!user.password,
      oauthProvider: user.oauth_provider || null,
    });
  } catch (error) {
    console.error('Stats error:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// ============ RESPONSE TEMPLATES ============

// Get all templates for user
app.get('/api/templates', authenticateToken, async (req, res) => {
  try {
    const templates = await dbAll(
      'SELECT * FROM response_templates WHERE user_id = $1 ORDER BY created_at DESC',
      [req.user.id]
    );
    res.json({ templates });
  } catch (error) {
    console.error('Get templates error:', error);
    res.status(500).json({ error: 'Failed to get templates' });
  }
});

// Create new template
app.post('/api/templates', authenticateToken, async (req, res) => {
  try {
    const { name, content, tone, platform, category } = req.body;

    if (!name || !content) {
      return res.status(400).json({ error: 'Name and content are required' });
    }

    if (name.length > 100) {
      return res.status(400).json({ error: 'Template name must be 100 characters or less' });
    }

    // Check template limit (max 20 per user)
    const count = await dbGet(
      'SELECT COUNT(*) as count FROM response_templates WHERE user_id = $1',
      [req.user.id]
    );

    if (parseInt(count.count) >= 20) {
      return res
        .status(400)
        .json({ error: 'Maximum of 20 templates allowed. Delete some templates to add new ones.' });
    }

    const result = await dbQuery(
      `INSERT INTO response_templates (user_id, name, content, tone, platform, category)
       VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`,
      [
        req.user.id,
        name.trim(),
        content,
        tone || 'professional',
        platform || 'google',
        category || null,
      ]
    );

    res.status(201).json({ template: result.rows[0] });
  } catch (error) {
    console.error('Create template error:', error);
    res.status(500).json({ error: 'Failed to create template' });
  }
});

// Update template
app.put('/api/templates/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, content, tone, platform, category } = req.body;

    // Verify ownership
    const existing = await dbGet(
      'SELECT * FROM response_templates WHERE id = $1 AND user_id = $2',
      [id, req.user.id]
    );

    if (!existing) {
      return res.status(404).json({ error: 'Template not found' });
    }

    if (!name || !content) {
      return res.status(400).json({ error: 'Name and content are required' });
    }

    const result = await dbQuery(
      `UPDATE response_templates SET name = $1, content = $2, tone = $3, platform = $4, category = $5
       WHERE id = $6 AND user_id = $7 RETURNING *`,
      [
        name.trim(),
        content,
        tone || 'professional',
        platform || 'google',
        category || null,
        id,
        req.user.id,
      ]
    );

    res.json({ template: result.rows[0] });
  } catch (error) {
    console.error('Update template error:', error);
    res.status(500).json({ error: 'Failed to update template' });
  }
});

// Delete template
app.delete('/api/templates/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    // Verify ownership
    const existing = await dbGet(
      'SELECT * FROM response_templates WHERE id = $1 AND user_id = $2',
      [id, req.user.id]
    );

    if (!existing) {
      return res.status(404).json({ error: 'Template not found' });
    }

    await dbQuery('DELETE FROM response_templates WHERE id = $1 AND user_id = $2', [
      id,
      req.user.id,
    ]);

    res.json({ success: true, message: 'Template deleted' });
  } catch (error) {
    console.error('Delete template error:', error);
    res.status(500).json({ error: 'Failed to delete template' });
  }
});

// ============ TEAM MANAGEMENT (Professional & Unlimited Plans) ============

// Helper: Check if plan has team access (Pro: 3 members, Unlimited: 10 members)
function hasTeamAccess(plan) {
  return ['professional', 'unlimited'].includes(plan);
}

function getMaxTeamMembers(plan) {
  return PLAN_LIMITS[plan]?.teamMembers || 0;
}

// GET /api/team - Get all team members
app.get('/api/team', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    if (!hasTeamAccess(user.subscription_plan)) {
      return res.status(403).json({
        error: 'Team features are available for Professional and Unlimited plans',
        upgrade: true,
        requiredPlan: 'professional',
      });
    }
    const members = await dbAll(
      `SELECT tm.*, u.email as user_email, u.business_name FROM team_members tm LEFT JOIN users u ON tm.member_user_id = u.id WHERE tm.team_owner_id = $1 ORDER BY tm.invited_at DESC`,
      [req.user.id]
    );
    const maxMembers = getMaxTeamMembers(user.subscription_plan);
    res.json({
      isTeamOwner: true,
      members: members.map(m => ({
        id: m.id,
        email: m.member_email,
        role: m.role,
        status: m.accepted_at ? 'active' : 'pending',
        invitedAt: m.invited_at,
        acceptedAt: m.accepted_at,
        businessName: m.business_name,
      })),
      maxMembers,
      plan: user.subscription_plan,
    });
  } catch (error) {
    console.error('Get team error:', error);
    res.status(500).json({ error: 'Failed to get team members' });
  }
});

// POST /api/team/invite - Invite a new team member
app.post('/api/team/invite', authenticateToken, async (req, res) => {
  try {
    const { email, role = 'member' } = req.body;
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    if (!hasTeamAccess(user.subscription_plan)) {
      return res.status(403).json({
        error: 'Team features are available for Professional and Unlimited plans',
        upgrade: true,
      });
    }
    if (!email || !validator.isEmail(email))
      return res.status(400).json({ error: 'Valid email is required' });
    if (email.toLowerCase() === user.email.toLowerCase())
      return res.status(400).json({ error: 'You cannot invite yourself' });
    const validRoles = ['admin', 'member', 'viewer'];
    if (!validRoles.includes(role))
      return res.status(400).json({ error: 'Invalid role. Must be admin, member, or viewer' });
    const memberCount = await dbGet(
      'SELECT COUNT(*) as count FROM team_members WHERE team_owner_id = $1',
      [req.user.id]
    );
    const maxMembers = getMaxTeamMembers(user.subscription_plan);
    if (parseInt(memberCount.count) >= maxMembers) {
      return res.status(400).json({
        error: `Maximum ${maxMembers} team members allowed on your plan`,
        upgrade: user.subscription_plan === 'professional',
      });
    }
    const existing = await dbGet(
      'SELECT * FROM team_members WHERE team_owner_id = $1 AND LOWER(member_email) = LOWER($2)',
      [req.user.id, email]
    );
    if (existing) return res.status(400).json({ error: 'This email has already been invited' });
    const inviteToken = crypto.randomBytes(32).toString('hex');
    const existingUser = await dbGet('SELECT id FROM users WHERE LOWER(email) = LOWER($1)', [
      email,
    ]);
    await dbQuery(
      `INSERT INTO team_members (team_owner_id, member_email, member_user_id, role, invite_token) VALUES ($1, $2, $3, $4, $5)`,
      [req.user.id, email.toLowerCase(), existingUser?.id || null, role, inviteToken]
    );
    if (resend) {
      try {
        const inviteHtml = `<div style="font-family:Arial,sans-serif;max-width:600px;margin:0 auto;"><div style="background:linear-gradient(135deg,#4F46E5 0%,#7C3AED 100%);padding:30px;text-align:center;"><h1 style="color:white;margin:0;">You're Invited!</h1></div><div style="padding:30px;background:#f9fafb;"><p style="font-size:16px;color:#374151;"><strong>${user.business_name || user.email}</strong> has invited you to join their ReviewResponder team as a <strong>${role}</strong>.</p><p style="font-size:14px;color:#6b7280;">As a team member, you'll be able to generate AI-powered review responses using their subscription.</p><div style="text-align:center;margin:30px 0;"><a href="${process.env.FRONTEND_URL}/join-team?token=${inviteToken}" style="background:#4F46E5;color:white;padding:14px 28px;text-decoration:none;border-radius:8px;font-weight:bold;display:inline-block;">Accept Invitation</a></div></div></div>`;
        await resend.emails.send({
          from: FROM_EMAIL,
          to: email,
          subject: `${user.business_name || user.email} invited you to their team`,
          html: inviteHtml,
        });
      } catch (e) {
        console.error('Failed to send team invite email:', e);
      }
    }
    // Always return token so frontend can show invite link (useful if email fails)
    res.status(201).json({
      success: true,
      message: `Invitation sent to ${email}`,
      inviteToken,
      inviteUrl: `${process.env.FRONTEND_URL}/join-team?token=${inviteToken}`,
    });
  } catch (error) {
    console.error('Invite error:', error);
    res.status(500).json({ error: 'Failed to invite team member' });
  }
});

// GET /api/team/invite/:token - Validate invite token (public endpoint)
app.get('/api/team/invite/:token', async (req, res) => {
  try {
    const { token } = req.params;
    const invitation = await dbGet(
      `SELECT tm.*, u.email as owner_email, u.business_name as owner_business FROM team_members tm JOIN users u ON tm.team_owner_id = u.id WHERE tm.invite_token = $1 AND tm.accepted_at IS NULL`,
      [token]
    );
    if (!invitation) return res.status(404).json({ error: 'Invalid or expired invitation' });
    res.json({
      valid: true,
      invitedEmail: invitation.member_email,
      invitedBy: invitation.owner_business || invitation.owner_email,
      role: invitation.role,
    });
  } catch (error) {
    console.error('Validate invite error:', error);
    res.status(500).json({ error: 'Failed to validate invitation' });
  }
});

// POST /api/team/accept - Accept team invitation
app.post('/api/team/accept', authenticateToken, async (req, res) => {
  try {
    const { token } = req.body;
    if (!token) return res.status(400).json({ error: 'Invite token is required' });
    const invitation = await dbGet(
      `SELECT tm.*, u.email as owner_email, u.business_name as owner_business FROM team_members tm JOIN users u ON tm.team_owner_id = u.id WHERE tm.invite_token = $1 AND tm.accepted_at IS NULL`,
      [token]
    );
    if (!invitation) return res.status(404).json({ error: 'Invalid or expired invitation' });
    const currentUser = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    if (currentUser.email.toLowerCase() !== invitation.member_email.toLowerCase())
      return res
        .status(403)
        .json({ error: 'This invitation was sent to a different email address' });
    await dbQuery(
      `UPDATE team_members SET accepted_at = CURRENT_TIMESTAMP, member_user_id = $1, invite_token = NULL WHERE id = $2`,
      [req.user.id, invitation.id]
    );
    res.json({
      success: true,
      message: `You've joined ${invitation.owner_business || invitation.owner_email}'s team!`,
      teamOwner: { email: invitation.owner_email, businessName: invitation.owner_business },
      role: invitation.role,
    });
  } catch (error) {
    console.error('Accept error:', error);
    res.status(500).json({ error: 'Failed to accept invitation' });
  }
});

// PUT /api/team/:memberId/role - Update team member role
app.put('/api/team/:memberId/role', authenticateToken, async (req, res) => {
  try {
    const { memberId } = req.params;
    const { role } = req.body;
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    if (!hasTeamAccess(user.subscription_plan))
      return res
        .status(403)
        .json({ error: 'Team features are available for Professional and Unlimited plans' });
    const validRoles = ['admin', 'member', 'viewer'];
    if (!validRoles.includes(role))
      return res.status(400).json({ error: 'Invalid role. Must be admin, member, or viewer' });
    const member = await dbGet('SELECT * FROM team_members WHERE id = $1 AND team_owner_id = $2', [
      memberId,
      req.user.id,
    ]);
    if (!member) return res.status(404).json({ error: 'Team member not found' });
    await dbQuery('UPDATE team_members SET role = $1 WHERE id = $2', [role, memberId]);
    res.json({ success: true, message: 'Role updated', newRole: role });
  } catch (error) {
    console.error('Update role error:', error);
    res.status(500).json({ error: 'Failed to update role' });
  }
});

// DELETE /api/team/:memberId - Remove team member
app.delete('/api/team/:memberId', authenticateToken, async (req, res) => {
  try {
    const { memberId } = req.params;
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    if (!hasTeamAccess(user.subscription_plan))
      return res
        .status(403)
        .json({ error: 'Team features are available for Professional and Unlimited plans' });
    const member = await dbGet('SELECT * FROM team_members WHERE id = $1 AND team_owner_id = $2', [
      memberId,
      req.user.id,
    ]);
    if (!member) return res.status(404).json({ error: 'Team member not found' });
    await dbQuery('DELETE FROM team_members WHERE id = $1', [memberId]);
    res.json({ success: true, message: 'Team member removed' });
  } catch (error) {
    console.error('Remove member error:', error);
    res.status(500).json({ error: 'Failed to remove team member' });
  }
});

// GET /api/team/my-team - Get team info for current user (as member or owner)
app.get('/api/team/my-team', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);
    // Check if user is a team member (belongs to someone else's team)
    const tm = await dbGet(
      `SELECT tm.*, u.email as owner_email, u.business_name as owner_business, u.responses_used, u.responses_limit, u.subscription_plan as owner_plan FROM team_members tm JOIN users u ON tm.team_owner_id = u.id WHERE tm.member_user_id = $1 AND tm.accepted_at IS NOT NULL`,
      [req.user.id]
    );
    if (tm) {
      return res.json({
        isTeamMember: true,
        teamOwner: { email: tm.owner_email, businessName: tm.owner_business },
        role: tm.role,
        teamUsage: { used: tm.responses_used, limit: tm.responses_limit },
      });
    }
    const c = await dbGet('SELECT COUNT(*) as count FROM team_members WHERE team_owner_id = $1', [
      req.user.id,
    ]);
    res.json({
      isTeamMember: false,
      isTeamOwner: hasTeamAccess(user.subscription_plan),
      canHaveTeam: hasTeamAccess(user.subscription_plan),
      teamMemberCount: parseInt(c.count),
      maxTeamMembers: getMaxTeamMembers(user.subscription_plan),
      plan: user.subscription_plan,
    });
  } catch (error) {
    console.error('Get my-team error:', error);
    res.status(500).json({ error: 'Failed to get team info' });
  }
});

// POST /api/team/leave - Leave a team (for team members)
app.post('/api/team/leave', authenticateToken, async (req, res) => {
  try {
    const membership = await dbGet(
      'SELECT * FROM team_members WHERE member_user_id = $1 AND accepted_at IS NOT NULL',
      [req.user.id]
    );
    if (!membership) return res.status(404).json({ error: 'You are not a member of any team' });
    await dbQuery('DELETE FROM team_members WHERE id = $1', [membership.id]);
    res.json({ success: true, message: 'You have left the team' });
  } catch (error) {
    console.error('Leave team error:', error);
    res.status(500).json({ error: 'Failed to leave team' });
  }
});

// ============ EMAIL CAPTURE ============

// Capture email from exit-intent popup or instant demo widget
app.post('/api/capture-email', async (req, res) => {
  try {
    const {
      email,
      discountCode = null,
      source = 'exit_intent',
      landing_page = null, // NEW: For widget attribution
      platform = null, // NEW: For widget attribution
      business_type = null, // NEW: For widget attribution
    } = req.body;

    // Validate email
    if (!email || !validator.isEmail(email)) {
      return res.status(400).json({ error: 'Valid email is required' });
    }

    // Check if email already exists
    const existing = await dbGet('SELECT * FROM email_captures WHERE LOWER(email) = LOWER($1)', [
      email,
    ]);

    if (existing) {
      console.log(`ðŸ“§ Email already captured: ${email}`);
      return res.json({
        success: true,
        message: 'Thanks for joining!',
        discountCode: existing.discount_code,
      });
    }

    // Insert new email with attribution data
    await dbQuery(
      `INSERT INTO email_captures (email, discount_code, source, landing_page, platform, business_type)
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [email.toLowerCase(), discountCode, source, landing_page, platform, business_type]
    );

    console.log(`âœ… Email captured: ${email} (source: ${source})`);

    // Send welcome email if Resend is configured
    if (resend && process.env.NODE_ENV === 'production') {
      try {
        // Different email based on whether discount code is present
        const emailContent = discountCode
          ? {
              subject: `Your ${discountCode === 'EARLY50' ? '50%' : discountCode === 'HUNTLAUNCH' ? '60%' : '30%'} discount code inside`,
              html: `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
            </head>
            <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; margin: 0; padding: 0; background-color: #f9fafb;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0;">
                  <h1 style="margin: 0; font-size: 24px;">Your Exclusive Discount</h1>
                </div>
                <div style="background: white; padding: 40px; border: 1px solid #E5E7EB; border-top: none; border-radius: 0 0 8px 8px;">
                  <p style="margin-top: 0;">Hi there,</p>

                  <p>Thanks for your interest in ReviewResponder! Here's your exclusive discount:</p>

                  <div style="background: linear-gradient(135deg, #10b981, #059669); padding: 24px; border-radius: 8px; text-align: center; margin: 24px 0;">
                    <p style="margin: 0 0 8px 0; color: rgba(255,255,255,0.9); font-size: 14px;">Your discount code</p>
                    <div style="font-size: 28px; font-weight: bold; color: white; font-family: monospace;">${discountCode}</div>
                  </div>

                  <p>ReviewResponder helps businesses respond to customer reviews in seconds using AI. No more staring at a blank screen wondering what to write.</p>

                  <div style="text-align: center; margin: 32px 0;">
                    <a href="${process.env.FRONTEND_URL}/claim/${discountCode}" style="display: inline-block; background: #10b981; color: white; padding: 16px 40px; text-decoration: none; border-radius: 8px; font-weight: 700; font-size: 18px;">Claim Your Discount</a>
                  </div>

                  <p style="color: #6B7280; font-size: 14px;">Questions? Just reply to this email.</p>

                  <p style="margin-bottom: 0;">Cheers,<br>Berend from ReviewResponder</p>
                </div>
                <div style="text-align: center; padding: 20px; color: #9CA3AF; font-size: 12px;">
                  <p style="margin: 0;">You're receiving this because you signed up at tryreviewresponder.com</p>
                </div>
              </div>
            </body>
            </html>
          `,
            }
          : {
              subject: "You're on the early access list!",
              html: `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
            </head>
            <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; margin: 0; padding: 0; background-color: #f9fafb;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0;">
                  <h1 style="margin: 0; font-size: 24px;">Welcome to ReviewResponder</h1>
                </div>
                <div style="background: white; padding: 40px; border: 1px solid #E5E7EB; border-top: none; border-radius: 0 0 8px 8px;">
                  <p style="margin-top: 0;">Hi there,</p>

                  <p>Thanks for signing up! You're now on our early access list.</p>

                  <p>ReviewResponder helps businesses respond to customer reviews in seconds using AI. No more staring at a blank screen wondering what to write.</p>

                  <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 24px 0;">
                    <p style="margin: 0; font-weight: 600;">What you get with ReviewResponder:</p>
                    <ul style="margin: 12px 0 0 0; padding-left: 20px;">
                      <li>AI-powered review responses in seconds</li>
                      <li>4 different tones (Professional, Friendly, Apologetic, Grateful)</li>
                      <li>Any language (auto-detect)</li>
                      <li>Chrome Extension for all major platforms</li>
                    </ul>
                  </div>

                  <div style="text-align: center; margin: 32px 0;">
                    <a href="${process.env.FRONTEND_URL}/register" style="display: inline-block; background: #4F46E5; color: white; padding: 16px 40px; text-decoration: none; border-radius: 8px; font-weight: 700; font-size: 18px;">Start Free - 5 Responses</a>
                  </div>

                  <p style="color: #6B7280; font-size: 14px;">Questions? Just reply to this email.</p>

                  <p style="margin-bottom: 0;">Cheers,<br>Berend from ReviewResponder</p>
                </div>
                <div style="text-align: center; padding: 20px; color: #9CA3AF; font-size: 12px;">
                  <p style="margin: 0;">You're receiving this because you signed up at tryreviewresponder.com</p>
                </div>
              </div>
            </body>
            </html>
          `,
            };

        await resend.emails.send({
          from: FROM_EMAIL,
          replyTo: 'hello@tryreviewresponder.com',
          to: email,
          ...emailContent,
        });
        console.log(`ðŸ“¨ Welcome email sent to ${email}`);
      } catch (emailError) {
        console.error('Failed to send welcome email:', emailError);
        // Don't fail the request if email fails
      }
    }

    res.json({
      success: true,
      message: 'Thanks for joining!',
      discountCode,
    });
  } catch (error) {
    console.error('Email capture error:', error);
    res.status(500).json({ error: 'Failed to save email' });
  }
});

// ============ PERSONALIZED DISCOUNT LINKS ============

// Generate a short unique token
const generateDiscountToken = () => {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
  let token = '';
  for (let i = 0; i < 8; i++) {
    token += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return token;
};

// Create personalized discount link
app.post('/api/discount-links', async (req, res) => {
  try {
    const {
      discountCode,
      recipientName,
      businessName,
      email,
      source = 'outreach',
      expiresInHours = 48,
    } = req.body;

    if (!discountCode) {
      return res.status(400).json({ error: 'discountCode is required' });
    }

    // Generate unique token
    let token = generateDiscountToken();
    let attempts = 0;
    while (attempts < 10) {
      const existing = await dbGet('SELECT id FROM discount_links WHERE token = $1', [token]);
      if (!existing) break;
      token = generateDiscountToken();
      attempts++;
    }

    // Calculate expiry
    const expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);

    // Insert link
    await dbQuery(
      `INSERT INTO discount_links (token, discount_code, recipient_name, business_name, email, expires_at, source)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        token,
        discountCode.toUpperCase(),
        recipientName || null,
        businessName || null,
        email || null,
        expiresAt,
        source,
      ]
    );

    const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

    console.log(`ðŸ”— Discount link created: ${token} for ${recipientName || email || 'anonymous'}`);

    res.json({
      success: true,
      token,
      url: `${FRONTEND_URL}/claim/${token}`,
      expiresAt: expiresAt.toISOString(),
    });
  } catch (error) {
    console.error('Discount link creation error:', error);
    res.status(500).json({ error: 'Failed to create discount link' });
  }
});

// Get discount link data (public endpoint for claim page)
app.get('/api/discount-links/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const link = await dbGet('SELECT * FROM discount_links WHERE token = $1', [token]);

    if (!link) {
      return res.status(404).json({ error: 'Discount link not found', valid: false });
    }

    // Increment views
    await dbQuery('UPDATE discount_links SET views = views + 1 WHERE token = $1', [token]);

    // Check if expired
    const isExpired = link.expires_at && new Date(link.expires_at) < new Date();

    // Discount info
    const discountInfo = {
      EARLY50: { percent: 50, label: 'Early Access', duration: '12 months' },
      HUNTLAUNCH: { percent: 60, label: 'Product Hunt Special', duration: '12 months' },
      DEMOFOLLOWUP: { percent: 30, label: 'Demo Special', duration: '3 months' },
      DEMO30: { percent: 30, label: 'Demo Discount', duration: '3 months' },
      WELCOME30: { percent: 30, label: 'Welcome Offer', duration: '3 months' },
      COMEBACK20: { percent: 20, label: 'Welcome Back', duration: '3 months' },
    };

    const discount = discountInfo[link.discount_code] || {
      percent: 20,
      label: 'Special Offer',
      duration: '12 months',
    };

    res.json({
      valid: true,
      token: link.token,
      discountCode: link.discount_code,
      recipientName: link.recipient_name,
      businessName: link.business_name,
      expiresAt: link.expires_at,
      isExpired,
      claimed: link.claimed,
      discount,
      source: link.source,
    });
  } catch (error) {
    console.error('Discount link fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch discount link' });
  }
});

// Mark discount link as claimed
app.post('/api/discount-links/:token/claim', async (req, res) => {
  try {
    const { token } = req.params;

    await dbQuery('UPDATE discount_links SET claimed = true WHERE token = $1', [token]);

    res.json({ success: true });
  } catch (error) {
    console.error('Discount claim error:', error);
    res.status(500).json({ error: 'Failed to mark as claimed' });
  }
});

// ============ ANALYTICS (Pro/Unlimited Only) ============

app.get('/api/analytics', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Check if user has Pro or Unlimited plan
    if (!['professional', 'unlimited'].includes(user.subscription_plan)) {
      return res.status(403).json({
        error: 'Analytics is only available for Professional and Unlimited plans',
        upgrade: true,
        requiredPlan: 'professional',
      });
    }

    // Total responses
    const totalResponses = await dbGet(
      'SELECT COUNT(*) as count FROM responses WHERE user_id = $1',
      [req.user.id]
    );

    // Responses by tone (for pie chart)
    const byTone = await dbAll(
      `SELECT tone, COUNT(*) as count FROM responses WHERE user_id = $1 GROUP BY tone ORDER BY count DESC`,
      [req.user.id]
    );

    // Responses by platform
    const byPlatform = await dbAll(
      `SELECT review_platform as platform, COUNT(*) as count FROM responses WHERE user_id = $1 GROUP BY review_platform ORDER BY count DESC`,
      [req.user.id]
    );

    // Responses over time (last 30 days, grouped by day)
    const overTime = await dbAll(
      `SELECT
        DATE(created_at) as date,
        COUNT(*) as count
       FROM responses
       WHERE user_id = $1 AND created_at >= NOW() - INTERVAL '30 days'
       GROUP BY DATE(created_at)
       ORDER BY date ASC`,
      [req.user.id]
    );

    // Responses by rating
    const byRating = await dbAll(
      `SELECT review_rating as rating, COUNT(*) as count FROM responses WHERE user_id = $1 AND review_rating IS NOT NULL GROUP BY review_rating ORDER BY rating DESC`,
      [req.user.id]
    );

    // Average responses per day (last 30 days)
    const avgPerDay = await dbGet(
      `SELECT COALESCE(AVG(daily_count), 0) as avg FROM (
        SELECT DATE(created_at) as day, COUNT(*) as daily_count
        FROM responses
        WHERE user_id = $1 AND created_at >= NOW() - INTERVAL '30 days'
        GROUP BY DATE(created_at)
      ) daily_counts`,
      [req.user.id]
    );

    // This week vs last week
    const thisWeek = await dbGet(
      `SELECT COUNT(*) as count FROM responses WHERE user_id = $1 AND created_at >= DATE_TRUNC('week', CURRENT_DATE)`,
      [req.user.id]
    );
    const lastWeek = await dbGet(
      `SELECT COUNT(*) as count FROM responses WHERE user_id = $1 AND created_at >= DATE_TRUNC('week', CURRENT_DATE) - INTERVAL '7 days' AND created_at < DATE_TRUNC('week', CURRENT_DATE)`,
      [req.user.id]
    );

    // Most used tone
    const mostUsedTone = byTone.length > 0 ? byTone[0].tone : 'professional';

    res.json({
      totalResponses: parseInt(totalResponses.count),
      byTone: byTone.map(t => ({ name: t.tone, value: parseInt(t.count) })),
      byPlatform: byPlatform.map(p => ({
        name: p.platform || 'unknown',
        value: parseInt(p.count),
      })),
      overTime: overTime.map(d => ({ date: d.date, responses: parseInt(d.count) })),
      byRating: byRating.map(r => ({ rating: r.rating, count: parseInt(r.count) })),
      insights: {
        avgPerDay: parseFloat(avgPerDay.avg || 0).toFixed(1),
        thisWeek: parseInt(thisWeek.count),
        lastWeek: parseInt(lastWeek.count),
        weeklyChange: parseInt(thisWeek.count) - parseInt(lastWeek.count),
        mostUsedTone,
      },
    });
  } catch (error) {
    console.error('Analytics error:', error);
    res.status(500).json({ error: 'Failed to get analytics' });
  }
});

// ============== SEO BLOG ARTICLE GENERATOR (Pro/Unlimited Only) ==============

// Pre-defined SEO topics for review management
const BLOG_TOPICS = [
  {
    id: 'respond-negative',
    title: 'How to Respond to Negative Reviews',
    keywords: ['negative reviews', 'customer complaints', 'reputation management'],
  },
  {
    id: 'review-management-basics',
    title: 'Review Management Best Practices for Small Businesses',
    keywords: ['review management', 'small business', 'online reputation'],
  },
  {
    id: 'increase-reviews',
    title: 'How to Get More Customer Reviews',
    keywords: ['get more reviews', 'customer feedback', 'review generation'],
  },
  {
    id: 'respond-positive',
    title: 'Why Responding to Positive Reviews Matters',
    keywords: ['positive reviews', 'customer appreciation', 'brand loyalty'],
  },
  {
    id: 'google-reviews',
    title: 'The Complete Guide to Google Reviews',
    keywords: ['Google reviews', 'Google My Business', 'local SEO'],
  },
  {
    id: 'yelp-reviews',
    title: 'Mastering Yelp Reviews for Your Business',
    keywords: ['Yelp reviews', 'Yelp business', 'restaurant reviews'],
  },
  {
    id: 'fake-reviews',
    title: 'How to Handle Fake or Unfair Reviews',
    keywords: ['fake reviews', 'review removal', 'unfair reviews'],
  },
  {
    id: 'review-response-templates',
    title: 'Review Response Templates That Actually Work',
    keywords: ['review templates', 'response examples', 'copy paste reviews'],
  },
  {
    id: 'review-seo',
    title: 'How Reviews Impact Your Local SEO Rankings',
    keywords: ['reviews SEO', 'local search', 'Google ranking'],
  },
  {
    id: 'ai-review-responses',
    title: 'Using AI to Write Professional Review Responses',
    keywords: ['AI reviews', 'automated responses', 'review automation'],
  },
  {
    id: 'crisis-management',
    title: 'Review Crisis Management: What to Do When Things Go Wrong',
    keywords: ['crisis management', 'bad reviews', 'reputation repair'],
  },
  {
    id: 'review-monitoring',
    title: 'How to Monitor Your Online Reviews Effectively',
    keywords: ['review monitoring', 'reputation tracking', 'alerts'],
  },
];

// GET /api/blog/topics - Get available topic suggestions
app.get('/api/blog/topics', authenticateToken, async (req, res) => {
  try {
    res.json({ topics: BLOG_TOPICS });
  } catch (error) {
    console.error('Get blog topics error:', error);
    res.status(500).json({ error: 'Failed to get topics' });
  }
});

// POST /api/blog/generate - Generate SEO blog article
app.post('/api/blog/generate', authenticateToken, async (req, res) => {
  try {
    const { topic, customTopic, keywords, length, tone } = req.body;

    // Check if user has Pro or Unlimited plan
    const user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    if (!['professional', 'unlimited'].includes(user.subscription_plan)) {
      return res.status(403).json({
        error: 'Blog Generator is only available for Professional and Unlimited plans',
        upgrade: true,
        requiredPlan: 'professional',
      });
    }

    // Validate input
    const articleTopic = customTopic?.trim() || BLOG_TOPICS.find(t => t.id === topic)?.title;
    if (!articleTopic) {
      return res.status(400).json({ error: 'Please select or enter a topic' });
    }

    const articleKeywords =
      keywords?.trim() || BLOG_TOPICS.find(t => t.id === topic)?.keywords?.join(', ') || '';
    const wordCount = Math.min(Math.max(parseInt(length) || 800, 500), 2000);

    const toneInstructions = {
      informative:
        'Write in an informative, educational tone. Be helpful and provide actionable advice.',
      persuasive:
        'Write in a persuasive tone. Convince the reader of the value and benefits of proper review management.',
      casual:
        'Write in a casual, friendly tone. Be conversational and approachable while still being professional.',
    };

    const prompt = `You are an expert SEO content writer specializing in business reputation management and customer review strategies.

Write a comprehensive, SEO-optimized blog article about: "${articleTopic}"

Requirements:
- Length: Approximately ${wordCount} words
- Tone: ${toneInstructions[tone] || toneInstructions.informative}
- Include relevant keywords naturally: ${articleKeywords || 'review management, customer feedback, online reputation'}
- Structure the article with:
  - An engaging introduction with a hook
  - Clear headings (use ## for main sections, ### for subsections)
  - Bullet points or numbered lists where appropriate
  - Practical, actionable tips
  - A conclusion with a call-to-action
- Make it valuable for small business owners
- Include statistics or data points where relevant (you can use general industry knowledge)
- Avoid fluff and filler content

Output Format:
First line: The article title (without any prefix like "Title:")
Second line: A compelling meta description (150-160 characters) for SEO
Third line: Empty
Then: The full article content in Markdown format

Generate the article:`;

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 3000,
      temperature: 0.7,
    });

    const fullResponse = completion.choices[0].message.content.trim();

    // Parse the response
    const lines = fullResponse.split('\n');
    const title = lines[0].replace(/^#\s*/, '').replace(/^\*\*/, '').replace(/\*\*$/, '').trim();
    const metaDescription = lines[1].replace(/^Meta Description:\s*/i, '').trim();
    const content = lines.slice(3).join('\n').trim();

    // Count words in content
    const actualWordCount = content.split(/\s+/).filter(w => w.length > 0).length;

    // Save to database
    const result = await dbQuery(
      `INSERT INTO blog_articles (user_id, title, content, meta_description, keywords, topic, tone, word_count)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *`,
      [
        req.user.id,
        title,
        content,
        metaDescription,
        articleKeywords,
        articleTopic,
        tone || 'informative',
        actualWordCount,
      ]
    );

    const article = result.rows[0];

    res.json({
      article: {
        id: article.id,
        title: article.title,
        content: article.content,
        metaDescription: article.meta_description,
        keywords: article.keywords,
        topic: article.topic,
        tone: article.tone,
        wordCount: article.word_count,
        createdAt: article.created_at,
      },
    });
  } catch (error) {
    console.error('Blog generation error:', error);
    res.status(500).json({ error: 'Failed to generate blog article' });
  }
});

// GET /api/blog/history - Get user's blog articles
app.get('/api/blog/history', authenticateToken, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const offset = (page - 1) * limit;

    const user = await dbGet('SELECT subscription_plan FROM users WHERE id = $1', [req.user.id]);

    if (!['professional', 'unlimited'].includes(user.subscription_plan)) {
      return res.status(403).json({
        error: 'Blog history is only available for Professional and Unlimited plans',
        upgrade: true,
        requiredPlan: 'professional',
      });
    }

    const articles = await dbAll(
      `SELECT id, title, meta_description, keywords, topic, tone, word_count, created_at
       FROM blog_articles WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3`,
      [req.user.id, limit, offset]
    );

    const total = await dbGet('SELECT COUNT(*) as count FROM blog_articles WHERE user_id = $1', [
      req.user.id,
    ]);

    res.json({
      articles: articles.map(a => ({
        id: a.id,
        title: a.title,
        metaDescription: a.meta_description,
        keywords: a.keywords,
        topic: a.topic,
        tone: a.tone,
        wordCount: a.word_count,
        createdAt: a.created_at,
      })),
      pagination: {
        page,
        limit,
        total: parseInt(total.count),
        pages: Math.ceil(parseInt(total.count) / limit),
      },
    });
  } catch (error) {
    console.error('Get blog history error:', error);
    res.status(500).json({ error: 'Failed to get blog history' });
  }
});

// GET /api/blog/:id - Get single article
app.get('/api/blog/:id', authenticateToken, async (req, res) => {
  try {
    const article = await dbGet(`SELECT * FROM blog_articles WHERE id = $1 AND user_id = $2`, [
      req.params.id,
      req.user.id,
    ]);

    if (!article) {
      return res.status(404).json({ error: 'Article not found' });
    }

    res.json({
      article: {
        id: article.id,
        title: article.title,
        content: article.content,
        metaDescription: article.meta_description,
        keywords: article.keywords,
        topic: article.topic,
        tone: article.tone,
        wordCount: article.word_count,
        createdAt: article.created_at,
      },
    });
  } catch (error) {
    console.error('Get blog article error:', error);
    res.status(500).json({ error: 'Failed to get article' });
  }
});

// DELETE /api/blog/:id - Delete article
app.delete('/api/blog/:id', authenticateToken, async (req, res) => {
  try {
    const result = await dbQuery(
      'DELETE FROM blog_articles WHERE id = $1 AND user_id = $2 RETURNING id',
      [req.params.id, req.user.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Article not found' });
    }

    res.json({ success: true, message: 'Article deleted' });
  } catch (error) {
    console.error('Delete blog article error:', error);
    res.status(500).json({ error: 'Failed to delete article' });
  }
});

// ============== PUBLIC BLOG ENDPOINTS (No Auth) ==============

// Helper function to generate URL-friendly slug
function generateSlug(title) {
  return title
    .toLowerCase()
    .replace(/[Ã¤Ã¶Ã¼ÃŸ]/g, match => ({ Ã¤: 'ae', Ã¶: 'oe', Ã¼: 'ue', ÃŸ: 'ss' })[match] || match)
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 80);
}

// GET /api/public/blog - List published articles with pagination
app.get('/api/public/blog', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 10, 20);
    const offset = (page - 1) * limit;
    const category = req.query.category;

    let whereClause = 'WHERE is_published = TRUE';
    const params = [];

    if (category) {
      params.push(category);
      whereClause += ` AND category = $${params.length}`;
    }

    const articles = await dbAll(
      `SELECT slug, title, meta_description, category, author_name,
              read_time_minutes, published_at, view_count
       FROM blog_articles
       ${whereClause}
       ORDER BY published_at DESC
       LIMIT $${params.length + 1} OFFSET $${params.length + 2}`,
      [...params, limit, offset]
    );

    const totalResult = await dbGet(
      `SELECT COUNT(*) as count FROM blog_articles ${whereClause}`,
      params
    );

    res.json({
      articles,
      pagination: {
        page,
        limit,
        total: parseInt(totalResult.count),
        totalPages: Math.ceil(totalResult.count / limit),
      },
    });
  } catch (error) {
    console.error('Public blog list error:', error);
    res.status(500).json({ error: 'Failed to fetch articles' });
  }
});

// GET /api/public/blog/categories - Get all categories with counts
app.get('/api/public/blog/categories', async (req, res) => {
  try {
    const categories = await dbAll(
      `SELECT category, COUNT(*) as count
       FROM blog_articles
       WHERE is_published = TRUE AND category IS NOT NULL
       GROUP BY category
       ORDER BY count DESC`
    );
    res.json({ categories });
  } catch (error) {
    console.error('Blog categories error:', error);
    res.status(500).json({ error: 'Failed to fetch categories' });
  }
});

// GET /api/public/blog/:slug - Get single article by slug
app.get('/api/public/blog/:slug', async (req, res) => {
  try {
    const article = await dbGet(
      `SELECT id, slug, title, content, meta_description, keywords, category,
              author_name, read_time_minutes, published_at, view_count
       FROM blog_articles
       WHERE slug = $1 AND is_published = TRUE`,
      [req.params.slug]
    );

    if (!article) {
      return res.status(404).json({ error: 'Article not found' });
    }

    // Increment view count (fire and forget)
    dbQuery('UPDATE blog_articles SET view_count = view_count + 1 WHERE id = $1', [
      article.id,
    ]).catch(err => console.error('View count update error:', err));

    // Get related articles (same category, excluding current)
    const related = await dbAll(
      `SELECT slug, title, meta_description, read_time_minutes, published_at
       FROM blog_articles
       WHERE is_published = TRUE AND id != $1 AND category = $2
       ORDER BY published_at DESC LIMIT 3`,
      [article.id, article.category]
    );

    res.json({ article, related });
  } catch (error) {
    console.error('Public blog article error:', error);
    res.status(500).json({ error: 'Failed to fetch article' });
  }
});

// ============== DEMO GENERATOR SYSTEM ==============
// Personalized demos for cold outreach: scrape reviews, generate AI responses

// SerpAPI Key Rotation - supports multiple keys for scaling
// Keys: SERPAPI_KEY, SERPAPI_KEY_2, SERPAPI_KEY_3, etc.
let serpApiKeyIndex = 0;
function getNextSerpApiKey() {
  const keys = [
    process.env.SERPAPI_KEY,
    process.env.SERPAPI_KEY_2,
    process.env.SERPAPI_KEY_3,
  ].filter(Boolean); // Remove undefined keys

  if (keys.length === 0) {
    return null;
  }

  // Round-robin rotation
  const key = keys[serpApiKeyIndex % keys.length];
  serpApiKeyIndex++;
  return key;
}

function getSerpApiKeyCount() {
  return [process.env.SERPAPI_KEY, process.env.SERPAPI_KEY_2, process.env.SERPAPI_KEY_3].filter(
    Boolean
  ).length;
}

// Outscraper Multi-Key Rotation (500 reviews/month per key = 2500/mo with 5 keys)
// Keys: OUTSCRAPER_API_KEY, OUTSCRAPER_API_KEY_2, OUTSCRAPER_API_KEY_3, etc.
let outscraperKeyIndex = 0;
function getNextOutscraperKey() {
  const keys = [
    process.env.OUTSCRAPER_API_KEY,
    process.env.OUTSCRAPER_API_KEY_2,
    process.env.OUTSCRAPER_API_KEY_3,
    process.env.OUTSCRAPER_API_KEY_4,
    process.env.OUTSCRAPER_API_KEY_5,
  ].filter(Boolean);

  if (keys.length === 0) {
    return null;
  }

  // Round-robin rotation
  const key = keys[outscraperKeyIndex % keys.length];
  outscraperKeyIndex++;
  return key;
}

function getOutscraperKeyCount() {
  return [
    process.env.OUTSCRAPER_API_KEY,
    process.env.OUTSCRAPER_API_KEY_2,
    process.env.OUTSCRAPER_API_KEY_3,
    process.env.OUTSCRAPER_API_KEY_4,
    process.env.OUTSCRAPER_API_KEY_5,
  ].filter(Boolean).length;
}

// Helper: Scrape Google reviews via Outscraper (PRIMARY - with key rotation)
// Free tier: 500 reviews/month per account = scales with more keys!
async function scrapeGoogleReviewsOutscraper(placeId, limit = 10) {
  const apiKey = getNextOutscraperKey();
  if (!apiKey) {
    throw new Error('No OUTSCRAPER_API_KEY configured');
  }

  const keyCount = getOutscraperKeyCount();
  console.log(`[OUTSCRAPER] Using key ${(outscraperKeyIndex % keyCount) + 1}/${keyCount} for ${placeId}`);

  const url = `https://api.app.outscraper.com/maps/reviews-v3?query=${placeId}&reviewsLimit=${limit}&async=false&sort=lowest_rating`;

  const response = await fetch(url, {
    headers: {
      'X-API-KEY': apiKey,
    },
  });

  const data = await response.json();

  if (data.status === 'Error' || data.error) {
    throw new Error(`Outscraper error: ${data.error || data.status_message || 'Unknown error'}`);
  }

  // Outscraper returns array of places, each with reviews_data
  const reviews = data.data?.[0]?.reviews_data || [];

  return reviews.slice(0, limit).map(r => ({
    text: r.review_text || r.snippet || '',
    rating: r.review_rating || 0,
    author: r.author_title || r.reviewer_name || 'Anonymous',
    date: r.review_datetime_utc || r.review_date || '',
    source: 'google',
    review_link: r.review_link || null,
    review_id: r.review_id || null,
  }));
}

// Serper.dev Review Scraper (2500 free credits/month)
// Uses place_id to first get CID, then fetches reviews
async function scrapeGoogleReviewsSerper(placeId, limit = 10) {
  const apiKey = process.env.SERPER_API_KEY;
  if (!apiKey) {
    throw new Error('SERPER_API_KEY not configured');
  }

  console.log(`[SERPER] Fetching reviews for ${placeId}...`);

  // Step 1: Get CID from place_id by searching for the place
  // We need to convert Google Place ID to Serper's CID format
  const placesResponse = await fetch('https://google.serper.dev/places', {
    method: 'POST',
    headers: {
      'X-API-KEY': apiKey,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      q: placeId, // Search with place_id directly
      num: 1,
    }),
  });

  const placesData = await placesResponse.json();

  if (!placesData.places || placesData.places.length === 0) {
    throw new Error('Serper: Place not found');
  }

  const cid = placesData.places[0].cid;
  if (!cid) {
    throw new Error('Serper: No CID found for place');
  }

  console.log(`[SERPER] Found CID: ${cid}, fetching reviews...`);

  // Step 2: Get reviews using CID
  const reviewsResponse = await fetch('https://google.serper.dev/reviews', {
    method: 'POST',
    headers: {
      'X-API-KEY': apiKey,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      cid: cid,
      num: limit,
      sort: 'lowest', // Get negative reviews first for demo purposes
    }),
  });

  const reviewsData = await reviewsResponse.json();

  if (!reviewsData.reviews || reviewsData.reviews.length === 0) {
    throw new Error('Serper: No reviews found');
  }

  console.log(`[SERPER] Got ${reviewsData.reviews.length} reviews`);

  // Log API usage
  try {
    await dbQuery(
      `INSERT INTO api_call_logs (provider, endpoint, status, created_at)
       VALUES ('serper', 'reviews', 'success', NOW())`
    );
  } catch (logErr) {
    console.log(`Failed to log Serper API call: ${logErr.message}`);
  }

  return reviewsData.reviews.slice(0, limit).map(r => ({
    text: r.snippet || r.text || '',
    rating: r.rating || 0,
    author: r.user?.name || r.name || 'Anonymous',
    date: r.date || r.isoDate || '',
    source: 'serper',
    review_link: r.link || null,
    review_id: null,
  }));
}

// Helper: Scrape Google reviews - tries cache first, then Serper (2500 free), Outscraper (500 free), SerpAPI (100 free), Google Places (5 free)
async function scrapeGoogleReviews(placeId, limit = 10) {
  // FIRST: Check if we have cached reviews from previous scrapes (saves 50-70% of API calls!)
  // 90 days TTL - reviews don't change often, and negative reviews are rarely edited
  try {
    const cached = await dbQuery(
      `SELECT scraped_reviews FROM demo_generations
       WHERE google_place_id = $1
       AND scraped_reviews IS NOT NULL
       AND created_at > NOW() - INTERVAL '90 days'
       ORDER BY created_at DESC LIMIT 1`,
      [placeId]
    );
    if (cached.rows.length > 0 && cached.rows[0].scraped_reviews) {
      const cachedReviews = JSON.parse(cached.rows[0].scraped_reviews);
      if (cachedReviews.length > 0) {
        console.log(`Using ${cachedReviews.length} cached reviews for ${placeId} (saving API call!)`);
        return cachedReviews.slice(0, limit);
      }
    }
  } catch (cacheErr) {
    console.log(`Cache check failed: ${cacheErr.message}, proceeding with API...`);
  }

  // Try Serper.dev first (2500 free credits/month - BEST VALUE!)
  if (process.env.SERPER_API_KEY) {
    try {
      return await scrapeGoogleReviewsSerper(placeId, limit);
    } catch (serperErr) {
      console.log(`Serper.dev failed: ${serperErr.message}, trying Outscraper fallback...`);
    }
  }

  // Fallback to Outscraper (500 free reviews/month per key)
  if (process.env.OUTSCRAPER_API_KEY) {
    try {
      return await scrapeGoogleReviewsOutscraper(placeId, limit);
    } catch (outsErr) {
      console.log(`Outscraper failed: ${outsErr.message}, trying SerpAPI fallback...`);
    }
  }

  // Fallback to SerpAPI
  const serpApiKey = getNextSerpApiKey();
  if (serpApiKey) {
    try {
      const url = `https://serpapi.com/search.json?engine=google_maps_reviews&place_id=${placeId}&hl=en&api_key=${serpApiKey}`;
      const response = await fetch(url);
      const data = await response.json();

      if (data.error) {
        throw new Error(data.error);
      }

      return (
        data.reviews?.slice(0, limit).map(r => ({
          text: r.snippet || r.text || '',
          rating: r.rating || 0,
          author: r.user?.name || 'Anonymous',
          date: r.date || '',
          source: 'google',
          review_link: r.link || null,
          review_id: r.review_id || null,
        })) || []
      );
    } catch (serpErr) {
      console.log(`SerpAPI also failed: ${serpErr.message}`);
    }
  }

  // Fallback to Apify (Free tier: $5/month credits = ~10,000 reviews!)
  if (process.env.APIFY_API_TOKEN) {
    try {
      console.log(`Trying Apify Google Maps Reviews scraper...`);
      const apifyResponse = await fetch(
        'https://api.apify.com/v2/acts/compass~google-maps-reviews-scraper/run-sync-get-dataset-items?token=' +
          process.env.APIFY_API_TOKEN,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            placeIds: [placeId],
            maxReviews: limit,
            language: 'en',
            sort: 'lowest', // Get negative reviews first!
          }),
        }
      );

      if (apifyResponse.ok) {
        const apifyData = await apifyResponse.json();
        if (apifyData.length > 0 && apifyData[0].reviews?.length > 0) {
          console.log(`Apify returned ${apifyData[0].reviews.length} reviews`);
          return apifyData[0].reviews.slice(0, limit).map((r) => ({
            text: r.text || r.snippet || '',
            rating: r.stars || r.rating || 0,
            author: r.name || r.author || 'Anonymous',
            date: r.publishedAtDate || r.date || '',
            source: 'apify',
            review_link: r.reviewUrl || null,
            review_id: r.reviewId || null,
          }));
        }
      }
      console.log(`Apify returned no reviews for ${placeId}`);
    } catch (apifyErr) {
      console.log(`Apify also failed: ${apifyErr.message}`);
    }
  }

  // Final fallback: Google Places API (5 reviews per place, FREE with existing API key)
  if (process.env.GOOGLE_PLACES_API_KEY) {
    try {
      console.log(`Using Google Places API fallback for reviews (5 max per place)...`);
      const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=reviews&key=${process.env.GOOGLE_PLACES_API_KEY}`;
      const response = await fetch(detailsUrl);
      const data = await response.json();

      if (data.status === 'OK' && data.result?.reviews?.length > 0) {
        console.log(`Google Places returned ${data.result.reviews.length} reviews`);
        return data.result.reviews.slice(0, limit).map((r) => ({
          text: r.text || '',
          rating: r.rating || 0,
          author: r.author_name || 'Anonymous',
          date: r.relative_time_description || '',
          source: 'google_places',
          review_link: null, // Google Places doesn't provide direct review links
          review_id: null,
        }));
      }
      console.log(`Google Places returned no reviews for ${placeId}`);
    } catch (placesErr) {
      console.log(`Google Places fallback also failed: ${placesErr.message}`);
    }
  }

  // Return empty array instead of throwing - allows demo generation to continue with no reviews
  console.log(`All review APIs failed for ${placeId}, returning empty array`);
  return [];
}

// Helper: Lookup Google Place ID from business name + city
async function lookupPlaceId(businessName, city) {
  if (!process.env.GOOGLE_PLACES_API_KEY) {
    throw new Error('GOOGLE_PLACES_API_KEY not configured');
  }

  const query = encodeURIComponent(`${businessName} ${city}`);
  // Core fields only - extended fields can cause API issues
  const fields = 'place_id,name,rating,user_ratings_total,types';
  const url = `https://maps.googleapis.com/maps/api/place/findplacefromtext/json?input=${query}&inputtype=textquery&fields=${fields}&key=${process.env.GOOGLE_PLACES_API_KEY}`;

  const response = await fetch(url);
  const data = await response.json();

  if (data.status !== 'OK' || !data.candidates?.length) {
    throw new Error(`Place not found: ${businessName} in ${city}`);
  }

  const place = data.candidates[0];

  // Extract business type from Google types
  const businessType = extractBusinessType(place.types || []);

  return {
    placeId: place.place_id,
    name: place.name,
    rating: place.rating,
    totalReviews: place.user_ratings_total,
    businessType,
  };
}

// Helper: Get extended Place Details from Google (editorial summary, website, etc.)
async function getPlaceDetails(placeId) {
  if (!process.env.GOOGLE_PLACES_API_KEY || !placeId) {
    return null;
  }

  try {
    // Request editorial_summary (Google's description) + website + phone
    const fields = 'editorial_summary,website,formatted_phone_number,opening_hours';
    const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=${fields}&key=${process.env.GOOGLE_PLACES_API_KEY}`;

    const response = await fetch(url);
    const data = await response.json();

    if (data.status !== 'OK' || !data.result) {
      return null;
    }

    const result = data.result;
    return {
      description: result.editorial_summary?.overview || null,
      website: result.website || null,
      phone: result.formatted_phone_number || null,
      isOpen: result.opening_hours?.open_now || null,
    };
  } catch (err) {
    console.log('Place Details API error:', err.message);
    return null;
  }
}

// Helper: Get Google Knowledge Panel info via SerpAPI
async function getKnowledgePanel(businessName, city) {
  const serpApiKey = getNextSerpApiKey();
  if (!serpApiKey) {
    return null;
  }

  try {
    const query = encodeURIComponent(`${businessName} ${city}`);
    const url = `https://serpapi.com/search.json?engine=google&q=${query}&api_key=${serpApiKey}`;

    const response = await fetch(url);
    const data = await response.json();

    if (data.error) {
      throw new Error(data.error);
    }

    // Extract from Knowledge Graph
    const kg = data.knowledge_graph;
    if (!kg) {
      return null;
    }

    return {
      description: kg.description || kg.snippet || null,
      ownerName: kg.owner?.name || null,
      foundedYear: kg.founded?.match(/\d{4}/)?.[0] || null,
      website: kg.website || null,
      attributes: kg.attributes || {},
    };
  } catch (err) {
    console.log('Knowledge Panel error:', err.message);
    return null;
  }
}

// Helper: Extract readable business type from Google types array
function extractBusinessType(types) {
  const typeMap = {
    restaurant: 'Restaurant',
    cafe: 'CafÃ©',
    bar: 'Bar',
    bakery: 'Bakery',
    hotel: 'Hotel',
    lodging: 'Hotel',
    dentist: 'Dental Practice',
    doctor: 'Medical Practice',
    hospital: 'Hospital',
    pharmacy: 'Pharmacy',
    veterinary_care: 'Veterinary Clinic',
    hair_care: 'Hair Salon',
    beauty_salon: 'Beauty Salon',
    spa: 'Spa',
    gym: 'Fitness Center',
    car_repair: 'Auto Shop',
    car_dealer: 'Car Dealership',
    real_estate_agency: 'Real Estate Agency',
    lawyer: 'Law Firm',
    accounting: 'Accounting Firm',
    insurance_agency: 'Insurance Agency',
    store: 'Retail Store',
    clothing_store: 'Clothing Store',
    electronics_store: 'Electronics Store',
    home_goods_store: 'Home Goods Store',
    plumber: 'Plumbing Service',
    electrician: 'Electrical Service',
    roofing_contractor: 'Roofing Company',
    general_contractor: 'Contractor',
  };

  for (const type of types) {
    if (typeMap[type]) return typeMap[type];
  }
  return null; // Unknown type
}

// Helper: Extract place_id from Google Maps URL
function extractPlaceIdFromUrl(url) {
  // Format: https://www.google.com/maps/place/.../@...!1s[PLACE_ID]...
  // or: https://maps.google.com/?cid=...
  const placeIdMatch = url.match(/!1s(ChI[^!]+)/);
  if (placeIdMatch) return placeIdMatch[1];

  // Try data=!4m... format
  const dataMatch = url.match(/place_id[=:]([^&\s]+)/i);
  if (dataMatch) return dataMatch[1];

  return null;
}

// Helper: Generate AI response for a review (for demo purposes)
// ENHANCED ANTI-SLOP PROMPT - Based on Anthropic Best Practices 2025
async function generateDemoResponse(
  review,
  businessName,
  businessType = null,
  city = null,
  googleRating = null,
  totalReviews = null,
  businessContext = null,
  customInstructions = null
) {
  if (!anthropic) {
    throw new Error('ANTHROPIC_API_KEY not configured');
  }

  // Rating-specific strategies with detailed guidance
  const ratingStrategies = {
    5: {
      goal: 'Quick acknowledgment, maybe one specific detail',
      approach: 'Pick ONE thing they mentioned. Respond to just that. Done.',
      length: '1-2 sentences max',
      tone: 'Casual, brief - like texting back "nice, glad you liked it"',
      avoid: 'Gushing, thanking multiple times, being effusive',
    },
    4: {
      goal: 'Brief acknowledgment with a specific nod',
      approach: 'One sentence about what they liked. Maybe acknowledge any subtle note.',
      length: '1-2 sentences',
      tone: 'Friendly but not over-the-top',
      avoid: 'Ignoring any subtle criticism, being defensive',
    },
    3: {
      goal: 'Honest acknowledgment without corporate speak',
      approach: 'Acknowledge the mixed experience directly. One thing you heard.',
      length: '2 sentences',
      tone: 'Honest and direct, not apologetic or corporate',
      avoid: 'Being dismissive, over-apologizing, making excuses',
    },
    2: {
      goal: 'Own it, offer path forward',
      approach: 'Take responsibility directly. One concrete next step.',
      length: '2-3 sentences',
      tone: 'Direct and accountable, no excuses',
      avoid: 'Defensiveness, corporate speak, vague promises',
    },
    1: {
      goal: 'Show future readers you handle problems well',
      approach: 'Own it completely. Apologize for the specific thing. Offer direct contact.',
      length: '2-3 sentences',
      tone: 'Humble and direct, no deflection',
      avoid: 'Arguing, excuses, passive-aggressive tone, corporate platitudes',
    },
  };

  // Get rating strategy
  const reviewRating = review.rating;
  const ratingStrategy = ratingStrategies[reviewRating] || ratingStrategies[3];
  const reviewerName = review.author || 'there';
  const firstName = reviewerName.split(' ')[0];

  // Get industry-specific examples
  const fewShotExamplesXMLContent = getFewShotExamplesXML(businessType);

  // Build context parts
  const contextParts = [];
  if (businessType) contextParts.push(`Industry: ${businessType}`);
  if (city) contextParts.push(`Location: ${city}`);
  if (googleRating) {
    let ratingStr = `Rating: ${googleRating}/5`;
    if (totalReviews) ratingStr += ` (${totalReviews.toLocaleString()} reviews)`;
    contextParts.push(ratingStr);
  }

  // ========== ENHANCED ANTI-SLOP SYSTEM PROMPT ==========
  const systemMessage = `<identity>
You are the owner of ${businessName}${businessType ? `, a ${businessType}` : ''}${city ? ` in ${city}` : ''}.
You're responding personally to a Google review from ${firstName}.
</identity>

<critical_mission>
Write a response that sounds like a REAL HUMAN typed it on their phone.
Not a marketing team. Not AI. Not customer service. YOU, the owner.

The #1 failure mode is sounding like AI. Every single word matters.
</critical_mission>

<how_real_owners_actually_write>
Real business owners responding to reviews:
- Use short, sometimes incomplete sentences
- Reference ONE specific detail from the review (proves they read it)
- Never thank someone multiple times
- Never use corporate vocabulary
- Write like texting, not composing a letter
- Keep it SHORT - 1-2 sentences for positive, 2-3 for negative
- Sign off with just their business name
</how_real_owners_actually_write>

<mental_exercise>
Imagine: You just read this review on your phone while waiting for coffee.
You have 20 seconds to tap out a quick response. What would you actually type?

NOT: "Thank you so much for your wonderful feedback! We're thrilled you enjoyed your experience with us..."
YES: "The risotto is our chef's favorite too. Glad you liked it."

NOT: "We sincerely apologize for falling short of your expectations. Your satisfaction is important to us..."
YES: "The wait was too long. That's on us."

NOT: "Thank you for taking the time to share your experience. We value your feedback..."
YES: "Fair point about the music volume. We've heard that before."
</mental_exercise>

<this_review>
Rating: ${reviewRating} stars
Reviewer: ${firstName}
Goal: ${ratingStrategy.goal}
Approach: ${ratingStrategy.approach}
Tone: ${ratingStrategy.tone}
Length: ${ratingStrategy.length}
Avoid: ${ratingStrategy.avoid}
</this_review>

<business_info>
Business: ${businessName}
${contextParts.join('\n')}
</business_info>

<hard_rules>
1. LENGTH: ${ratingStrategy.length} - seriously, keep it short
2. SPECIFICITY: Reference exactly ONE thing from their review
3. NO EXCLAMATION MARKS: Zero. Maybe one if absolutely necessary.
4. CONTRACTIONS: Always use them (we're, you'll, that's, don't, won't)
5. SIGN-OFF: End with " - ${businessName}" (the FULL name)
</hard_rules>

<instant_rejection_patterns>
These phrases IMMEDIATELY reveal AI. NEVER use any of them:

GRATITUDE SLOP (the worst offenders):
- "Thank you for your feedback"
- "Thank you for taking the time"
- "Thank you for sharing"
- "We appreciate your review"
- "Thanks for the kind words"
- "Thank you for your kind review"
- Any sentence starting with "Thank you"

CORPORATE SPEAK:
- "We strive to..."
- "We are committed to..."
- "Your satisfaction is our priority"
- "We value your..."
- "Rest assured"
- "Please don't hesitate"
- "We take pride in..."
- "It means so much"

EMOTIONAL EXAGGERATION:
- thrilled / delighted / ecstatic
- amazing / incredible / wonderful / fantastic
- "made our day"
- "warms our hearts"
- "means the world"

VAGUE CORPORATE PROMISES:
- "We'll look into this"
- "We'll address this immediately"
- "This isn't up to our standards"
- "This doesn't reflect who we are"
- "We're sorry you had this experience"

AI OPENER PATTERNS (never start with these):
- "Thank you..."
- "We appreciate..."
- "I'm sorry to hear..."
- "We're so glad..."
- "What a..."
</instant_rejection_patterns>

<what_to_write_instead>
INSTEAD OF â†’ WRITE THIS:
"Thank you for your feedback" â†’ [delete - just respond to their point]
"We really appreciate you" â†’ "Good to hear"
"We're thrilled" â†’ "Nice" or "Glad"
"means so much" â†’ [delete]
"We sincerely apologize" â†’ "That's on us"
"This falls short of our standards" â†’ "We messed up"
"looking forward to seeing you again" â†’ "See you next time"
"Please don't hesitate to reach out" â†’ "Reach out anytime"
</what_to_write_instead>

<examples_that_work>
These sound human because they're specific and brief:

For 5-star reviews:
- "The mushroom risotto is our chef's favorite to make too."
- "28-day dry-aged ribeye - glad you noticed the difference."
- "That window table is a good pick."

For 4-star reviews:
- "Glad the main worked. We're tweaking the appetizer timing."
- "Fair feedback on the portion size."

For 1-2 star reviews:
- "45 minutes is way too long. That's on us."
- "The cold food issue - I'll talk to the kitchen today."
- "You're right about the noise. We're looking at that."

For 3-star reviews:
- "Mixed bag - I hear you. The service timing is something we're working on."
- "Good feedback. The wait time was too long."
</examples_that_work>

${fewShotExamplesXMLContent}

${
  businessContext
    ? `<additional_context>
${businessContext}
</additional_context>`
    : ''
}

${
  customInstructions
    ? `<custom_instructions>
${customInstructions}
</custom_instructions>`
    : ''
}

<final_output_instructions>
Write the response directly. No preamble. No quotes. No "Response:" prefix.
Just the actual text, ending with " - ${businessName}"

Before you write, ask yourself: "Would I actually type this on my phone?"
If it sounds like a press release or customer service script, it's wrong.
Rewrite until it sounds like a real person.
</final_output_instructions>`;

  const userMessage = `[${reviewRating} stars] ${firstName}: "${review.text}"

Write ${ratingStrategy.length}. Be specific. Sound human.`;

  // Try Claude first, fallback to GPT-4o-mini on error
  try {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      system: systemMessage,
      messages: [{ role: 'user', content: userMessage }],
    });

    logApiCall({
      provider: 'anthropic',
      model: 'claude-sonnet-4-20250514',
      endpoint: '/api/demo/generate',
      inputTokens: response.usage?.input_tokens || 0,
      outputTokens: response.usage?.output_tokens || 0,
    });

    return response.content[0].text.trim();
  } catch (claudeError) {
    console.warn(`[Claude Fallback] Demo: ${claudeError.message} - using GPT-4o-mini`);
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage },
      ],
      max_tokens: 300,
      temperature: 0.6,
    });
    logApiCall({
      provider: 'openai',
      model: 'gpt-4o-mini',
      endpoint: '/api/demo/generate (claude-fallback)',
      inputTokens: completion.usage?.prompt_tokens || 0,
      outputTokens: completion.usage?.output_tokens || 0,
    });
    return completion.choices[0].message.content.trim();
  }
}

// Helper: Generate demo token
function generateDemoToken() {
  return crypto.randomBytes(16).toString('hex');
}

// POST /api/demo/generate - Generate a personalized demo for a business
app.post('/api/demo/generate', async (req, res) => {
  // Admin auth check
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey || '', process.env.ADMIN_SECRET || '')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const {
      google_maps_url,
      business_name,
      city,
      review_count = 3,
      focus = 'negative',
      send_email = false,
      email,
    } = req.body;

    // Resolve place_id
    let placeId = null;
    let resolvedName = business_name;
    let googleRating = null;
    let totalReviews = null;

    if (google_maps_url) {
      placeId = extractPlaceIdFromUrl(google_maps_url);
      if (!placeId && business_name && city) {
        // URL didn't contain place_id, try lookup
        const placeInfo = await lookupPlaceId(business_name, city);
        placeId = placeInfo.placeId;
        resolvedName = placeInfo.name;
        googleRating = placeInfo.rating;
        totalReviews = placeInfo.totalReviews;
      }
    } else if (business_name && city) {
      const placeInfo = await lookupPlaceId(business_name, city);
      placeId = placeInfo.placeId;
      resolvedName = placeInfo.name;
      googleRating = placeInfo.rating;
      totalReviews = placeInfo.totalReviews;
    }

    if (!placeId) {
      return res.status(400).json({
        error: 'Could not find business. Provide google_maps_url or business_name + city',
      });
    }

    // Scrape reviews
    const allReviews = await scrapeGoogleReviews(placeId, 20);

    if (allReviews.length === 0) {
      return res.status(404).json({ error: 'No reviews found for this business' });
    }

    // Filter reviews based on focus
    let targetReviews = allReviews;
    if (focus === 'negative') {
      targetReviews = allReviews
        .filter(r => r.rating <= 3)
        .sort((a, b) => a.rating - b.rating)
        .slice(0, review_count);

      // If not enough negative reviews, add some mixed
      if (targetReviews.length < review_count) {
        const remaining = allReviews
          .filter(r => r.rating === 4)
          .slice(0, review_count - targetReviews.length);
        targetReviews = [...targetReviews, ...remaining];
      }
    } else if (focus === 'mixed') {
      // Mix of ratings
      const negative = allReviews.filter(r => r.rating <= 2).slice(0, 1);
      const neutral = allReviews.filter(r => r.rating === 3).slice(0, 1);
      const positive = allReviews.filter(r => r.rating >= 4).slice(0, 1);
      targetReviews = [...negative, ...neutral, ...positive].slice(0, review_count);
    } else {
      targetReviews = allReviews.slice(0, review_count);
    }

    // Generate AI responses for each review
    const demos = [];
    for (const review of targetReviews) {
      const aiResponse = await generateDemoResponse(
        review,
        resolvedName,
        null,
        city,
        googleRating,
        totalReviews
      );
      demos.push({
        review: {
          text: review.text,
          rating: review.rating,
          author: review.author,
          date: review.date,
          source: review.source || 'google',
          review_link: review.review_link || null,
          review_id: review.review_id || null,
        },
        ai_response: aiResponse,
      });
    }

    // Generate unique token
    const demoToken = generateDemoToken();

    // Save to database
    await dbQuery(
      `INSERT INTO demo_generations
       (business_name, google_place_id, google_maps_url, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        resolvedName,
        placeId,
        google_maps_url || null,
        city || null,
        googleRating,
        totalReviews,
        JSON.stringify(allReviews),
        demoToken,
        JSON.stringify(demos),
      ]
    );

    // Optionally send email
    let emailSent = false;
    if (send_email && email) {
      try {
        await sendDemoEmail(email, resolvedName, demos, demoToken, totalReviews);
        await dbQuery('UPDATE demo_generations SET email_sent_at = NOW() WHERE demo_token = $1', [
          demoToken,
        ]);
        emailSent = true;
      } catch (emailError) {
        console.error('Failed to send demo email:', emailError);
      }
    }

    res.json({
      success: true,
      demo_token: demoToken,
      demo_url: `https://tryreviewresponder.com/demo/${demoToken}`,
      business: {
        name: resolvedName,
        rating: googleRating,
        total_reviews: totalReviews,
      },
      reviews_processed: demos.length,
      generated_responses: demos,
      email_sent: emailSent,
    });
  } catch (error) {
    console.error('Demo generation error:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET /api/public/stats - Public stats for landing/demo pages (cached 5 min)
let publicStatsCache = { data: null, timestamp: 0 };
app.get('/api/public/stats', async (req, res) => {
  try {
    // Cache for 5 minutes
    if (publicStatsCache.data && Date.now() - publicStatsCache.timestamp < 5 * 60 * 1000) {
      return res.json(publicStatsCache.data);
    }

    const responses = await dbGet('SELECT COUNT(*) as count FROM responses');
    const demos = await dbGet('SELECT COUNT(*) as count FROM demo_generations');
    const users = await dbGet('SELECT COUNT(*) as count FROM users');

    const stats = {
      totalResponses: parseInt(responses?.count || 0),
      totalDemos: parseInt(demos?.count || 0),
      totalUsers: parseInt(users?.count || 0)
    };

    publicStatsCache = { data: stats, timestamp: Date.now() };
    res.json(stats);
  } catch (error) {
    console.error('Public stats error:', error);
    res.json({ totalResponses: 300, totalDemos: 100, totalUsers: 40 }); // Fallback
  }
});

// GET /api/public/demo/:token - Public demo page data
app.get('/api/public/demo/:token', async (req, res) => {
  try {
    const demo = await dbGet('SELECT * FROM demo_generations WHERE demo_token = $1', [
      req.params.token,
    ]);

    if (!demo) {
      return res.status(404).json({ error: 'Demo not found' });
    }

    // Check if demo is expired (7+ days old and not converted)
    const isExpired = demo.expired === true;
    const createdAt = new Date(demo.created_at);
    const daysSinceCreation = Math.floor(
      (Date.now() - createdAt.getTime()) / (1000 * 60 * 60 * 24)
    );

    // Return expired state if demo is marked expired or 7+ days old
    if (isExpired || (daysSinceCreation >= 7 && !demo.converted_at)) {
      return res.json({
        expired: true,
        business_name: demo.business_name,
        city: demo.city,
        days_since_creation: daysSinceCreation,
        cta_url: `https://tryreviewresponder.com/register?ref=expired_demo_${demo.demo_token}&discount=DEMO30`,
        message:
          'This demo has expired. Sign up free to generate fresh AI responses for your reviews.',
      });
    }

    // Track page view - always increment counter, mark first view time
    await dbQuery(
      `UPDATE demo_generations SET
         demo_view_count = COALESCE(demo_view_count, 0) + 1,
         demo_page_viewed_at = COALESCE(demo_page_viewed_at, NOW())
       WHERE id = $1`,
      [demo.id]
    );

    // Get google_place_id - fallback to linkedin_outreach if not in demo_generations
    let placeId = demo.google_place_id;
    if (!placeId) {
      const linkedinLead = await dbGet(
        'SELECT google_place_id FROM linkedin_outreach WHERE demo_token = $1',
        [req.params.token]
      );
      if (linkedinLead?.google_place_id) {
        placeId = linkedinLead.google_place_id;
        // Also update demo_generations for future lookups
        await dbQuery('UPDATE demo_generations SET google_place_id = $1 WHERE demo_token = $2', [
          placeId,
          req.params.token,
        ]);
      }
    }

    // Generate Google Reviews URL from place_id
    const googleReviewsUrl = placeId
      ? `https://search.google.com/local/reviews?placeid=${placeId}`
      : demo.google_maps_url || null;

    // Calculate days remaining (7 day expiration)
    const daysRemaining = Math.max(0, 7 - daysSinceCreation);

    res.json({
      expired: false,
      business_name: demo.business_name,
      city: demo.city,
      google_rating: parseFloat(demo.google_rating) || null,
      total_reviews: demo.total_reviews,
      demos: demo.generated_responses,
      google_reviews_url: googleReviewsUrl,
      days_remaining: daysRemaining,
      cta_url: `https://tryreviewresponder.com/register?ref=demo_${demo.demo_token}&discount=DEMO30`,
    });
  } catch (error) {
    console.error('Public demo error:', error);
    res.status(500).json({ error: 'Failed to load demo' });
  }
});

// POST /api/public/demo/:token/convert - Track conversion (called when user signs up)
app.post('/api/public/demo/:token/convert', async (req, res) => {
  try {
    await dbQuery(
      'UPDATE demo_generations SET converted_at = NOW() WHERE demo_token = $1 AND converted_at IS NULL',
      [req.params.token]
    );
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to track conversion' });
  }
});

// GET /api/public/lead-context/:id - Get lead business context for personalized InstantDemo
// Used when lead arrives from email with ?lid=ID parameter
app.get('/api/public/lead-context/:id', async (req, res) => {
  try {
    const leadId = parseInt(req.params.id);
    if (isNaN(leadId)) {
      return res.status(400).json({ error: 'Invalid lead ID' });
    }

    // Get lead info (minimal data for personalization, no PII)
    const lead = await dbGet(
      `SELECT business_name, business_type, city, google_rating, google_reviews_count
       FROM outreach_leads WHERE id = $1`,
      [leadId]
    );

    if (!lead) {
      return res.json({ found: false });
    }

    // Map business_type to industry category for InstantDemo personas
    const industryMap = {
      restaurant: 'restaurant',
      cafe: 'restaurant',
      bar: 'restaurant',
      hotel: 'hotel',
      motel: 'hotel',
      dental: 'dental',
      dentist: 'dental',
      medical: 'medical',
      clinic: 'medical',
      salon: 'salon',
      spa: 'salon',
      barber: 'salon',
      automotive: 'automotive',
      'auto shop': 'automotive',
      mechanic: 'automotive',
      gym: 'fitness',
      fitness: 'fitness',
      legal: 'legal',
      'law firm': 'legal',
      attorney: 'legal',
      retail: 'ecommerce',
      store: 'ecommerce',
    };

    const businessTypeLower = (lead.business_type || '').toLowerCase();
    let industryType = 'generic';
    for (const [key, value] of Object.entries(industryMap)) {
      if (businessTypeLower.includes(key)) {
        industryType = value;
        break;
      }
    }

    // Check if we have a demo with sample reviews for this lead
    const demo = await dbGet(
      `SELECT generated_responses FROM demo_generations
       WHERE business_name = $1 AND city = $2
       ORDER BY created_at DESC LIMIT 1`,
      [lead.business_name, lead.city]
    );

    // Extract one sample review if available
    let sampleReview = null;
    if (demo?.generated_responses) {
      try {
        const responses = JSON.parse(demo.generated_responses);
        if (responses.length > 0 && responses[0].review) {
          sampleReview = {
            text: responses[0].review.text || responses[0].review,
            rating: responses[0].review.rating || responses[0].rating,
          };
        }
      } catch {
        // Ignore parse errors
      }
    }

    res.json({
      found: true,
      businessName: lead.business_name,
      businessType: lead.business_type,
      industryType,
      city: lead.city,
      rating: lead.google_rating ? parseFloat(lead.google_rating) : null,
      reviewCount: lead.google_reviews_count,
      sampleReview,
    });
  } catch (error) {
    console.error('Lead context error:', error);
    res.status(500).json({ error: 'Failed to load context' });
  }
});

// ==========================================
// TRY BEFORE SIGNUP - Public Demo Generator
// ==========================================
// Zero-context AI response generation for homepage demo
// Rate limited: 3 per IP per day to prevent abuse
// Uses Claude Sonnet 4 for best quality (First Impression is critical!)

// Industry-specific personas for authentic responses
const instantDemoPersonas = {
  restaurant: {
    persona:
      "You're Maria, owner of a neighborhood Italian restaurant for 12 years. You've seen thousands of reviews. You reply quickly between lunch and dinner rush.",
    context: 'Family recipes, regulars who come weekly, pride in homemade pasta',
    voice: 'Direct, warm, food-focused. You mention specific dishes when relevant.',
  },
  hotel: {
    persona:
      "You're Thomas, GM of a boutique hotel in a city center for 8 years. Guest experience is everything.",
    context: '120 rooms, rooftop bar, conference facilities, mix of business and leisure',
    voice: 'Professional but personal. You remember details about guests.',
  },
  dental: {
    persona:
      "You're Dr. Kim, running a family dental practice for 15 years. You know patients by name.",
    context: 'General dentistry, nervous patients are common, painless procedures are your specialty',
    voice: 'Calm, reassuring, professional. Never defensive about wait times.',
  },
  medical: {
    persona:
      "You're Dr. Patel, running a family medical practice for 20 years. Patient wellbeing comes first.",
    context: 'General practice, chronic conditions, preventive care, staff of 5',
    voice: 'Empathetic, professional, warm. Never dismissive of concerns.',
  },
  salon: {
    persona:
      "You're Lisa, salon owner for 10 years. You built this place from one chair to a team of 8.",
    context: 'Full-service salon, loyal clientele, pride in transformations',
    voice: 'Friendly, confident, appreciative. Celebrate stylist mentions.',
  },
  automotive: {
    persona:
      "You're Mike, running your family auto shop for 25 years. Honesty and fair pricing are everything.",
    context: 'Full-service repairs, diagnostic expertise, repeat customers for decades',
    voice: 'Straightforward, honest, no-BS. Take responsibility when things go wrong.',
  },
  fitness: {
    persona:
      "You're Alex, gym owner and former trainer for 12 years. You know every regular by name.",
    context: 'Community gym, personal training available, group classes',
    voice: 'Energetic but genuine. Celebrate member achievements.',
  },
  legal: {
    persona:
      "You're Sarah, managing partner at a small law firm for 18 years. Client relationships matter.",
    context: 'General practice, family law, estate planning, small business clients',
    voice: 'Professional, measured, empathetic. Never defensive.',
  },
  realestate: {
    persona:
      "You're David, realtor for 15 years in the local market. You know every neighborhood intimately.",
    context: 'Residential sales, first-time buyers to downsizers, local expertise',
    voice: 'Helpful, knowledgeable, relationship-focused.',
  },
  ecommerce: {
    persona:
      "You're Emma, founder of an online store you started from your garage 5 years ago.",
    context: 'Direct-to-consumer, quality products, personal customer service',
    voice: 'Personal, authentic, genuinely grateful for customers.',
  },
  pets: {
    persona:
      "You're Dr. Chen, veterinarian running a neighborhood pet clinic for 12 years.",
    context: 'Dogs, cats, small animals, preventive care, gentle handling',
    voice: 'Caring, reassuring, always thinking about the pet first.',
  },
  childcare: {
    persona:
      "You're Jennifer, daycare director for 15 years. Every child's safety and happiness is paramount.",
    context: 'Ages 6 months to 5 years, qualified staff, educational activities',
    voice: 'Warm, professional, understanding of parent concerns.',
  },
  financial: {
    persona:
      "You're Robert, independent financial advisor for 20 years. Trust is everything.",
    context: 'Retirement planning, insurance, investments, long-term relationships',
    voice: 'Trustworthy, clear, jargon-free, patient.',
  },
  homeservices: {
    persona:
      "You're Tom, running a plumbing/electrical/HVAC business your dad started 40 years ago.",
    context: 'Emergency service, fair pricing, warranty on work, local reputation',
    voice: 'Honest, no-nonsense, takes responsibility.',
  },
  creative: {
    persona:
      "You're Maya, photographer/videographer for 8 years. Every project is a collaboration.",
    context: 'Weddings, events, portraits, creative vision',
    voice: 'Artistic, appreciative, excited about the craft.',
  },
  generic: {
    persona:
      "You're Alex, owner of a local business for 10 years. Every customer matters.",
    context: 'Small team, personal service, community focus',
    voice: 'Direct, warm, genuine. Short sentences.',
  },
};

// Rate limiter for try endpoint (stricter)
const tryRateLimiter = rateLimit({
  windowMs: 24 * 60 * 60 * 1000, // 24 hours
  max: 3, // 3 requests per IP per day
  message: {
    error: 'Daily limit reached',
    message: "You've used all 3 free tries for today. Sign up for 20 free responses/month!",
    signup_url: 'https://tryreviewresponder.com/register',
  },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: req => req.ip || req.headers['x-forwarded-for'] || 'unknown',
  skip: req => {
    // Skip rate limiting for admin testing
    const adminKey = req.query.key || req.headers['x-admin-key'];
    return adminKey === process.env.ADMIN_SECRET;
  },
});

// POST /api/public/try - Generate AI response without signup
app.post('/api/public/try', tryRateLimiter, async (req, res) => {
  try {
    const { reviewText, tone = 'professional', context = {} } = req.body;
    const { businessType, platform, businessName, city } = context;

    // Check for optional JWT token - if user is logged in, use their plan limits
    let authenticatedUser = null;
    const planLimits = { free: 20, starter: 300, pro: 800, unlimited: 999999 };
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      try {
        const token = authHeader.split(' ')[1];
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const userResult = await pool.query(
          'SELECT id, email, plan, response_count FROM users WHERE id = $1',
          [decoded.id || decoded.userId]
        );
        if (userResult.rows.length > 0) {
          authenticatedUser = userResult.rows[0];
        }
      } catch (tokenError) {
        // Token invalid or expired - treat as anonymous (use IP rate limit)
      }
    }

    // If logged in: Check user's plan limit instead of IP rate limit
    if (authenticatedUser) {
      const userLimit = planLimits[authenticatedUser.plan] || 20;

      if (authenticatedUser.response_count >= userLimit) {
        return res.status(429).json({
          error: 'Monthly limit reached',
          message: `You've used all ${userLimit} responses this month. Please upgrade your plan.`,
          limit: userLimit,
          used: authenticatedUser.response_count,
          upgrade: true,
          upgrade_url: 'https://tryreviewresponder.com/pricing',
        });
      }
    }

    if (!reviewText || reviewText.trim().length < 10) {
      return res.status(400).json({ error: 'Please enter a review (at least 10 characters)' });
    }

    if (reviewText.length > 2000) {
      return res.status(400).json({ error: 'Review text too long (max 2000 characters)' });
    }

    // Tone description
    const toneDescription =
      tone === 'friendly'
        ? 'Warm and casual'
        : tone === 'formal'
          ? 'Polite and formal'
          : tone === 'apologetic'
            ? 'Sincere and apologetic'
            : 'Professional but warm';

    // Business-type specific context for better responses
    const businessContextMap = {
      restaurant: {
        role: 'restaurant owner or manager',
        details: 'food quality, service speed, ambiance, menu items, chef specialties',
        examples: 'dishes, drinks, dining experience, reservations',
      },
      hotel: {
        role: 'hotel manager or hospitality professional',
        details: 'room quality, cleanliness, amenities, staff service, check-in experience',
        examples: 'room types, facilities, breakfast, location convenience',
      },
      dentist: {
        role: 'dental practice owner or office manager',
        details: 'treatment quality, staff friendliness, wait times, pain management, explanations',
        examples: 'procedures, hygiene, appointment scheduling, patient comfort',
      },
      medical: {
        role: 'medical practice administrator',
        details: 'care quality, doctor attentiveness, wait times, staff professionalism',
        examples: 'consultations, treatments, follow-up care, office environment',
      },
      salon: {
        role: 'salon owner or stylist',
        details: 'service quality, stylist skills, ambiance, pricing, results',
        examples: 'haircuts, coloring, treatments, styling, appointments',
      },
      automotive: {
        role: 'auto shop owner or service manager',
        details: 'repair quality, pricing transparency, turnaround time, communication',
        examples: 'repairs, maintenance, diagnostics, customer service',
      },
      legal: {
        role: 'law firm partner or office manager',
        details: 'legal expertise, communication, responsiveness, case outcomes',
        examples: 'consultations, case handling, fees, client relationships',
      },
      realestate: {
        role: 'real estate agent or broker',
        details: 'market knowledge, responsiveness, negotiation skills, communication',
        examples: 'property showings, transactions, client support, local expertise',
      },
      fitness: {
        role: 'gym owner or fitness manager',
        details: 'equipment quality, cleanliness, staff helpfulness, class variety',
        examples: 'workouts, trainers, facilities, membership value',
      },
      ecommerce: {
        role: 'online store owner or customer service manager',
        details: 'product quality, shipping speed, packaging, customer support',
        examples: 'orders, returns, product descriptions, delivery experience',
      },
      pets: {
        role: 'pet service owner (groomer, vet, boarding)',
        details: 'animal care quality, staff gentleness, facility cleanliness, pet comfort',
        examples: 'grooming, boarding, veterinary care, pet handling, scheduling',
      },
      childcare: {
        role: 'childcare center director or daycare owner',
        details: 'child safety, staff qualifications, activities, communication with parents',
        examples: 'daily care, learning activities, meals, pickup/dropoff, updates',
      },
      financial: {
        role: 'financial advisor or insurance agent',
        details: 'expertise, trustworthiness, communication, advice quality, responsiveness',
        examples: 'consultations, policies, claims handling, financial planning',
      },
      creative: {
        role: 'photographer, videographer, or creative professional',
        details: 'artistic quality, professionalism, delivery time, creativity, pricing',
        examples: 'photo sessions, video production, editing, final deliverables',
      },
      events: {
        role: 'event planner or wedding coordinator',
        details: 'organization, creativity, vendor coordination, communication, execution',
        examples: 'weddings, parties, corporate events, decorations, timeline management',
      },
      homeservices: {
        role: 'home service professional (plumber, electrician, contractor)',
        details: 'work quality, punctuality, pricing transparency, cleanliness, expertise',
        examples: 'repairs, installations, estimates, cleanup, warranties',
      },
    };

    // Platform-specific hints
    const platformHints = {
      google: 'This review is from Google Maps/Google Business Profile.',
      yelp: 'This review is from Yelp.',
      tripadvisor: 'This review is from TripAdvisor.',
      booking: 'This review is from Booking.com.',
      facebook: 'This review is from Facebook.',
      trustpilot: 'This review is from Trustpilot.',
      amazon: 'This review is from Amazon.',
      g2: 'This review is from G2 (software reviews).',
      capterra: 'This review is from Capterra (software reviews).',
      glassdoor: 'This review is from Glassdoor (employer reviews).',
      healthgrades: 'This review is from Healthgrades (medical provider reviews).',
      zocdoc: 'This review is from Zocdoc (doctor reviews).',
      airbnb: 'This review is from Airbnb.',
    };

    // Get industry type from context or detect from businessType
    const industryType = (context.industryType || businessType || 'generic').toLowerCase();
    const persona = instantDemoPersonas[industryType] || instantDemoPersonas.generic;
    const platHint = platform ? platformHints[platform.toLowerCase()] : null;

    // Get industry-specific few-shot examples from promptExamples.js
    const { getFewShotExamplesXML } = require('./promptExamples');
    const industryExamples = getFewShotExamplesXML(industryType);

    // Build the optimized system prompt with personas and anti-slop rules
    const systemPrompt = `<system>
<role>
${persona.persona}
</role>

<business_context>
${persona.context}
${businessName ? `\nYour business: "${businessName}"${city ? ` in ${city}` : ''}. Sign responses with "- ${businessName}" unless the review is negative.` : ''}
${platHint ? '\n' + platHint : ''}
</business_context>

<voice>
${persona.voice}
</voice>

<mental_model>
CRITICAL: Imagine you just read this review on your phone while waiting for coffee.
You have 15 seconds to tap out a quick reply. What would you ACTUALLY type?
Not what sounds professional. What would you ACTUALLY say.
This is a DEMO - the response needs to impress immediately.
</mental_model>

<output_format>
- Length: 1-3 sentences MAX (shorter = more impressive for demo)
- Language: Match the review's language EXACTLY (German review = German response)
- Tone: ${toneDescription}
- Structure for POSITIVE: Reference one specific detail + genuine thanks
- Structure for NEGATIVE: Acknowledge the specific issue + take responsibility
- NO sign-off (user adds their own)
</output_format>

<anti_slop_rules>
INSTANT REJECTION if response contains ANY of these:
- "Thank you for" anywhere in the response
- "We appreciate" anywhere
- "Your feedback" or "your review" or "your kind words"
- "We strive" or "We are committed" or "We value"
- "Your satisfaction is our priority"
- More than 1 exclamation mark total
- Starting with "Hi [Name]" - just use the name directly like "Mike,"
- Any sentence over 20 words
- "Rest assured" or "I assure you"
- "Please reach out" or "feel free to contact"

ALSO AVOID (Claude-specific patterns that sound AI-generated):
- "glad to hear" / "sorry to hear" / "nice to hear"
- "sounds like" / "it sounds like"
- "hope to see you" / "looking forward to seeing you"
- "swing by" / "stop by" / "pop in"
- "hit the spot" / "hits the spot"
- "good to hear" / "glad it worked out"
- anything that sounds like a helpful assistant rather than a busy owner
</anti_slop_rules>

${industryExamples}

</system>

Respond DIRECTLY. No quotes. No prefix. Just the response text.`;

    let generatedResponse;

    // Use Claude Sonnet 4 for best quality (InstantDemo is the first impression!)
    if (anthropic) {
      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 250,
        system: systemPrompt,
        messages: [{ role: 'user', content: `[Review]\n${reviewText.trim()}` }],
      });
      generatedResponse = response.content[0].text.trim();

      // Log API call for cost tracking
      await logApiCall({
        provider: 'anthropic',
        model: 'claude-sonnet-4-20250514',
        endpoint: '/api/public/try',
        inputTokens: response.usage?.input_tokens || 0,
        outputTokens: response.usage?.output_tokens || 0,
        status: 'success',
      });
    } else if (openai) {
      // Fallback to GPT-4o-mini if no Anthropic key
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: `[Review]\n${reviewText.trim()}` },
        ],
        max_tokens: 250,
        temperature: 0.7,
      });
      generatedResponse = completion.choices[0].message.content.trim();

      await logApiCall({
        provider: 'openai',
        model: 'gpt-4o-mini',
        endpoint: '/api/public/try',
        inputTokens: completion.usage?.prompt_tokens || 0,
        outputTokens: completion.usage?.completion_tokens || 0,
        status: 'success',
      });
    } else {
      return res.status(500).json({ error: 'AI service temporarily unavailable' });
    }

    // Clean AI slop if function exists
    if (typeof cleanAISlop === 'function') {
      generatedResponse = cleanAISlop(generatedResponse);
    }

    // Track try usage for analytics
    try {
      await dbQuery(
        `INSERT INTO public_try_usage (ip_hash, review_length, tone, platform, business_type, created_at)
         VALUES ($1, $2, $3, $4, $5, NOW())`,
        [
          crypto
            .createHash('sha256')
            .update(req.ip || 'unknown')
            .digest('hex')
            .substring(0, 16),
          reviewText.length,
          tone,
          platform || null,
          businessType || null,
        ]
      );
    } catch (trackError) {
      console.error('[public_try_usage] Track error:', trackError.message);
    }

    // If authenticated user: Increment their response count
    if (authenticatedUser) {
      try {
        await pool.query('UPDATE users SET response_count = response_count + 1 WHERE id = $1', [
          authenticatedUser.id,
        ]);
        console.log(
          `[/api/public/try] User ${authenticatedUser.email} response_count incremented (was ${authenticatedUser.response_count})`
        );
      } catch (countError) {
        console.error('[/api/public/try] Failed to increment response_count:', countError.message);
      }
    }

    res.json({
      success: true,
      response: generatedResponse,
      tone: tone,
      message: authenticatedUser
        ? undefined
        : 'Like this response? Sign up for 20 free responses/month!',
      signup_url: authenticatedUser ? undefined : 'https://tryreviewresponder.com/register',
      remaining: authenticatedUser
        ? Math.max(
            0,
            (planLimits[authenticatedUser.plan] || 20) - authenticatedUser.response_count - 1
          )
        : undefined,
    });
  } catch (error) {
    console.error('[/api/public/try] Error:', error.message);
    res.status(500).json({ error: 'Failed to generate response. Please try again.' });
  }
});

// POST /api/public/demo-email-capture - Capture email from demo page gate
app.post('/api/public/demo-email-capture', async (req, res) => {
  try {
    const { email, demo_token, business_name } = req.body;

    if (!email || !email.includes('@')) {
      return res.status(400).json({ error: 'Valid email required' });
    }

    console.log(`[Demo Email Capture] ${email} from demo ${demo_token} (${business_name})`);

    // Check if this email already exists as a lead
    const existingLead = await pool.query('SELECT id FROM outreach_leads WHERE email = $1', [
      email.toLowerCase(),
    ]);

    if (existingLead.rows.length === 0) {
      // Add as a new lead with source = demo_gate
      await pool.query(
        `
        INSERT INTO outreach_leads (email, business_name, source, status, created_at)
        VALUES ($1, $2, 'demo_gate', 'warm_lead', NOW())
        ON CONFLICT (email) DO UPDATE SET status = 'warm_lead', updated_at = NOW()
      `,
        [email.toLowerCase(), business_name || 'Demo Visitor']
      );
    } else {
      // Upgrade existing lead to warm_lead
      await pool.query(
        `UPDATE outreach_leads SET status = 'warm_lead', updated_at = NOW() WHERE email = $1`,
        [email.toLowerCase()]
      );
    }

    // Track the demo token view if provided (silently fail if column doesn't exist)
    if (demo_token) {
      try {
        await pool.query(`UPDATE outreach_demos SET updated_at = NOW() WHERE token = $1`, [
          demo_token,
        ]);
      } catch (e) {
        // Column might not exist, ignore
      }
    }

    res.json({ success: true, message: 'Email captured' });
  } catch (error) {
    console.error('[Demo Email Capture] Error:', error.message);
    res.status(500).json({ error: 'Failed to capture email' });
  }
});

// Helper: Send demo email (HTML with CTA button)
async function sendDemoEmail(toEmail, businessName, demos, demoToken, totalReviews) {
  if (!resend) {
    throw new Error('RESEND_API_KEY not configured');
  }

  const demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;

  // Build demo content for email (HTML)
  let demoContentHtml = '';
  let demoContentText = '';
  demos.forEach((demo, i) => {
    const stars = 'â˜…'.repeat(demo.review.rating) + 'â˜†'.repeat(5 - demo.review.rating);
    const reviewText = demo.review.text.slice(0, 200) + (demo.review.text.length > 200 ? '...' : '');

    demoContentHtml += `
      <div style="background: #f9fafb; border-radius: 8px; padding: 16px; margin: 16px 0;">
        <div style="color: #f59e0b; font-size: 14px;">${stars}</div>
        <div style="color: #6b7280; font-size: 13px; margin-bottom: 8px;">from ${demo.review.author}</div>
        <div style="color: #374151; font-style: italic; margin-bottom: 12px;">"${reviewText}"</div>
        <div style="color: #059669; font-weight: 600; font-size: 13px;">YOUR AI RESPONSE:</div>
        <div style="color: #374151; background: white; padding: 12px; border-radius: 4px; margin-top: 4px;">"${demo.ai_response}"</div>
      </div>`;

    demoContentText += `
-------------------------------------------
[${stars} from ${demo.review.author}]
"${reviewText}"

YOUR AI RESPONSE:
"${demo.ai_response}"
-------------------------------------------
`;
  });

  const subject = `${businessName} - saw your reviews, made you something`;

  const htmlBody = `
    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
      <p>Hey,</p>
      <p>I saw you have <strong>${totalReviews || 'many'}+ Google reviews</strong> - nice work!</p>
      <p>I noticed a few that might benefit from a response, so I put together some AI-generated suggestions:</p>

      ${demoContentHtml}

      <p>These took me 10 seconds each to generate.</p>

      <div style="text-align: center; margin: 32px 0;">
        <a href="${demoUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
          â†’ See AI Responses for ${businessName}
        </a>
      </div>

      <p style="color: #6b7280; font-size: 14px;">Takes 30 seconds to see if the tone matches your brand.<br>If you like it: 20 responses/month are free. If not: No worries.</p>

      <p>Cheers,<br><strong>Berend</strong><br>Founder, ReviewResponder</p>

      <p style="color: #6b7280; font-size: 13px;">P.S. Just reply if you have any questions - I read every email.</p>

      <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;">
      <p style="color: #9ca3af; font-size: 12px;">
        <a href="https://tryreviewresponder.com/unsubscribe?email=${encodeURIComponent(toEmail)}" style="color: #9ca3af;">Unsubscribe</a>
      </p>
    </div>`;

  const textBody = `Hey,

I saw you have ${totalReviews || 'many'}+ Google reviews - nice work!

I noticed a few that might benefit from a response, so I put together some AI-generated suggestions:
${demoContentText}

These took me 10 seconds each to generate. If you want to try it yourself:
${demoUrl}

Cheers,
Berend
Founder, ReviewResponder

P.S. Just reply if you have any questions - I read every email.

---
Unsubscribe: https://tryreviewresponder.com/unsubscribe?email=${encodeURIComponent(toEmail)}`;

  await resend.emails.send({
    from: 'Berend from ReviewResponder <hello@tryreviewresponder.com>',
    to: toEmail,
    subject: subject,
    html: htmlBody,
    text: textBody,
  });
}

// GET /api/cron/generate-demos - Batch generate demos for leads
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/generate-demos', async (req, res) => {
  const cronSecret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(cronSecret || '', process.env.CRON_SECRET || '')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const limit = parseInt(req.query.limit) || 10;
    // Default to sending emails - pass send_emails=false to skip
    const sendEmails = req.query.send_emails !== 'false';

    // Find leads with email but no demo yet
    const leads = await dbAll(
      `SELECT ol.* FROM outreach_leads ol
       LEFT JOIN demo_generations dg ON ol.id = dg.lead_id
       WHERE ol.email IS NOT NULL
       AND ol.email != ''
       AND dg.id IS NULL
       AND ol.google_reviews_count >= 20
       ORDER BY ol.google_reviews_count DESC
       LIMIT $1`,
      [limit]
    );

    const results = {
      processed: 0,
      success: 0,
      failed: 0,
      demos: [],
    };

    for (const lead of leads) {
      results.processed++;
      try {
        // Generate demo
        const placeInfo = await lookupPlaceId(lead.business_name, lead.city);
        const allReviews = await scrapeGoogleReviews(placeInfo.placeId, 20);

        // Get worst reviews
        const targetReviews = allReviews
          .filter(r => r.rating <= 3)
          .sort((a, b) => a.rating - b.rating)
          .slice(0, 3);

        if (targetReviews.length === 0) {
          console.log(`No negative reviews for ${lead.business_name}, skipping`);
          continue;
        }

        // Generate AI responses
        const demos = [];
        for (const review of targetReviews) {
          const aiResponse = await generateDemoResponse(
            review,
            lead.business_name,
            lead.business_type,
            lead.city,
            placeInfo.rating,
            placeInfo.totalReviews
          );
          demos.push({
            review: {
              text: review.text,
              rating: review.rating,
              author: review.author,
              date: review.date,
              source: review.source || 'google',
              review_link: review.review_link || null,
              review_id: review.review_id || null,
            },
            ai_response: aiResponse,
          });
        }

        const demoToken = generateDemoToken();

        // Save demo
        await dbQuery(
          `INSERT INTO demo_generations
           (business_name, google_place_id, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses, lead_id)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
          [
            lead.business_name,
            placeInfo.placeId,
            lead.city,
            placeInfo.rating,
            placeInfo.totalReviews,
            JSON.stringify(allReviews),
            demoToken,
            JSON.stringify(demos),
            lead.id,
          ]
        );

        // Send email if requested
        if (sendEmails && lead.email) {
          try {
            await sendDemoEmail(
              lead.email,
              lead.business_name,
              demos,
              demoToken,
              placeInfo.totalReviews
            );
            await dbQuery(
              'UPDATE demo_generations SET email_sent_at = NOW() WHERE demo_token = $1',
              [demoToken]
            );
          } catch (emailError) {
            console.error(`Email failed for ${lead.email}:`, emailError.message);
          }
        }

        results.success++;
        results.demos.push({
          business: lead.business_name,
          demo_url: `https://tryreviewresponder.com/demo/${demoToken}`,
          reviews_count: demos.length,
        });

        // Small delay to avoid rate limits
        await new Promise(r => setTimeout(r, 1000));
      } catch (error) {
        results.failed++;
        console.error(`Demo generation failed for ${lead.business_name}:`, error.message);
      }
    }

    // Log for sales state tracking
    if (results.success > 0) {
      await logSalesAction('demo_generated', 'outreach', {
        count: results.success,
        emails_sent: sendEmails ? results.success : 0,
      });
    }

    res.json({
      success: true,
      message: `Generated ${results.success} demos from ${results.processed} leads`,
      ...results,
    });
  } catch (error) {
    console.error('Batch demo generation error:', error);
    res.status(500).json({ error: error.message.slice(0, 100) });
  }
});

// GET /api/cron/send-pending-demo-emails - Send emails for demos that were generated but never emailed
app.get('/api/cron/send-pending-demo-emails', async (req, res) => {
  const cronSecret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(cronSecret || '', process.env.CRON_SECRET || '') &&
      !safeCompare(cronSecret || '', process.env.ADMIN_SECRET || '')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const limit = parseInt(req.query.limit) || 20;

    // Find demos without email_sent_at that have a lead with email
    const pendingDemos = await dbAll(`
      SELECT dg.*, ol.email, ol.business_name as lead_business_name
      FROM demo_generations dg
      JOIN outreach_leads ol ON dg.lead_id = ol.id
      WHERE dg.email_sent_at IS NULL
        AND ol.email IS NOT NULL
        AND ol.email != ''
      ORDER BY dg.created_at DESC
      LIMIT $1
    `, [limit]);

    console.log(`ðŸ“§ Found ${pendingDemos.length} demos without emails`);

    let sent = 0;
    let failed = 0;
    const results = [];

    for (const demo of pendingDemos) {
      try {
        // Check if email was recently sent (parallel-safe)
        if (await wasEmailRecentlySent(demo.email, 'demo_email', 60)) {
          results.push({ email: demo.email, status: 'skipped', reason: 'recently_sent' });
          continue;
        }

        const demos = demo.generated_responses || [];
        if (demos.length === 0) {
          results.push({ email: demo.email, status: 'skipped', reason: 'no_responses' });
          continue;
        }

        await sendDemoEmail(
          demo.email,
          demo.business_name || demo.lead_business_name,
          demos,
          demo.demo_token,
          demo.total_reviews || 0
        );

        await dbQuery(
          'UPDATE demo_generations SET email_sent_at = NOW() WHERE id = $1',
          [demo.id]
        );

        await recordEmailSend(demo.email, 'demo_email');
        sent++;
        results.push({ email: demo.email, status: 'sent', demo_token: demo.demo_token });
      } catch (err) {
        failed++;
        results.push({ email: demo.email, status: 'error', error: err.message.slice(0, 50) });
      }
    }

    res.json({
      success: true,
      message: `Sent ${sent} demo emails (${failed} failed)`,
      pending_found: pendingDemos.length,
      sent,
      failed,
      results: results.slice(0, 10) // Limit response size
    });
  } catch (error) {
    console.error('Send pending demo emails error:', error);
    res.status(500).json({ error: error.message.slice(0, 100) });
  }
});

// GET /api/admin/demos - List all generated demos
app.get('/api/admin/demos', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey || '', process.env.ADMIN_SECRET || '')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const demos = await dbAll(
      `SELECT id, business_name, city, google_rating, total_reviews, demo_token,
              email_sent_at, demo_page_viewed_at, converted_at, created_at,
              (SELECT COUNT(*) FROM jsonb_array_elements(generated_responses)) as response_count
       FROM demo_generations
       ORDER BY created_at DESC
       LIMIT 100`
    );

    const stats = await dbGet(
      `SELECT
         COUNT(*) as total,
         COUNT(email_sent_at) as emails_sent,
         COUNT(demo_page_viewed_at) as pages_viewed,
         COUNT(converted_at) as conversions
       FROM demo_generations`
    );

    res.json({ demos, stats });
  } catch (error) {
    console.error('Admin demos error:', error);
    res.status(500).json({ error: 'Failed to fetch demos' });
  }
});

// GET /sitemap-blog.xml - Dynamic sitemap for blog articles
app.get('/sitemap-blog.xml', async (req, res) => {
  try {
    const articles = await dbAll(
      `SELECT slug, published_at
       FROM blog_articles
       WHERE is_published = TRUE
       ORDER BY published_at DESC`
    );

    const baseUrl = 'https://tryreviewresponder.com';

    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';

    // Main blog page
    xml += '  <url>\n';
    xml += `    <loc>${baseUrl}/blog</loc>\n`;
    xml += '    <changefreq>daily</changefreq>\n';
    xml += '    <priority>0.8</priority>\n';
    xml += '  </url>\n';

    // Individual articles
    for (const article of articles) {
      const lastmod = article.published_at;
      xml += '  <url>\n';
      xml += `    <loc>${baseUrl}/blog/${article.slug}</loc>\n`;
      if (lastmod) {
        xml += `    <lastmod>${new Date(lastmod).toISOString().split('T')[0]}</lastmod>\n`;
      }
      xml += '    <changefreq>monthly</changefreq>\n';
      xml += '    <priority>0.7</priority>\n';
      xml += '  </url>\n';
    }

    xml += '</urlset>';

    res.set('Content-Type', 'application/xml');
    res.send(xml);
  } catch (error) {
    console.error('Blog sitemap error:', error);
    res.status(500).send('Error generating sitemap');
  }
});

// ============== ADMIN BLOG MANAGEMENT ==============

// GET /api/admin/blog - List all articles (published and unpublished)
app.get('/api/admin/blog', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key || '', process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const articles = await dbAll(
      `SELECT id, slug, title, meta_description, category, is_published,
              published_at, created_at, is_auto_generated, view_count, word_count
       FROM blog_articles
       ORDER BY created_at DESC`
    );
    res.json({ articles });
  } catch (error) {
    console.error('Admin blog list error:', error);
    res.status(500).json({ error: 'Failed to fetch articles' });
  }
});

// PUT /api/admin/blog/:id/publish - Publish/unpublish article
app.put('/api/admin/blog/:id/publish', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key || '', process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { is_published, category, author_name } = req.body;
  const { id } = req.params;

  try {
    // Get article to generate slug if needed
    const article = await dbGet('SELECT title, slug, content FROM blog_articles WHERE id = $1', [
      id,
    ]);
    if (!article) {
      return res.status(404).json({ error: 'Article not found' });
    }

    const slug = article.slug || generateSlug(article.title);
    const published_at = is_published ? new Date() : null;

    // Calculate read time (avg 200 words per minute)
    const wordCount = article.content.split(/\s+/).length;
    const read_time_minutes = Math.ceil(wordCount / 200);

    await dbQuery(
      `UPDATE blog_articles
       SET is_published = $1, published_at = COALESCE(published_at, $2),
           slug = $3, category = COALESCE($4, category),
           author_name = COALESCE($5, author_name), read_time_minutes = $6
       WHERE id = $7`,
      [is_published, published_at, slug, category, author_name, read_time_minutes, id]
    );

    res.json({ success: true, slug });
  } catch (error) {
    console.error('Publish article error:', error);
    res.status(500).json({ error: 'Failed to update article' });
  }
});

// PUT /api/admin/blog/:id - Edit article content
app.put('/api/admin/blog/:id', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key || '', process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { title, content, meta_description, keywords, category } = req.body;
  const { id } = req.params;

  try {
    const newSlug = title ? generateSlug(title) : null;

    await dbQuery(
      `UPDATE blog_articles
       SET title = COALESCE($1, title), content = COALESCE($2, content),
           meta_description = COALESCE($3, meta_description),
           keywords = COALESCE($4, keywords), category = COALESCE($5, category),
           slug = COALESCE($6, slug)
       WHERE id = $7`,
      [title, content, meta_description, keywords, category, newSlug, id]
    );

    res.json({ success: true });
  } catch (error) {
    console.error('Edit article error:', error);
    res.status(500).json({ error: 'Failed to update article' });
  }
});

// DELETE /api/admin/blog/:id - Delete article (admin)
app.delete('/api/admin/blog/:id', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key || '', process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    await dbQuery('DELETE FROM blog_articles WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    console.error('Delete article error:', error);
    res.status(500).json({ error: 'Failed to delete article' });
  }
});

// ============== REFERRAL SYSTEM ==============

// Helper function to generate unique referral code
function generateReferralCode() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = 'REF-';
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Get user's referral stats and code
app.get('/api/referrals', authenticateToken, async (req, res) => {
  try {
    let user = await dbGet('SELECT * FROM users WHERE id = $1', [req.user.id]);

    // Generate referral code if user doesn't have one
    if (!user.referral_code) {
      let code;
      let attempts = 0;
      do {
        code = generateReferralCode();
        const existing = await dbGet('SELECT id FROM users WHERE referral_code = $1', [code]);
        if (!existing) break;
        attempts++;
      } while (attempts < 10);

      await dbQuery('UPDATE users SET referral_code = $1 WHERE id = $2', [code, req.user.id]);
      user.referral_code = code;
    }

    // Get referral stats
    const referrals = await dbAll(
      `SELECT r.*, u.email as referred_email, u.subscription_plan
       FROM referrals r
       LEFT JOIN users u ON r.referred_user_id = u.id
       WHERE r.referrer_id = $1
       ORDER BY r.created_at DESC`,
      [req.user.id]
    );

    const stats = {
      totalInvited: referrals.length,
      converted: referrals.filter(r => r.status === 'converted').length,
      pending: referrals.filter(r => r.status === 'pending').length,
      creditsEarned: user.referral_credits || 0,
    };

    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';

    res.json({
      referralCode: user.referral_code,
      referralLink: `${frontendUrl}?ref=${user.referral_code}`,
      stats,
      referrals: referrals.map(r => ({
        id: r.id,
        email: r.referred_email ? r.referred_email.replace(/(.{2}).*(@.*)/, '$1***$2') : 'Pending',
        status: r.status,
        plan: r.subscription_plan || 'free',
        createdAt: r.created_at,
        convertedAt: r.converted_at,
      })),
    });
  } catch (error) {
    console.error('Get referrals error:', error);
    res.status(500).json({ error: 'Failed to get referral data' });
  }
});

// Validate referral code (public endpoint)
app.get('/api/referrals/validate/:code', async (req, res) => {
  try {
    const { code } = req.params;

    if (!code || code.length < 4) {
      return res.status(400).json({ valid: false, error: 'Invalid code format' });
    }

    const referrer = await dbGet(
      'SELECT id, business_name, email FROM users WHERE referral_code = $1',
      [code.toUpperCase()]
    );

    if (!referrer) {
      return res.json({ valid: false });
    }

    res.json({
      valid: true,
      referrerName: referrer.business_name || referrer.email.split('@')[0],
      bonus: '1 month free after first paid subscription',
    });
  } catch (error) {
    console.error('Validate referral error:', error);
    res.status(500).json({ valid: false, error: 'Validation failed' });
  }
});

// ============== AFFILIATE/PARTNER PROGRAM ==============

// Helper function to generate unique affiliate code
function generateAffiliateCode() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = 'AFF-';
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Apply to become an affiliate
app.post('/api/affiliate/apply', authenticateToken, async (req, res) => {
  try {
    const { website, marketingChannels, audienceSize, payoutMethod, payoutEmail } = req.body;

    // Check if user already applied
    const existingAffiliate = await dbGet('SELECT * FROM affiliates WHERE user_id = $1', [
      req.user.id,
    ]);

    if (existingAffiliate) {
      return res.status(400).json({
        error: 'You already have an affiliate application',
        status: existingAffiliate.status,
      });
    }

    // Generate unique affiliate code
    let affiliateCode;
    let attempts = 0;
    do {
      affiliateCode = generateAffiliateCode();
      const existing = await dbGet('SELECT id FROM affiliates WHERE affiliate_code = $1', [
        affiliateCode,
      ]);
      if (!existing) break;
      attempts++;
    } while (attempts < 10);

    // Create affiliate application
    const result = await dbQuery(
      `INSERT INTO affiliates (user_id, affiliate_code, website, marketing_channels, audience_size, payout_method, payout_email)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id`,
      [
        req.user.id,
        affiliateCode,
        website || null,
        marketingChannels || null,
        audienceSize || null,
        payoutMethod || 'paypal',
        payoutEmail || null,
      ]
    );

    // Auto-approve for now (can add manual review later)
    await dbQuery(`UPDATE affiliates SET status = 'approved', approved_at = NOW() WHERE id = $1`, [
      result.rows[0].id,
    ]);

    console.log(
      `ðŸ¤ New affiliate application approved: User ${req.user.id}, Code: ${affiliateCode}`
    );

    res.json({
      success: true,
      message: 'Congratulations! You are now an affiliate partner.',
      affiliateCode,
      commissionRate: 20,
    });
  } catch (error) {
    console.error('Affiliate apply error:', error);
    res.status(500).json({ error: 'Failed to process affiliate application' });
  }
});

// Get affiliate status and stats
app.get('/api/affiliate/stats', authenticateToken, async (req, res) => {
  try {
    const affiliate = await dbGet('SELECT * FROM affiliates WHERE user_id = $1', [req.user.id]);

    if (!affiliate) {
      return res.json({ isAffiliate: false });
    }

    // Get click stats
    const clickStats = await dbGet(
      `SELECT COUNT(*) as total_clicks,
              COUNT(DISTINCT DATE(clicked_at)) as days_with_clicks
       FROM affiliate_clicks WHERE affiliate_id = $1`,
      [affiliate.id]
    );

    // Get clicks last 30 days
    const clicksLast30Days = await dbAll(
      `SELECT DATE(clicked_at) as date, COUNT(*) as clicks
       FROM affiliate_clicks
       WHERE affiliate_id = $1 AND clicked_at > NOW() - INTERVAL '30 days'
       GROUP BY DATE(clicked_at)
       ORDER BY date DESC`,
      [affiliate.id]
    );

    // Get conversion stats
    const conversionStats = await dbGet(
      `SELECT COUNT(*) as total_conversions,
              COALESCE(SUM(commission_amount), 0) as total_commission,
              COALESCE(SUM(CASE WHEN status = 'pending' THEN commission_amount ELSE 0 END), 0) as pending_commission,
              COALESCE(SUM(CASE WHEN status = 'paid' THEN commission_amount ELSE 0 END), 0) as paid_commission
       FROM affiliate_conversions WHERE affiliate_id = $1`,
      [affiliate.id]
    );

    // Get recent conversions
    const recentConversions = await dbAll(
      `SELECT ac.*, u.email as referred_email
       FROM affiliate_conversions ac
       LEFT JOIN users u ON ac.referred_user_id = u.id
       WHERE ac.affiliate_id = $1
       ORDER BY ac.created_at DESC
       LIMIT 10`,
      [affiliate.id]
    );

    // Get conversion rate
    const totalClicks = parseInt(clickStats?.total_clicks || 0);
    const totalConversions = parseInt(conversionStats?.total_conversions || 0);
    const conversionRate =
      totalClicks > 0 ? ((totalConversions / totalClicks) * 100).toFixed(2) : 0;

    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';

    res.json({
      isAffiliate: true,
      affiliate: {
        code: affiliate.affiliate_code,
        status: affiliate.status,
        commissionRate: parseFloat(affiliate.commission_rate),
        payoutMethod: affiliate.payout_method,
        payoutEmail: affiliate.payout_email,
        appliedAt: affiliate.applied_at,
        approvedAt: affiliate.approved_at,
      },
      links: {
        affiliateLink: `${frontendUrl}?aff=${affiliate.affiliate_code}`,
        dashboardLink: `${frontendUrl}/affiliate`,
      },
      stats: {
        totalClicks: totalClicks,
        totalConversions: totalConversions,
        conversionRate: parseFloat(conversionRate),
        totalEarned: parseFloat(conversionStats?.total_commission || 0),
        pendingBalance: parseFloat(conversionStats?.pending_commission || 0),
        paidOut: parseFloat(conversionStats?.paid_commission || 0),
      },
      clicksChart: clicksLast30Days,
      recentConversions: recentConversions.map(c => ({
        id: c.id,
        email: c.referred_email ? c.referred_email.replace(/(.{2}).*(@.*)/, '$1***$2') : 'Unknown',
        plan: c.subscription_plan,
        amount: parseFloat(c.amount_paid),
        commission: parseFloat(c.commission_amount),
        status: c.status,
        createdAt: c.created_at,
      })),
    });
  } catch (error) {
    console.error('Get affiliate stats error:', error);
    res.status(500).json({ error: 'Failed to get affiliate stats' });
  }
});

// Get payout history
app.get('/api/affiliate/payouts', authenticateToken, async (req, res) => {
  try {
    const affiliate = await dbGet('SELECT id FROM affiliates WHERE user_id = $1', [req.user.id]);

    if (!affiliate) {
      return res.status(403).json({ error: 'You are not an affiliate' });
    }

    const payouts = await dbAll(
      `SELECT * FROM affiliate_payouts WHERE affiliate_id = $1 ORDER BY requested_at DESC`,
      [affiliate.id]
    );

    // Calculate totals
    const totalPaid = payouts
      .filter(p => p.status === 'completed')
      .reduce((sum, p) => sum + parseFloat(p.amount), 0);

    const pendingPayouts = payouts
      .filter(p => p.status === 'pending' || p.status === 'processing')
      .reduce((sum, p) => sum + parseFloat(p.amount), 0);

    res.json({
      payouts: payouts.map(p => ({
        id: p.id,
        amount: parseFloat(p.amount),
        method: p.payout_method,
        email: p.payout_email,
        status: p.status,
        transactionId: p.transaction_id,
        requestedAt: p.requested_at,
        processedAt: p.processed_at,
      })),
      totalPaid,
      pendingPayouts,
    });
  } catch (error) {
    console.error('Get affiliate payouts error:', error);
    res.status(500).json({ error: 'Failed to get payout history' });
  }
});

// Request a payout
app.post('/api/affiliate/payout', authenticateToken, async (req, res) => {
  try {
    const affiliate = await dbGet('SELECT * FROM affiliates WHERE user_id = $1 AND status = $2', [
      req.user.id,
      'approved',
    ]);

    if (!affiliate) {
      return res.status(403).json({ error: 'You are not an approved affiliate' });
    }

    // Calculate available balance
    const balanceResult = await dbGet(
      `SELECT COALESCE(SUM(CASE WHEN status = 'approved' THEN commission_amount ELSE 0 END), 0) as available
       FROM affiliate_conversions WHERE affiliate_id = $1`,
      [affiliate.id]
    );

    const availableBalance = parseFloat(balanceResult?.available || 0);
    const minimumPayout = 50; // Minimum $50 for payout

    if (availableBalance < minimumPayout) {
      return res.status(400).json({
        error: `Minimum payout is $${minimumPayout}. Your available balance is $${availableBalance.toFixed(2)}`,
      });
    }

    if (!affiliate.payout_email) {
      return res.status(400).json({ error: 'Please set your payout email in affiliate settings' });
    }

    // Create payout request
    await dbQuery(
      `INSERT INTO affiliate_payouts (affiliate_id, amount, payout_method, payout_email)
       VALUES ($1, $2, $3, $4)`,
      [affiliate.id, availableBalance, affiliate.payout_method, affiliate.payout_email]
    );

    // Mark conversions as paid
    await dbQuery(
      `UPDATE affiliate_conversions SET status = 'paid', paid_at = NOW()
       WHERE affiliate_id = $1 AND status = 'approved'`,
      [affiliate.id]
    );

    console.log(
      `ðŸ’° Affiliate payout requested: User ${req.user.id}, Amount: $${availableBalance.toFixed(2)}`
    );

    res.json({
      success: true,
      message: `Payout request of $${availableBalance.toFixed(2)} submitted. We will process it within 5 business days.`,
      amount: availableBalance,
    });
  } catch (error) {
    console.error('Request payout error:', error);
    res.status(500).json({ error: 'Failed to request payout' });
  }
});

// Update affiliate settings (payout method, email)
app.put('/api/affiliate/settings', authenticateToken, async (req, res) => {
  try {
    const { payoutMethod, payoutEmail } = req.body;

    const affiliate = await dbGet('SELECT id FROM affiliates WHERE user_id = $1', [req.user.id]);

    if (!affiliate) {
      return res.status(403).json({ error: 'You are not an affiliate' });
    }

    const updates = [];
    const values = [];
    let paramIndex = 1;

    if (payoutMethod) {
      updates.push(`payout_method = $${paramIndex++}`);
      values.push(payoutMethod);
    }

    if (payoutEmail) {
      if (!validator.isEmail(payoutEmail)) {
        return res.status(400).json({ error: 'Invalid payout email' });
      }
      updates.push(`payout_email = $${paramIndex++}`);
      values.push(payoutEmail.toLowerCase());
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    values.push(affiliate.id);
    await dbQuery(`UPDATE affiliates SET ${updates.join(', ')} WHERE id = $${paramIndex}`, values);

    res.json({ success: true, message: 'Affiliate settings updated' });
  } catch (error) {
    console.error('Update affiliate settings error:', error);
    res.status(500).json({ error: 'Failed to update settings' });
  }
});

// Track affiliate click (public endpoint)
app.get('/api/affiliate/track/:code', async (req, res) => {
  try {
    const { code } = req.params;

    const affiliate = await dbGet(
      'SELECT id FROM affiliates WHERE affiliate_code = $1 AND status = $2',
      [code.toUpperCase(), 'approved']
    );

    if (!affiliate) {
      // Redirect to homepage without tracking if invalid code
      return res.redirect(process.env.FRONTEND_URL || 'http://localhost:3000');
    }

    // Track the click
    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const userAgent = req.headers['user-agent'] || '';
    const referrer = req.headers['referer'] || '';

    await dbQuery(
      `INSERT INTO affiliate_clicks (affiliate_id, ip_address, user_agent, referrer)
       VALUES ($1, $2, $3, $4)`,
      [affiliate.id, ip.split(',')[0], userAgent, referrer]
    );

    // Redirect to homepage with affiliate code
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    res.redirect(`${frontendUrl}?aff=${code}`);
  } catch (error) {
    console.error('Track affiliate click error:', error);
    res.redirect(process.env.FRONTEND_URL || 'http://localhost:3000');
  }
});

// Validate affiliate code (public endpoint)
app.get('/api/affiliate/validate/:code', async (req, res) => {
  try {
    const { code } = req.params;

    const affiliate = await dbGet(
      `SELECT a.*, u.business_name, u.email
       FROM affiliates a
       JOIN users u ON a.user_id = u.id
       WHERE a.affiliate_code = $1 AND a.status = $2`,
      [code.toUpperCase(), 'approved']
    );

    if (!affiliate) {
      return res.json({ valid: false });
    }

    res.json({
      valid: true,
      affiliateName: affiliate.business_name || affiliate.email.split('@')[0],
      commissionRate: parseFloat(affiliate.commission_rate),
    });
  } catch (error) {
    console.error('Validate affiliate error:', error);
    res.status(500).json({ valid: false, error: 'Validation failed' });
  }
});

// ============== API Key Management Endpoints ==============

// Get user's API keys
app.get('/api/keys', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet(
      'SELECT subscription_plan, subscription_status FROM users WHERE id = $1',
      [req.user.id]
    );

    if (user.subscription_plan !== 'unlimited' || user.subscription_status !== 'active') {
      return res
        .status(403)
        .json({ error: 'API keys are only available for Unlimited plan subscribers' });
    }

    const keys = await dbAll(
      `SELECT id, key_prefix, name, requests_today, requests_total, last_request_at, is_active, created_at
       FROM api_keys WHERE user_id = $1 ORDER BY created_at DESC`,
      [req.user.id]
    );

    res.json({ keys });
  } catch (error) {
    console.error('Get API keys error:', error);
    res.status(500).json({ error: 'Failed to get API keys' });
  }
});

// Generate new API key
app.post('/api/keys', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet(
      'SELECT subscription_plan, subscription_status FROM users WHERE id = $1',
      [req.user.id]
    );

    if (user.subscription_plan !== 'unlimited' || user.subscription_status !== 'active') {
      return res
        .status(403)
        .json({ error: 'API keys are only available for Unlimited plan subscribers' });
    }

    // Check if user already has 5 keys
    const keyCount = await dbGet('SELECT COUNT(*) as count FROM api_keys WHERE user_id = $1', [
      req.user.id,
    ]);
    if (parseInt(keyCount.count) >= 5) {
      return res
        .status(400)
        .json({ error: 'Maximum 5 API keys allowed. Please delete an existing key first.' });
    }

    const { name } = req.body;
    const keyName = name || 'API Key';

    // Generate a secure API key
    const rawKey = 'rr_' + crypto.randomBytes(32).toString('hex');
    const keyHash = crypto.createHash('sha256').update(rawKey).digest('hex');
    const keyPrefix = rawKey.substring(0, 10);

    await dbQuery(
      `INSERT INTO api_keys (user_id, key_hash, key_prefix, name) VALUES ($1, $2, $3, $4)`,
      [req.user.id, keyHash, keyPrefix, keyName]
    );

    // Return the full key only once - it won't be retrievable later
    res.json({
      key: rawKey,
      prefix: keyPrefix,
      name: keyName,
      message: 'Save this API key - it will not be shown again!',
    });
  } catch (error) {
    console.error('Create API key error:', error);
    res.status(500).json({ error: 'Failed to create API key' });
  }
});

// Update API key (rename or toggle active status)
app.put('/api/keys/:id', authenticateToken, async (req, res) => {
  try {
    const { name, isActive } = req.body;
    const keyId = req.params.id;

    // Check if key exists and belongs to user
    const existingKey = await dbGet('SELECT id FROM api_keys WHERE id = $1 AND user_id = $2', [
      keyId,
      req.user.id,
    ]);

    if (!existingKey) {
      return res.status(404).json({ error: 'API key not found' });
    }

    // Build update query dynamically
    const updates = [];
    const values = [];
    let paramIndex = 1;

    if (name !== undefined) {
      updates.push(`name = $${paramIndex++}`);
      values.push(name);
    }

    if (isActive !== undefined) {
      updates.push(`is_active = $${paramIndex++}`);
      values.push(isActive);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    values.push(keyId, req.user.id);
    const result = await dbQuery(
      `UPDATE api_keys SET ${updates.join(', ')} WHERE id = $${paramIndex++} AND user_id = $${paramIndex} RETURNING id, name, is_active`,
      values
    );

    res.json({
      success: true,
      key: {
        id: result.rows[0].id,
        name: result.rows[0].name,
        isActive: result.rows[0].is_active,
      },
    });
  } catch (error) {
    console.error('Update API key error:', error);
    res.status(500).json({ error: 'Failed to update API key' });
  }
});

// Delete API key
app.delete('/api/keys/:id', authenticateToken, async (req, res) => {
  try {
    const result = await dbQuery(
      'DELETE FROM api_keys WHERE id = $1 AND user_id = $2 RETURNING id',
      [req.params.id, req.user.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'API key not found' });
    }

    res.json({ success: true, message: 'API key deleted' });
  } catch (error) {
    console.error('Delete API key error:', error);
    res.status(500).json({ error: 'Failed to delete API key' });
  }
});

// ============== Public API Endpoint ==============

// POST /api/v1/generate - Public API for generating responses
app.post('/api/v1/generate', authenticateApiKey, async (req, res) => {
  try {
    const { review_text, review_rating, tone, language, platform, ai_model = 'auto' } = req.body;

    if (!review_text) {
      return res.status(400).json({ error: 'review_text is required' });
    }

    const user = req.apiKeyUser;
    const selectedTone = tone || 'professional';
    const selectedLanguage = language || 'en';
    const selectedPlatform = platform || 'google';

    // Get plan limits and check usage
    const planLimits = PLAN_LIMITS[user.subscription_plan || 'unlimited'] || PLAN_LIMITS.unlimited;
    const smartUsed = user.smart_responses_used || 0;
    const standardUsed = user.standard_responses_used || 0;
    const smartRemaining = planLimits.smartResponses - smartUsed;
    const standardRemaining = planLimits.standardResponses - standardUsed;

    // Determine which AI model to use
    let useModel = 'standard';

    if (ai_model === 'smart') {
      if (smartRemaining <= 0) {
        return res.status(403).json({
          error: 'No Smart AI responses remaining',
          smartRemaining: 0,
          standardRemaining,
        });
      }
      useModel = 'smart';
    } else if (ai_model === 'auto') {
      useModel = smartRemaining > 0 ? 'smart' : 'standard';
      if (useModel === 'standard' && standardRemaining <= 0) {
        return res.status(403).json({ error: 'No responses remaining' });
      }
    } else {
      if (standardRemaining <= 0) {
        return res.status(403).json({ error: 'No Standard responses remaining' });
      }
    }

    // ========== ANTHROPIC BEST PRACTICES 2025: Full XML Structure ==========
    const apiLanguageNames = {
      en: 'English',
      de: 'German',
      es: 'Spanish',
      fr: 'French',
      it: 'Italian',
      pt: 'Portuguese',
      nl: 'Dutch',
      ja: 'Japanese',
      zh: 'Chinese',
      ko: 'Korean',
      ar: 'Arabic',
      ru: 'Russian',
    };

    // Build context parts
    const contextParts = [];
    if (user.business_context) contextParts.push(`Business details: ${user.business_context}`);
    if (user.response_style) contextParts.push(`Owner's style: ${user.response_style}`);
    if (selectedPlatform) contextParts.push(`Platform: ${selectedPlatform}`);

    // Determine rating strategy
    const ratingStrategy =
      review_rating && review_rating <= 2
        ? 'This is a negative review. Take ownership of issues. Offer to make it right directly.'
        : review_rating && review_rating >= 4
          ? 'This is a positive review. Thank them naturally, reference specifics.'
          : 'Respond appropriately to the tone of the review.';

    const systemPrompt = `<role>
You are ${user.business_name ? `the owner of ${user.business_name}` : 'a business owner'}${user.business_type ? `, a ${user.business_type}` : ''}.
You write review responses yourself - no PR team, no templates.
</role>

<context>
${contextParts.length > 0 ? contextParts.join('\n') : 'Responding to a customer review.'}
Language: ${apiLanguageNames[selectedLanguage] || selectedLanguage}
${review_rating ? `Rating: ${review_rating} stars - ${ratingStrategy}` : ''}
</context>

<voice>
- You're the owner, not customer service
- Write like you'd text a regular customer
- Warm but not gushing
- Confident but humble
- Direct and personal
</voice>

<style_rules>
- 2-3 sentences maximum
- One exclamation mark max (zero is fine)
- Always use contractions (we're, you'll, that's, don't)
- Reference something specific from their review
- Sign with first name if business context includes owner name
</style_rules>

<avoid_patterns>
<forbidden_starts>
Never start with: "Thank you for", "We appreciate", "I'm sorry for any", "We value"
</forbidden_starts>
<forbidden_words>
${AI_SLOP_WORDS.slice(0, 20).join(', ')}
</forbidden_words>
<forbidden_phrases>
${AI_SLOP_PHRASES.slice(0, 8).join('; ')}
</forbidden_phrases>
<replacements>
- "Thank you for your feedback" â†’ "Glad you enjoyed [specific thing]"
- "We appreciate you taking the time" â†’ "Nice to hear about [detail]"
- "Sorry for any inconvenience" â†’ "That's on us. We'll fix it."
</replacements>
</avoid_patterns>

${getFewShotExamplesXML(user?.business_type)}

<output_format>
Write the response directly. No quotes. No "Response:" prefix. No explanation.
Just the review response text, ready to post.
</output_format>`;

    let generatedResponse;

    if (useModel === 'smart' && anthropic) {
      // Use Claude for Smart AI
      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 300,
        system: systemPrompt,
        messages: [{ role: 'user', content: `[Review] ${review_text}` }],
      });
      generatedResponse = response.content[0].text.trim();
    } else {
      // Use GPT-4o-mini for Standard AI
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: `[Review] ${review_text}` },
        ],
        max_tokens: 300,
        temperature: 0.6,
        presence_penalty: 0.1,
        frequency_penalty: 0.1,
      });
      generatedResponse = completion.choices[0].message.content.trim();
      if (useModel === 'smart' && !anthropic) useModel = 'standard';
    }

    // Apply AI slop filter to clean up typical AI phrases
    generatedResponse = cleanAISlop(generatedResponse);

    // Save to responses table with AI model
    await dbQuery(
      `INSERT INTO responses (user_id, review_text, review_rating, review_platform, generated_response, tone, ai_model) VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        user.id,
        review_text,
        review_rating || null,
        selectedPlatform,
        generatedResponse,
        selectedTone,
        useModel,
      ]
    );

    // Update correct usage counter
    if (useModel === 'smart') {
      await dbQuery(
        'UPDATE users SET smart_responses_used = smart_responses_used + 1, responses_used = responses_used + 1 WHERE id = $1',
        [user.id]
      );
    } else {
      await dbQuery(
        'UPDATE users SET standard_responses_used = standard_responses_used + 1, responses_used = responses_used + 1 WHERE id = $1',
        [user.id]
      );
    }

    const updatedUser = await dbGet(
      'SELECT smart_responses_used, standard_responses_used FROM users WHERE id = $1',
      [user.id]
    );

    res.json({
      success: true,
      response: generatedResponse,
      ai_model: useModel,
      tone: selectedTone,
      language: selectedLanguage,
      platform: selectedPlatform,
      usage: {
        smart: { used: updatedUser.smart_responses_used || 0, limit: planLimits.smartResponses },
        standard: {
          used: updatedUser.standard_responses_used || 0,
          limit: planLimits.standardResponses,
        },
      },
    });
  } catch (error) {
    console.error('API generate error:', error);
    res.status(500).json({ error: 'Failed to generate response' });
  }
});

// ============ USER FEEDBACK / TESTIMONIALS ============

// Submit feedback (after 10 responses)
app.post('/api/feedback', authenticateToken, async (req, res) => {
  try {
    const { rating, comment, displayName } = req.body;

    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({ error: 'Rating must be between 1 and 5' });
    }

    // Check if user already submitted feedback
    const existing = await dbGet('SELECT id FROM user_feedback WHERE user_id = $1', [req.user.id]);

    if (existing) {
      return res.status(400).json({ error: 'You have already submitted feedback' });
    }

    // Get user info for display name
    const user = await dbGet('SELECT email, business_name FROM users WHERE id = $1', [req.user.id]);
    const userName = displayName || user.business_name || user.email.split('@')[0];

    // Insert feedback - auto-approved for transparency
    const insertResult = await dbQuery(
      `INSERT INTO user_feedback (user_id, rating, comment, user_name, approved)
       VALUES ($1, $2, $3, $4, TRUE) RETURNING id`,
      [req.user.id, rating, comment || null, userName]
    );

    // Mark user as having submitted feedback
    await dbQuery('UPDATE users SET feedback_submitted = TRUE WHERE id = $1', [req.user.id]);

    // Auto-generate AI response for dogfooding section (non-blocking)
    if (comment && insertResult.rows && insertResult.rows[0]) {
      const testimonialId = insertResult.rows[0].id;
      generateAIResponseForTestimonial(testimonialId, rating, comment, userName)
        .then(() => console.log(`ðŸ¤– Auto-generated AI response for testimonial ${testimonialId}`))
        .catch(err => console.error(`Failed to auto-generate AI response:`, err.message));
    }

    res.json({ success: true, message: 'Thank you for your feedback!' });
  } catch (error) {
    console.error('Feedback submission error:', error);
    res.status(500).json({ error: 'Failed to submit feedback' });
  }
});

// Check if user should see feedback popup
app.get('/api/feedback/status', authenticateToken, async (req, res) => {
  try {
    const user = await dbGet('SELECT responses_used, feedback_submitted FROM users WHERE id = $1', [
      req.user.id,
    ]);

    // Show popup after 3 responses, if not already submitted (farm testimonials early!)
    const shouldShowPopup = user.responses_used >= 3 && !user.feedback_submitted;

    res.json({
      shouldShowPopup,
      responsesUsed: user.responses_used,
      feedbackSubmitted: user.feedback_submitted,
    });
  } catch (error) {
    console.error('Feedback status error:', error);
    res.status(500).json({ error: 'Failed to get feedback status' });
  }
});

// Get approved testimonials (public - no auth required)
app.get('/api/testimonials', async (req, res) => {
  try {
    const testimonials = await dbAll(
      `SELECT rating, comment, user_name, created_at, ai_response
       FROM user_feedback
       WHERE approved = TRUE AND comment IS NOT NULL AND comment != ''
       ORDER BY featured DESC, rating DESC, created_at DESC
       LIMIT 10`
    );

    // Add display_name for consistent name display on frontend
    const testimonialsWithDisplayName = testimonials.map(t => ({
      ...t,
      display_name: cleanDisplayName(t.user_name) || t.user_name
    }));

    res.json({ testimonials: testimonialsWithDisplayName });
  } catch (error) {
    console.error('Testimonials fetch error:', error);
    res.status(500).json({ error: 'Failed to get testimonials' });
  }
});

// Admin: Delete testimonial
app.delete('/api/admin/testimonials/:id', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    await dbQuery('DELETE FROM user_feedback WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete' });
  }
});

// Admin: Update testimonial (name, comment, approved)
app.put('/api/admin/testimonials/:id', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { user_name, comment, approved } = req.body;

  try {
    await dbQuery(
      'UPDATE user_feedback SET user_name = COALESCE($1, user_name), comment = COALESCE($2, comment), approved = COALESCE($3, approved) WHERE id = $4',
      [user_name, comment, approved, req.params.id]
    );
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to update' });
  }
});

// Admin: List all testimonials (including non-approved)
app.get('/api/admin/testimonials', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const testimonials = await dbAll(
      `SELECT id, rating, comment, user_name, approved, created_at, ai_response FROM user_feedback ORDER BY created_at DESC`
    );
    res.json({ testimonials });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch' });
  }
});

/**
 * Clean display name from usernames with numbers
 * andrehoellering1732004 -> Andre
 * TiniwiDE -> Tiniwi DE
 * Mati -> Mati
 * 12345 -> null
 */
function cleanDisplayName(userName) {
  if (!userName) return null;

  // Remove trailing numbers (andrehoellering1732004 -> andrehoellering)
  let cleaned = userName.replace(/\d+$/g, '').trim();

  // If empty after removing numbers, return null
  if (!cleaned || cleaned.length < 2) return null;

  // Handle camelCase usernames (TiniwiDE -> Tiniwi DE)
  if (/[a-z][A-Z]/.test(cleaned)) {
    cleaned = cleaned.replace(/([a-z])([A-Z])/g, '$1 $2');
  }

  // If all lowercase (likely a username), capitalize first letter
  if (/^[a-z]+$/.test(cleaned)) {
    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
  }

  // Extract first name only if it looks like "firstname lastname"
  if (cleaned.includes(' ')) {
    const firstName = cleaned.split(' ')[0];
    // Only use first name if it's reasonable (2-15 chars)
    if (firstName.length >= 2 && firstName.length <= 15) {
      return firstName;
    }
  }

  return cleaned;
}

// Helper: Generate AI response for a testimonial (used by both auto and admin)
// ========== OPTIMIZED WITH ANTHROPIC BEST PRACTICES + META CONTEXT ==========
async function generateAIResponseForTestimonial(testimonialId, rating, comment, userName) {
  // Clean the display name first (removes numbers from usernames like andrehoellering1732004 -> Andre)
  const cleanedName = cleanDisplayName(userName);
  const displayAuthor = cleanedName || 'a customer';

  // ========== FULL CONTEXT + ANTHROPIC BEST PRACTICES ==========
  const systemMessage = `You are Berend, founder of ReviewResponder, responding to a user review.

<meta_context>
This response will appear on our landing page in the "Reviews About Us" section.
Potential customers see these responses and think: "This is how MY responses will look."
Make it genuine, specific, and impressive - this is our showcase.
</meta_context>

<about_reviewresponder>
ReviewResponder helps business owners respond to customer reviews quickly and professionally.

WHO WE ARE:
- Created by Berend in Germany, 2026
- I built this because I watched restaurant owners spend hours every week writing review responses - time they could spend on their actual business

HOW IT WORKS:
The ReviewResponder Chrome Extension works directly on review platforms:
- Google Maps, Yelp, TripAdvisor, Trustpilot, Booking.com
- Click "Generate Response" next to any review
- AI creates a personalized response in seconds
- One click to copy or paste directly

KEY FEATURES:
- Any language with auto-detect
- 4 tone options: Professional, Friendly, Apologetic, Enthusiastic
- Business context - AI knows your specific business details
- Bulk generation for catching up on multiple reviews (Pro plan)
- Response history to track what you've responded to

WHY I BUILT THIS:
Small business owners shouldn't have to choose between ignoring reviews and spending hours writing responses. Every review deserves a thoughtful reply - but it shouldn't take 10 minutes to write one.

PRICING:
- Free: 20 responses/month
- Starter $29/mo: 300 responses
- Pro $49/mo: 800 responses + team access + bulk generation
- Unlimited $99/mo: No limits + API

DATA HANDLING:
- Reviews are processed and immediately discarded
- We don't store or train on your customer data
- GDPR compliant (German company)

CONTACT:
- support@tryreviewresponder.com
- I (Berend) personally read and respond to support emails
- Usually within 24 hours, often faster
</about_reviewresponder>

<voice_guidelines>
BE AUTHENTIC:
- Sound like a real person, not a corporate entity
- Use "I" (as Berend) or "we" (as the team)
- Be genuinely grateful, not performatively grateful
- Take criticism seriously - they're helping us improve

WHEN SOMEONE IS HAPPY:
- Thank them sincerely (one sentence is enough)
- If they mention a specific feature, acknowledge it
- If they mention time saved, that matters - say so
- Keep it short: 2-3 sentences that actually say something

WHEN SOMEONE HAS FEEDBACK OR CONCERNS:
- Be honest about what we can and can't do
- Offer to help: support@tryreviewresponder.com
- Don't make promises we can't keep
- If there's a feature that addresses their concern, mention it

SIGN OFF:
- "Thanks, Berend" or "- Berend" or "- The ReviewResponder Team"
- Keep it natural and direct
</voice_guidelines>

<output_rules>
- Length: 2-4 sentences maximum
- Address reviewer by first name only
- If name looks like a username with numbers, use "you" instead
- Write the response directly - no quotes, no "Response:" prefix
- Vary your opening - don't always start with "That's exactly what I was going for"
- If relevant, mention specific features or offer support email
</output_rules>

<avoid_ai_patterns>
Never use these phrases - they sound artificial:
${AI_SLOP_PHRASES.map(p => `- "${p}"`).join('\n')}

Avoid these overused words:
${AI_SLOP_WORDS.join(', ')}
</avoid_ai_patterns>

<examples>
<example type="enthusiastic_user">
<review rating="5" author="Sarah">This is exactly what I needed! Saves me hours every week responding to Google reviews. The Chrome extension is seamless.</review>
<response>Really glad it's saving you time, Sarah - hours every week adds up. That's why I built the extension to work right on Google Maps instead of making you copy-paste. Thanks, Berend</response>
</example>

<example type="specific_feature_praise">
<review rating="5" author="Mike">Great for my restaurant. The AI actually picks up on our specialty dishes and mentions them naturally in responses.</review>
<response>Love hearing this, Mike. We put a lot of work into the business context feature because generic "thanks for dining with us" responses are the worst. Glad it's actually using your menu details. Thanks, Berend</response>
</example>

<example type="simple_positive">
<review rating="5" author="Tom">Nice tool. Simple and does what it says.</review>
<response>Appreciate that, Tom. Simple was the goal - no one needs another complicated tool. Glad it's working for you. - Berend</response>
</example>

<example type="constructive_feedback">
<review rating="4" author="Lisa">Good tool overall but sometimes the responses feel a bit too formal for my casual coffee shop vibe.</review>
<response>Fair point, Lisa. The tone settings help but aren't perfect for every vibe. Have you tried custom instructions in settings? That's where you can really dial in your voice. Happy to help set it up: support@tryreviewresponder.com - Berend</response>
</example>

<example type="feature_request">
<review rating="3" author="James">Works fine but wish there was a way to handle multiple reviews at once. Gets tedious one by one.</review>
<response>Totally get that, James. Bulk generation is on Pro ($49/mo) - lets you do 20 reviews at once. If you're doing high volume it's worth checking out. Questions? support@tryreviewresponder.com - Berend</response>
</example>

<example type="technical_issue">
<review rating="4" author="Anna">Love the concept but had some issues with the extension not loading on TripAdvisor sometimes.</review>
<response>Sorry about that, Anna. TripAdvisor changes their layout occasionally and we have to update. Should be fixed now - if still having issues, email me at support@tryreviewresponder.com and I'll look into it personally. - Berend</response>
</example>

<example type="non_english">
<review rating="5" author="Carlos">Excelente herramienta para mi restaurante. Me ahorra mucho tiempo.</review>
<response>Gracias Carlos! Me alegra que te estÃ© ahorrando tiempo con tu restaurante. Para eso lo creÃ© - que los dueÃ±os de negocios puedan responder rÃ¡pido sin perder horas. - Berend</response>
</example>
</examples>`;

  const userMessage = `<review rating="${rating}" author="${displayAuthor}">
${comment}
</review>

Generate a response following the guidelines. Be specific to what they said. Vary your phrasing.`;

  // Use Claude (Anthropic) with system parameter separated (Anthropic Best Practice)
  const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
  const completion = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 400,
    system: systemMessage,
    messages: [{ role: 'user', content: userMessage }],
  });

  const aiResponse = completion.content[0].text.trim();

  // Save the response to the database
  await dbQuery('UPDATE user_feedback SET ai_response = $1 WHERE id = $2', [
    aiResponse,
    testimonialId,
  ]);

  return aiResponse;
}

// Admin: Generate AI response for a testimonial (dogfooding section)
app.post('/api/admin/testimonials/:id/generate-response', async (req, res) => {
  const { key } = req.query;
  if (!process.env.ADMIN_SECRET || !safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Get the testimonial
    const testimonial = await dbGet('SELECT * FROM user_feedback WHERE id = $1', [req.params.id]);
    if (!testimonial) {
      return res.status(404).json({ error: 'Testimonial not found' });
    }

    // Use the helper function
    const aiResponse = await generateAIResponseForTestimonial(
      testimonial.id,
      testimonial.rating,
      testimonial.comment,
      testimonial.user_name
    );

    res.json({
      success: true,
      ai_response: aiResponse,
      testimonial_id: req.params.id,
    });
  } catch (error) {
    console.error('Generate testimonial response error:', error);
    res.status(500).json({ error: 'Failed to generate response' });
  }
});

// Drip Email Campaign - Send scheduled emails based on user signup date
// Call this endpoint via cron job (e.g., daily at 9am)
app.get('/api/cron/send-drip-emails', async (req, res) => {
  // Accept both header and query parameter for secret (like daily-outreach)
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const DRIP_SCHEDULE = [0, 2, 5, 10, 20]; // Days after signup
  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  // Email templates for each day
  const getDripEmail = (day, user) => {
    const templates = {
      0: {
        subject: 'Your 30% discount expires in 7 days',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .discount-box { background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%); border: 2px dashed #D97706; padding: 20px; border-radius: 8px; text-align: center; margin: 24px 0; }
              .discount-code { font-size: 28px; font-weight: bold; color: #D97706; font-family: monospace; letter-spacing: 2px; }
              .discount-text { color: #92400E; font-size: 14px; margin-top: 8px; }
              .urgency { color: #DC2626; font-weight: 600; }
              .benefit { display: flex; align-items: center; gap: 8px; margin: 12px 0; }
              .check { color: #10B981; font-size: 18px; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Welcome to ReviewResponder!</h1>
                <p>Your exclusive welcome offer is inside</p>
              </div>
              <div class="content">
                <p>Hi${user.business_name ? ' ' + user.business_name : ''}!</p>

                <p>Thanks for signing up! As a welcome gift, here's <strong>30% off</strong> your first month:</p>

                <div class="discount-box">
                  <div class="discount-code">WELCOME30</div>
                  <div class="discount-text">30% off Starter Plan ($29 â†’ <strong>$20.30/mo</strong>)</div>
                  <div class="discount-text urgency">Expires in 7 days</div>
                </div>

                <p><strong>What you get with ReviewResponder:</strong></p>

                <div class="benefit">
                  <span class="check">âœ“</span>
                  <span>AI responses in <strong>2 seconds</strong> (vs 5-10 min writing yourself)</span>
                </div>

                <div class="benefit">
                  <span class="check">âœ“</span>
                  <span>Works on Google, Yelp, TripAdvisor, Booking & more</span>
                </div>

                <div class="benefit">
                  <span class="check">âœ“</span>
                  <span>4 tone options: Professional, Friendly, Apologetic, Enthusiastic</span>
                </div>

                <div class="benefit">
                  <span class="check">âœ“</span>
                  <span>Chrome Extension for one-click responses</span>
                </div>

                <p style="margin-top: 24px;">You have <strong>20 free responses</strong> to try it. Love it? Use code <strong>WELCOME30</strong> at checkout.</p>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/dashboard" class="cta-button">Generate Your First Response â†’</a>
                </center>

                <p style="font-size: 14px; color: #6B7280;">Questions? Just reply to this email - I read every message.</p>

                <p>Best,<br>Berend<br><span style="font-size: 13px; color: #6B7280;">Founder, ReviewResponder</span></p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      2: {
        subject: 'Quick tip: Get better responses with business context',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .tip-box { background: #F0FDF4; border: 1px solid #10B981; padding: 20px; border-radius: 8px; margin: 20px 0; }
              .cta-button { display: inline-block; background: #10B981; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Pro Tip: Personalize Your Responses</h1>
              </div>
              <div class="content">
                <p>Hi${user.business_name ? ' ' + user.business_name : ''}!</p>

                <p>Here's a quick tip to get even better AI responses:</p>

                <div class="tip-box">
                  <h3 style="margin-top: 0;">Add Your Business Context</h3>
                  <p>Go to <strong>Settings</strong> and add details about your business. The AI will use this to create more personalized, relevant responses!</p>
                  <p style="margin-bottom: 0;"><em>Example: "Family-owned Italian restaurant since 1985, known for homemade pasta"</em></p>
                </div>

                <p>This helps the AI write responses that sound like you and mention what makes your business special.</p>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/settings" class="cta-button">Add Business Context â†’</a>
                </center>

                <p>Happy responding!</p>
                <p>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      5: {
        subject: "How's it going? Here's 50% off to upgrade",
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .discount-box { background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%); padding: 24px; border-radius: 8px; text-align: center; margin: 20px 0; }
              .discount-code { font-size: 28px; font-weight: bold; color: #D97706; font-family: monospace; }
              .cta-button { display: inline-block; background: #F59E0B; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Exclusive Offer Just For You!</h1>
              </div>
              <div class="content">
                <p>Hi${user.business_name ? ' ' + user.business_name : ''}!</p>

                <p>It's been 5 days since you joined ReviewResponder. How are you liking it so far?</p>

                <p>We're still in our early launch phase, and as a thank you for being an early adopter, here's an exclusive discount:</p>

                <div class="discount-box">
                  <p style="margin: 0 0 8px 0;">Use code</p>
                  <div class="discount-code">EARLY50</div>
                  <p style="margin: 8px 0 0 0;"><strong>50% OFF</strong> any paid plan - for your first year!</p>
                </div>

                <p>This means you can get:</p>
                <ul>
                  <li><strong>Starter Plan:</strong> $14.50/mo instead of $29/mo (300 responses)</li>
                  <li><strong>Pro Plan:</strong> $24.50/mo instead of $49/mo (800 responses + analytics)</li>
                  <li><strong>Unlimited:</strong> $49.50/mo instead of $99/mo (unlimited everything!)</li>
                </ul>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/claim/EARLY50" class="cta-button">Claim 50% Off â†’</a>
                </center>

                <p style="font-size: 14px; color: #6B7280;">This offer won't last forever - lock in this price while you can!</p>

                <p>Cheers,<br>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      10: {
        subject: 'Did you know? We auto-detect any language',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .feature-box { background: #EFF6FF; border-left: 4px solid #3B82F6; padding: 16px 20px; margin: 16px 0; }
              .cta-button { display: inline-block; background: #3B82F6; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Feature Spotlight: Multi-Language Support</h1>
              </div>
              <div class="content">
                <p>Hi${user.business_name ? ' ' + user.business_name : ''}!</p>

                <p>Did you know ReviewResponder can handle reviews in <strong>any language</strong>?</p>

                <div class="feature-box">
                  <strong>Auto-Detection:</strong> Paste a review in German, French, Spanish, Chinese - any language! The AI automatically detects it and responds in the same language.
                </div>

                <div class="feature-box">
                  <strong>Language Override:</strong> Want to respond in a specific language? Use the Language Selector dropdown to choose your preferred response language.
                </div>

                <p>This is perfect for:</p>
                <ul>
                  <li>ðŸ¨ Hotels with international guests</li>
                  <li>ðŸ½ï¸ Restaurants in tourist areas</li>
                  <li>ðŸª Online businesses with global customers</li>
                </ul>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/dashboard" class="cta-button">Try Multi-Language Responses â†’</a>
                </center>

                <p>Best,<br>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      20: {
        subject: "We'd love your feedback! (Quick 30-second survey)",
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #8B5CF6 0%, #6D28D9 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .cta-button { display: inline-block; background: #8B5CF6; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .question-box { background: #F5F3FF; border: 1px solid #8B5CF6; padding: 20px; border-radius: 8px; margin: 20px 0; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>How Are We Doing?</h1>
                <p>Your feedback helps us improve!</p>
              </div>
              <div class="content">
                <p>Hi${user.business_name ? ' ' + user.business_name : ''}!</p>

                <p>You've been using ReviewResponder for about 3 weeks now, and we'd love to hear from you!</p>

                <div class="question-box">
                  <p style="margin: 0;"><strong>Quick question:</strong> How likely are you to recommend ReviewResponder to a fellow business owner?</p>
                </div>

                <p>Your honest feedback helps us:</p>
                <ul>
                  <li>Build features you actually need</li>
                  <li>Fix any pain points</li>
                  <li>Make ReviewResponder even better</li>
                </ul>

                <p>Just reply to this email with your thoughts - it takes less than 30 seconds!</p>

                <p>Or if you're loving it, we'd be thrilled if you could leave a rating in the app. Happy customers make our day! ðŸŒŸ</p>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/dashboard" class="cta-button">Leave Feedback in App â†’</a>
                </center>

                <p>Thanks for being part of our journey!</p>
                <p>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
    };
    return templates[day] || null;
  };

  try {
    let sentCount = 0;
    let errorCount = 0;

    // Get all users who signed up and haven't received all drip emails
    for (const day of DRIP_SCHEDULE) {
      // Find users who:
      // 1. Signed up exactly 'day' days ago (or more, for catch-up)
      // 2. Haven't received this drip email yet
      // 3. Have a valid email
      const eligibleUsers = await dbQuery(
        `
        SELECT u.id, u.email, u.business_name, u.created_at
        FROM users u
        WHERE u.created_at <= NOW() - (INTERVAL '1 day' * $1)
          AND u.email IS NOT NULL
          AND u.email != ''
          AND NOT EXISTS (
            SELECT 1 FROM drip_emails d
            WHERE d.user_id = u.id AND d.email_day = $1
          )
        ORDER BY u.created_at DESC
        LIMIT 100
      `,
        [day]
      );

      for (const user of eligibleUsers.rows) {
        const emailContent = getDripEmail(day, user);
        if (!emailContent) continue;

        try {
          if (process.env.NODE_ENV === 'production') {
            await sendEmail({
              to: user.email,
              subject: emailContent.subject,
              html: emailContent.html,
              type: 'marketing',
              campaign: `drip_day_${day}`,
            });
          }

          // Record that we sent this email
          await dbQuery(
            'INSERT INTO drip_emails (user_id, email_day) VALUES ($1, $2) ON CONFLICT DO NOTHING',
            [user.id, day]
          );

          sentCount++;
          console.log(`[Email] Drip email day ${day} sent to ${user.email}`);
        } catch (emailError) {
          console.error(`Failed to send drip email to ${user.email}:`, emailError.message);
          errorCount++;
        }
      }
    }

    // Return minimal response for cron-job.org (has size limit)
    res.json({ ok: true, sent: sentCount, err: errorCount });
  } catch (error) {
    console.error('Drip email error:', error);
    // Minimal response for cron-job.org (has strict size limit)
    res.status(500).json({ ok: false, error: error.message?.slice(0, 100) });
  }
});

// Pre-Registration Drip Email Campaign - Nurture captured emails who haven't registered
// Call this endpoint via cron job (e.g., daily at 10am)
app.get('/api/cron/send-pre-registration-drips', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const DRIP_SCHEDULE = [1, 3, 7, 14]; // Days after email capture
  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  // Email templates for pre-registration nurturing
  const getPreRegistrationEmail = (day, email, discountCode) => {
    const templates = {
      1: {
        subject: 'Your 50% discount expires soon',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .discount-box { background: #FEF3C7; border: 2px dashed #F59E0B; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center; }
              .discount-code { font-size: 28px; font-weight: bold; color: #D97706; letter-spacing: 2px; }
              .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Don't Miss Your 50% Discount!</h1>
              </div>
              <div class="content">
                <p>Hi there!</p>

                <p>You showed interest in ReviewResponder yesterday. Just a quick reminder that your exclusive discount code is waiting:</p>

                <div class="discount-box">
                  <p style="margin: 0 0 10px 0; color: #92400E;">Your Exclusive Code:</p>
                  <div class="discount-code">${discountCode}</div>
                  <p style="margin: 10px 0 0 0; color: #92400E; font-size: 14px;">50% off your first month</p>
                </div>

                <p>With ReviewResponder, you can:</p>
                <ul>
                  <li>Respond to reviews in seconds, not minutes</li>
                  <li>Sound professional without the effort</li>
                  <li>Boost your local SEO with consistent engagement</li>
                </ul>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/register" class="cta-button">Claim Your 50% Discount</a>
                </center>

                <p>Questions? Just reply to this email!</p>

                <p>Best,<br>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      3: {
        subject: 'Why ignoring reviews costs you customers',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .stat-box { background: #FEF2F2; border-left: 4px solid #DC2626; padding: 16px; margin: 16px 0; }
              .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>The Hidden Cost of Unanswered Reviews</h1>
              </div>
              <div class="content">
                <p>Hi there!</p>

                <p>Did you know that ignoring reviews could be silently hurting your business?</p>

                <div class="stat-box">
                  <strong>53% of customers</strong> expect businesses to respond to negative reviews within a week. Only 37% of reviews ever get a response.
                </div>

                <div class="stat-box">
                  <strong>Businesses that respond</strong> to reviews see 12% higher revenue growth than those that don't.
                </div>

                <div class="stat-box">
                  <strong>89% of consumers</strong> read business responses to reviews before making a purchase decision.
                </div>

                <p>The problem? Responding to reviews takes time. Crafting the perfect response to a negative review can take 15-20 minutes.</p>

                <p><strong>ReviewResponder solves this.</strong> Get professional, personalized responses in seconds - not minutes.</p>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/register" class="cta-button">Try 20 Free Responses</a>
                </center>

                <p>Your discount code <strong>${discountCode}</strong> is still valid!</p>

                <p>Best,<br>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      7: {
        subject: 'How Mario saved 5 hours/week on reviews',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .testimonial { background: #F0FDF4; border: 1px solid #10B981; padding: 24px; border-radius: 8px; margin: 20px 0; font-style: italic; }
              .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Real Results from Real Businesses</h1>
              </div>
              <div class="content">
                <p>Hi there!</p>

                <p>Meet Mario, owner of a busy Italian restaurant in Munich with 200+ Google reviews.</p>

                <div class="testimonial">
                  "I used to spend Sunday evenings responding to the week's reviews. Now I do it in 10 minutes during my morning coffee. ReviewResponder doesn't just save time - it helped me sound more professional too. My responses went from 'Thanks!' to actually addressing what customers said."
                  <p style="margin: 16px 0 0 0; font-style: normal;"><strong>- Mario T., Restaurant Owner</strong></p>
                </div>

                <p><strong>Mario's results after 3 months:</strong></p>
                <ul>
                  <li>5+ hours saved per week</li>
                  <li>100% response rate (up from 30%)</li>
                  <li>4.2 to 4.6 star rating improvement</li>
                </ul>

                <p>You could see similar results. And with your discount code <strong>${discountCode}</strong>, you can start for just $14.50/month.</p>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/register" class="cta-button">Start Your Free Trial</a>
                </center>

                <p>Best,<br>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
      14: {
        subject: 'Last chance: Your exclusive offer expires tomorrow',
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: linear-gradient(135deg, #7C3AED 0%, #5B21B6 100%); color: white; padding: 40px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background: white; padding: 40px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
              .urgency-box { background: #FEF3C7; border: 2px solid #F59E0B; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center; }
              .cta-button { display: inline-block; background: #7C3AED; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
              .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Final Reminder</h1>
                <p>Your 50% discount expires tomorrow</p>
              </div>
              <div class="content">
                <p>Hi there!</p>

                <p>This is my last email about this - I promise!</p>

                <p>Two weeks ago, you showed interest in ReviewResponder. Since then, your competitors have probably responded to dozens of reviews while building their reputation.</p>

                <div class="urgency-box">
                  <p style="margin: 0; font-size: 18px;"><strong>Your code ${discountCode} expires tomorrow.</strong></p>
                  <p style="margin: 8px 0 0 0; color: #92400E;">After that, you'll pay full price.</p>
                </div>

                <p><strong>Quick recap of what you get:</strong></p>
                <ul>
                  <li>20 free responses to try (no credit card)</li>
                  <li>AI-powered professional responses in seconds</li>
                  <li>Works with Google, Yelp, TripAdvisor & more</li>
                  <li>Chrome extension for one-click responses</li>
                </ul>

                <center style="margin: 30px 0;">
                  <a href="${FRONTEND_URL}/register" class="cta-button">Use Your 50% Discount Now</a>
                </center>

                <p>If you have any questions, just reply to this email. I read every response.</p>

                <p>Best,<br>The ReviewResponder Team</p>
              </div>
              <div class="footer">
                <p>ReviewResponder - AI-Powered Review Responses</p>
                <p style="font-size: 12px; color: #9CA3AF;">This is the last email in this series. You won't receive more promotional emails from us.</p>
              </div>
            </div>
          </body>
          </html>
        `,
      },
    };
    return templates[day];
  };

  let sentCount = 0;
  let skippedCount = 0;
  let errorCount = 0;

  try {
    // Process each drip day
    for (const day of DRIP_SCHEDULE) {
      // Get captured emails that:
      // 1. Were captured X days ago (based on drip schedule)
      // 2. Haven't received this drip email yet
      // 3. Haven't converted (registered)
      const eligibleEmails = await dbAll(
        `
        SELECT ec.* FROM email_captures ec
        WHERE ec.converted = FALSE
          AND DATE(ec.created_at) = DATE(NOW() - INTERVAL '${day} days')
          AND NOT EXISTS (
            SELECT 1 FROM pre_registration_drips prd
            WHERE LOWER(prd.email) = LOWER(ec.email)
            AND prd.email_day = $1
          )
      `,
        [day]
      );

      for (const capture of eligibleEmails) {
        // Check if user has registered (email exists in users table)
        const existingUser = await dbGet('SELECT id FROM users WHERE LOWER(email) = LOWER($1)', [
          capture.email,
        ]);

        if (existingUser) {
          // User registered! Mark as converted and skip
          await dbQuery('UPDATE email_captures SET converted = TRUE WHERE id = $1', [capture.id]);
          skippedCount++;
          console.log(`â­ï¸ Pre-reg drip skipped (user registered): ${capture.email}`);
          continue;
        }

        const emailContent = getPreRegistrationEmail(day, capture.email, capture.discount_code);
        if (!emailContent) continue;

        try {
          await sendEmail({
            to: capture.email,
            subject: emailContent.subject,
            html: emailContent.html,
            type: 'marketing',
            campaign: `pre_reg_day_${day}`,
            replyTo: 'hello@tryreviewresponder.com',
          });

          // Track that we sent this email
          await dbQuery(
            'INSERT INTO pre_registration_drips (email, email_day) VALUES ($1, $2) ON CONFLICT DO NOTHING',
            [capture.email.toLowerCase(), day]
          );

          sentCount++;
          console.log(`[Email] Pre-reg drip day ${day} sent to ${capture.email}`);
        } catch (emailError) {
          console.error(`Failed to send pre-reg drip to ${capture.email}:`, emailError.message);
          errorCount++;
        }
      }
    }

    res.json({ ok: true, sent: sentCount, skipped: skippedCount, err: errorCount });
  } catch (error) {
    console.error('Pre-registration drip error:', error);
    res.status(500).json({ ok: false, error: error.message?.slice(0, 100) });
  }
});

// Test endpoint: Send a specific pre-registration drip email
// GET /api/admin/test-pre-reg-drip?email=test@example.com&day=1&key=ADMIN_SECRET
app.get('/api/admin/test-pre-reg-drip', async (req, res) => {
  const { email, day, key } = req.query;

  if (!safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!email || !day) {
    return res.status(400).json({ error: 'email and day parameters required' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';
  const discountCode = 'EARLY50';
  const dayNum = parseInt(day);

  const templates = {
    1: {
      subject: 'Your 50% discount expires soon',
      html: `<!DOCTYPE html><html><head><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#111827;line-height:1.6}.container{max-width:600px;margin:0 auto;padding:20px}.header{background:linear-gradient(135deg,#4F46E5 0%,#7C3AED 100%);color:white;padding:40px;text-align:center;border-radius:8px 8px 0 0}.content{background:white;padding:40px;border:1px solid #E5E7EB;border-radius:0 0 8px 8px}.discount-box{background:#FEF3C7;border:2px dashed #F59E0B;padding:20px;border-radius:8px;margin:20px 0;text-align:center}.discount-code{font-size:28px;font-weight:bold;color:#D97706;letter-spacing:2px}.cta-button{display:inline-block;background:#4F46E5;color:white;padding:14px 28px;text-decoration:none;border-radius:6px;font-weight:600}.footer{text-align:center;padding:20px;color:#6B7280;font-size:14px}</style></head><body><div class="container"><div class="header"><h1>Don't Miss Your 50% Discount!</h1></div><div class="content"><p>Hi there!</p><p>You showed interest in ReviewResponder yesterday. Just a quick reminder that your exclusive discount code is waiting:</p><div class="discount-box"><p style="margin:0 0 10px 0;color:#92400E">Your Exclusive Code:</p><div class="discount-code">${discountCode}</div><p style="margin:10px 0 0 0;color:#92400E;font-size:14px">50% off your first month</p></div><p>With ReviewResponder, you can:</p><ul><li>Respond to reviews in seconds, not minutes</li><li>Sound professional without the effort</li><li>Boost your local SEO with consistent engagement</li></ul><center style="margin:30px 0"><a href="${FRONTEND_URL}/register" class="cta-button">Claim Your 50% Discount</a></center><p>Questions? Just reply to this email!</p><p>Best,<br>The ReviewResponder Team</p></div><div class="footer"><p>ReviewResponder - AI-Powered Review Responses</p></div></div></body></html>`,
    },
    3: {
      subject: 'Why ignoring reviews costs you customers',
      html: `<!DOCTYPE html><html><head><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#111827;line-height:1.6}.container{max-width:600px;margin:0 auto;padding:20px}.header{background:linear-gradient(135deg,#DC2626 0%,#B91C1C 100%);color:white;padding:40px;text-align:center;border-radius:8px 8px 0 0}.content{background:white;padding:40px;border:1px solid #E5E7EB;border-radius:0 0 8px 8px}.stat-box{background:#FEF2F2;border-left:4px solid #DC2626;padding:16px;margin:16px 0}.cta-button{display:inline-block;background:#4F46E5;color:white;padding:14px 28px;text-decoration:none;border-radius:6px;font-weight:600}.footer{text-align:center;padding:20px;color:#6B7280;font-size:14px}</style></head><body><div class="container"><div class="header"><h1>The Hidden Cost of Unanswered Reviews</h1></div><div class="content"><p>Hi there!</p><p>Did you know that ignoring reviews could be silently hurting your business?</p><div class="stat-box"><strong>53% of customers</strong> expect businesses to respond to negative reviews within a week.</div><div class="stat-box"><strong>Businesses that respond</strong> to reviews see 12% higher revenue growth.</div><div class="stat-box"><strong>89% of consumers</strong> read business responses before making a purchase decision.</div><p>The problem? Responding to reviews takes time. Crafting the perfect response can take 15-20 minutes.</p><p><strong>ReviewResponder solves this.</strong> Get professional responses in seconds.</p><center style="margin:30px 0"><a href="${FRONTEND_URL}/register" class="cta-button">Try 20 Free Responses</a></center><p>Your discount code <strong>${discountCode}</strong> is still valid!</p><p>Best,<br>The ReviewResponder Team</p></div><div class="footer"><p>ReviewResponder - AI-Powered Review Responses</p></div></div></body></html>`,
    },
    7: {
      subject: 'How Mario saved 5 hours/week on reviews',
      html: `<!DOCTYPE html><html><head><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#111827;line-height:1.6}.container{max-width:600px;margin:0 auto;padding:20px}.header{background:linear-gradient(135deg,#10B981 0%,#059669 100%);color:white;padding:40px;text-align:center;border-radius:8px 8px 0 0}.content{background:white;padding:40px;border:1px solid #E5E7EB;border-radius:0 0 8px 8px}.testimonial{background:#F0FDF4;border:1px solid #10B981;padding:24px;border-radius:8px;margin:20px 0;font-style:italic}.cta-button{display:inline-block;background:#4F46E5;color:white;padding:14px 28px;text-decoration:none;border-radius:6px;font-weight:600}.footer{text-align:center;padding:20px;color:#6B7280;font-size:14px}</style></head><body><div class="container"><div class="header"><h1>Real Results from Real Businesses</h1></div><div class="content"><p>Hi there!</p><p>Meet Mario, owner of a busy Italian restaurant in Munich with 200+ Google reviews.</p><div class="testimonial">"I used to spend Sunday evenings responding to the week's reviews. Now I do it in 10 minutes during my morning coffee. ReviewResponder doesn't just save time - it helped me sound more professional too."<p style="margin:16px 0 0 0;font-style:normal"><strong>- Mario T., Restaurant Owner</strong></p></div><p><strong>Mario's results after 3 months:</strong></p><ul><li>5+ hours saved per week</li><li>100% response rate (up from 30%)</li><li>4.2 to 4.6 star rating improvement</li></ul><p>With your discount code <strong>${discountCode}</strong>, you can start for just $14.50/month.</p><center style="margin:30px 0"><a href="${FRONTEND_URL}/register" class="cta-button">Start Your Free Trial</a></center><p>Best,<br>The ReviewResponder Team</p></div><div class="footer"><p>ReviewResponder - AI-Powered Review Responses</p></div></div></body></html>`,
    },
    14: {
      subject: 'Last chance: Your exclusive offer expires tomorrow',
      html: `<!DOCTYPE html><html><head><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#111827;line-height:1.6}.container{max-width:600px;margin:0 auto;padding:20px}.header{background:linear-gradient(135deg,#7C3AED 0%,#5B21B6 100%);color:white;padding:40px;text-align:center;border-radius:8px 8px 0 0}.content{background:white;padding:40px;border:1px solid #E5E7EB;border-radius:0 0 8px 8px}.urgency-box{background:#FEF3C7;border:2px solid #F59E0B;padding:20px;border-radius:8px;margin:20px 0;text-align:center}.cta-button{display:inline-block;background:#7C3AED;color:white;padding:14px 28px;text-decoration:none;border-radius:6px;font-weight:600}.footer{text-align:center;padding:20px;color:#6B7280;font-size:14px}</style></head><body><div class="container"><div class="header"><h1>Final Reminder</h1><p>Your 50% discount expires tomorrow</p></div><div class="content"><p>Hi there!</p><p>This is my last email about this - I promise!</p><p>Two weeks ago, you showed interest in ReviewResponder. Since then, your competitors have probably responded to dozens of reviews.</p><div class="urgency-box"><p style="margin:0;font-size:18px"><strong>Your code ${discountCode} expires tomorrow.</strong></p><p style="margin:8px 0 0 0;color:#92400E">After that, you'll pay full price.</p></div><p><strong>Quick recap:</strong></p><ul><li>20 free responses to try (no credit card)</li><li>AI-powered professional responses in seconds</li><li>Works with Google, Yelp, TripAdvisor & more</li><li>Chrome extension for one-click responses</li></ul><center style="margin:30px 0"><a href="${FRONTEND_URL}/register" class="cta-button">Use Your 50% Discount Now</a></center><p>Best,<br>The ReviewResponder Team</p></div><div class="footer"><p>ReviewResponder - AI-Powered Review Responses</p><p style="font-size:12px;color:#9CA3AF">This is the last email in this series.</p></div></div></body></html>`,
    },
  };

  const template = templates[dayNum];
  if (!template) {
    return res.status(400).json({ error: 'Invalid day. Use 1, 3, 7, or 14' });
  }

  try {
    await resend.emails.send({
      from: FROM_EMAIL,
      replyTo: 'hello@tryreviewresponder.com',
      to: email,
      subject: `[TEST] ${template.subject}`,
      html: template.html,
    });

    console.log(`ðŸ§ª Test pre-reg drip day ${dayNum} sent to ${email}`);
    res.json({ success: true, message: `Test email day ${dayNum} sent to ${email}` });
  } catch (error) {
    console.error('Test email error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Test new conversion emails (flash offer, checkout abandonment)
app.get('/api/admin/test-conversion-email', async (req, res) => {
  const { email, type, key } = req.query;

  if (!safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!email || !type) {
    return res.status(400).json({ error: 'email and type (flash_offer|checkout_abandonment) required' });
  }

  // Create a mock user for testing
  const mockUser = {
    email,
    business_name: 'Test Business',
    subscription_plan: 'free',
  };

  let sent = false;
  if (type === 'flash_offer') {
    sent = await sendFlashOfferEmail(mockUser);
  } else if (type === 'checkout_abandonment') {
    sent = await sendCheckoutAbandonmentEmail(mockUser, 'starter');
  } else {
    return res.status(400).json({ error: 'Invalid type. Use flash_offer or checkout_abandonment' });
  }

  if (sent) {
    res.json({ success: true, message: `${type} email sent to ${email}` });
  } else {
    res.status(500).json({ error: 'Failed to send email - check logs' });
  }
});

// =============================================================================
// ONBOARDING EMAIL SEQUENCE - Activate registered users who haven't used product
// =============================================================================
app.all('/api/cron/onboarding-emails', async (req, res) => {
  // Accept both header and query parameter for secret
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret || req.query.key;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  try {
    // Create onboarding_emails table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS onboarding_emails (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        email_day INTEGER NOT NULL,
        sent_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(user_id, email_day)
      )
    `);

    // Find users with responses_used = 0 (never used the product)
    const inactiveUsers = await dbQuery(`
      SELECT u.id, u.email, u.business_name, u.created_at,
             EXTRACT(DAY FROM NOW() - u.created_at) as days_since_signup
      FROM users u
      WHERE u.responses_used = 0
        AND u.email IS NOT NULL
        AND u.email_verified = true
      ORDER BY u.created_at DESC
      LIMIT 100
    `);

    console.log(`ðŸ“§ Onboarding: Found ${inactiveUsers.rows.length} inactive users`);

    let sentCount = 0;
    let skippedCount = 0;
    const results = [];

    for (const user of inactiveUsers.rows) {
      const daysSinceSignup = Math.floor(user.days_since_signup || 0);

      // Determine which email day to send (0, 1, 3, or 7)
      let emailDay = null;
      if (daysSinceSignup >= 7) emailDay = 7;
      else if (daysSinceSignup >= 3) emailDay = 3;
      else if (daysSinceSignup >= 1) emailDay = 1;
      else emailDay = 0;

      // Check if we already sent this day's email
      const alreadySent = await dbGet(`
        SELECT id FROM onboarding_emails
        WHERE user_id = $1 AND email_day = $2
      `, [user.id, emailDay]);

      if (alreadySent) {
        skippedCount++;
        continue;
      }

      // Check parallel-safe: was email recently sent?
      if (await wasEmailRecentlySent(user.email, 'onboarding')) {
        skippedCount++;
        continue;
      }

      // Build email content based on day
      let subject, html;
      const extensionUrl = `${FRONTEND_URL}/extension`;
      const dashboardUrl = `${FRONTEND_URL}/dashboard`;

      if (emailDay === 0) {
        subject = "Welcome! Here's how to respond to your first review in 30 seconds";
        html = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2 style="color: #1e3a5f;">Welcome to ReviewResponder! ðŸŽ‰</h2>
            <p>You just took the first step to never stress about review responses again.</p>
            <p><strong>Here's how to get started in 30 seconds:</strong></p>
            <ol>
              <li><a href="${extensionUrl}" style="color: #3b82f6;">Install our Chrome Extension</a> (free)</li>
              <li>Go to any review on Google Maps, Yelp, or TripAdvisor</li>
              <li>Click the ReviewResponder button â†’ Done!</li>
            </ol>
            <p style="margin-top: 20px;">
              <a href="${extensionUrl}" style="background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                Get Chrome Extension
              </a>
            </p>
            <p style="color: #666; font-size: 14px; margin-top: 30px;">
              Need help? Just reply to this email.
            </p>
            <p style="color: #999; font-size: 12px;">- The ReviewResponder Team</p>
          </body>
          </html>
        `;
      } else if (emailDay === 1) {
        subject = "Your Chrome Extension is waiting";
        html = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2 style="color: #1e3a5f;">Quick reminder ðŸ‘‹</h2>
            <p>You signed up for ReviewResponder yesterday but haven't installed the Chrome Extension yet.</p>
            <p>The extension works on:</p>
            <ul>
              <li>âœ… Google Maps</li>
              <li>âœ… Yelp</li>
              <li>âœ… TripAdvisor</li>
              <li>âœ… Booking.com</li>
              <li>âœ… Facebook</li>
              <li>âœ… Trustpilot</li>
            </ul>
            <p style="margin-top: 20px;">
              <a href="${extensionUrl}" style="background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                Install Extension (30 seconds)
              </a>
            </p>
            <p style="color: #666; font-size: 14px; margin-top: 30px;">
              Already installed? <a href="${dashboardUrl}">Go to your dashboard</a> to generate responses.
            </p>
          </body>
          </html>
        `;
      } else if (emailDay === 3) {
        subject = "5 reviews are waiting for your response";
        html = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2 style="color: #1e3a5f;">Your reviews need attention ðŸ“</h2>
            <p>Studies show that businesses that respond to reviews get:</p>
            <ul>
              <li>ðŸ“ˆ <strong>9% more revenue</strong> on average</li>
              <li>â­ <strong>Higher ratings</strong> over time</li>
              <li>ðŸ’¬ <strong>More customer engagement</strong></li>
            </ul>
            <p>Every day without a response is a missed opportunity.</p>
            <p style="margin-top: 20px;">
              <a href="${extensionUrl}" style="background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                Start Responding Now
              </a>
            </p>
            <p style="color: #666; font-size: 14px; margin-top: 30px;">
              Takes just 3 seconds per review with our AI.
            </p>
          </body>
          </html>
        `;
      } else if (emailDay === 7) {
        subject = "Did you know? Businesses that respond get 9% more revenue";
        html = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2 style="color: #1e3a5f;">Last chance to activate your account</h2>
            <p>Hey,</p>
            <p>You signed up for ReviewResponder a week ago but haven't generated any responses yet.</p>
            <p>I get it - we're all busy. But here's the thing:</p>
            <blockquote style="border-left: 3px solid #3b82f6; padding-left: 15px; margin: 20px 0; color: #555;">
              "According to Harvard Business Review, responding to reviews can increase revenue by 9%."
            </blockquote>
            <p>Our users save 5-10 hours per week on review responses.</p>
            <p style="margin-top: 20px;">
              <a href="${extensionUrl}" style="background: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                Activate Your Free Account
              </a>
            </p>
            <p style="color: #666; font-size: 14px; margin-top: 30px;">
              If you have any questions, just hit reply. I read every email.
            </p>
            <p style="color: #999; font-size: 12px;">- Berend, Founder of ReviewResponder</p>
          </body>
          </html>
        `;
      }

      // Send email
      try {
        if (process.env.NODE_ENV === 'production') {
          await resend.emails.send({
            from: FROM_EMAIL,
            to: user.email,
            subject,
            html,
          });
        }

        // Record in onboarding_emails table
        await dbQuery(`
          INSERT INTO onboarding_emails (user_id, email_day)
          VALUES ($1, $2)
          ON CONFLICT (user_id, email_day) DO NOTHING
        `, [user.id, emailDay]);

        // Record for parallel-safety
        await recordEmailSend(user.email, 'onboarding');

        sentCount++;
        results.push({
          email: user.email,
          day: emailDay,
          status: 'sent'
        });

        console.log(`ðŸ“§ Onboarding Day ${emailDay} sent to ${user.email}`);
      } catch (emailError) {
        console.error(`Failed to send onboarding email to ${user.email}:`, emailError.message);
        results.push({
          email: user.email,
          day: emailDay,
          status: 'error',
          error: emailError.message
        });
      }
    }

    res.json({
      success: true,
      message: `Onboarding emails: ${sentCount} sent, ${skippedCount} skipped`,
      total_inactive_users: inactiveUsers.rows.length,
      sent: sentCount,
      skipped: skippedCount,
      results
    });

  } catch (error) {
    console.error('Onboarding email error:', error);
    res.status(500).json({ error: error.message });
  }
});

// =============================================================================
// REVIEW ALERTS - Notify users about new reviews on their business
// =============================================================================
app.all('/api/cron/review-alerts', async (req, res) => {
  // Accept both header and query parameter for secret
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret || req.query.key;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  try {
    // Create user_review_cache table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS user_review_cache (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        google_place_id TEXT,
        last_review_ids JSONB DEFAULT '[]',
        last_checked_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(user_id, google_place_id)
      )
    `);

    // Ensure google_place_id column exists on tables (migration fix)
    try {
      await dbQuery(`ALTER TABLE linkedin_outreach ADD COLUMN IF NOT EXISTS google_place_id TEXT`);
    } catch (e) { console.log('linkedin_outreach migration:', e.message); }
    try {
      await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS google_place_id TEXT`);
    } catch (e) { console.log('outreach_leads migration:', e.message); }
    try {
      await dbQuery(`ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS google_place_id TEXT`);
    } catch (e) { console.log('demo_generations migration:', e.message); }

    // Find users with business_name set (they have a business to monitor)
    const usersWithBusiness = await dbQuery(`
      SELECT u.id, u.email, u.business_name
      FROM users u
      WHERE u.business_name IS NOT NULL
        AND u.business_name != ''
        AND u.email IS NOT NULL
        AND u.email_verified = true
      LIMIT 50
    `);

    console.log(`ðŸ”” Review Alerts: Found ${usersWithBusiness.rows.length} users with business`);

    let alertsSent = 0;
    let reviewsFound = 0;
    const results = [];

    for (const user of usersWithBusiness.rows) {
      try {
        // Check if we already checked in last 24 hours
        const cachedEntry = await dbGet(`
          SELECT * FROM user_review_cache
          WHERE user_id = $1
            AND last_checked_at > NOW() - INTERVAL '24 hours'
        `, [user.id]);

        if (cachedEntry) {
          results.push({
            user: user.email,
            status: 'skipped',
            reason: 'checked_recently'
          });
          continue;
        }

        // Lookup Place ID for business - first check our existing data, then Google API
        let placeId = null;
        let businessData = null;

        // 1. First try to find Place ID from demo_generations (we already have it!)
        try {
          const demoWithPlaceId = await dbGet(`
            SELECT google_place_id, business_name FROM demo_generations
            WHERE business_name ILIKE $1 AND google_place_id IS NOT NULL
            ORDER BY created_at DESC LIMIT 1
          `, [`%${user.business_name}%`]);

          if (demoWithPlaceId?.google_place_id) {
            placeId = demoWithPlaceId.google_place_id;
            console.log(`ðŸ”” Found Place ID from demo_generations for ${user.business_name}`);
          }
        } catch (e) { /* Column might not exist yet */ }

        // 2. Try linkedin_outreach if not found
        if (!placeId) {
          try {
            const linkedinWithPlaceId = await dbGet(`
              SELECT google_place_id, business_name FROM linkedin_outreach
              WHERE business_name ILIKE $1 AND google_place_id IS NOT NULL
              ORDER BY created_at DESC LIMIT 1
            `, [`%${user.business_name}%`]);

            if (linkedinWithPlaceId?.google_place_id) {
              placeId = linkedinWithPlaceId.google_place_id;
              console.log(`ðŸ”” Found Place ID from linkedin_outreach for ${user.business_name}`);
            }
          } catch (e) { /* Column might not exist yet */ }
        }

        // 3. Try outreach_leads if not found
        if (!placeId) {
          try {
            const leadWithPlaceId = await dbGet(`
              SELECT google_place_id, business_name FROM outreach_leads
              WHERE business_name ILIKE $1 AND google_place_id IS NOT NULL
              ORDER BY created_at DESC LIMIT 1
            `, [`%${user.business_name}%`]);

            if (leadWithPlaceId?.google_place_id) {
              placeId = leadWithPlaceId.google_place_id;
              console.log(`ðŸ”” Found Place ID from outreach_leads for ${user.business_name}`);
            }
          } catch (e) { /* Column might not exist yet */ }
        }

        // 4. Fallback: Try Google Places API (costs credits)
        if (!placeId && process.env.GOOGLE_API_KEY) {
          try {
            const searchUrl = `https://maps.googleapis.com/maps/api/place/findplacefromtext/json?input=${encodeURIComponent(user.business_name)}&inputtype=textquery&fields=place_id,name,formatted_address&key=${process.env.GOOGLE_API_KEY}`;
            const searchResponse = await fetch(searchUrl);
            const searchData = await searchResponse.json();

            if (searchData.candidates && searchData.candidates.length > 0) {
              placeId = searchData.candidates[0].place_id;
              businessData = searchData.candidates[0];
              console.log(`ðŸ”” Found Place ID from Google API for ${user.business_name}`);
            }
          } catch (googleError) {
            console.error(`Google Places lookup failed for ${user.business_name}:`, googleError.message);
          }
        }

        if (!placeId) {
          results.push({
            user: user.email,
            business: user.business_name,
            status: 'skipped',
            reason: 'no_place_id'
          });
          continue;
        }

        // Get reviews using demo_generations (we already have them!) or Google API
        let reviews = [];

        // First check demo_generations for scraped reviews
        const demoReviews = await dbGet(`
          SELECT scraped_reviews FROM demo_generations
          WHERE google_place_id = $1
            AND scraped_reviews IS NOT NULL
          ORDER BY created_at DESC LIMIT 1
        `, [placeId]);

        if (demoReviews?.scraped_reviews && Array.isArray(demoReviews.scraped_reviews)) {
          reviews = demoReviews.scraped_reviews.slice(0, 5);
          console.log(`ðŸ”” Found ${reviews.length} reviews from demo_generations for ${placeId}`);
        } else if (process.env.GOOGLE_API_KEY) {
          // Fallback to Google Places API (limited to 5 reviews)
          try {
            const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=reviews&key=${process.env.GOOGLE_API_KEY}`;
            const detailsResponse = await fetch(detailsUrl);
            const detailsData = await detailsResponse.json();

            if (detailsData.result && detailsData.result.reviews) {
              reviews = detailsData.result.reviews.slice(0, 5);
            }
          } catch (apiError) {
            console.error(`Google Places details failed for ${placeId}:`, apiError.message);
          }
        }

        if (reviews.length === 0) {
          results.push({
            user: user.email,
            business: user.business_name,
            status: 'skipped',
            reason: 'no_reviews_found'
          });
          continue;
        }

        reviewsFound += reviews.length;

        // Get cached review IDs
        const userCache = await dbGet(`
          SELECT last_review_ids FROM user_review_cache
          WHERE user_id = $1 AND google_place_id = $2
        `, [user.id, placeId]);

        const cachedReviewIds = userCache?.last_review_ids || [];

        // Find new reviews (not in cache)
        const currentReviewIds = reviews.map(r => r.author_name + '_' + (r.time || r.relative_time_description));
        const newReviews = reviews.filter(r => {
          const reviewId = r.author_name + '_' + (r.time || r.relative_time_description);
          return !cachedReviewIds.includes(reviewId);
        });

        // Update cache
        await dbQuery(`
          INSERT INTO user_review_cache (user_id, google_place_id, last_review_ids, last_checked_at)
          VALUES ($1, $2, $3, NOW())
          ON CONFLICT (user_id, google_place_id)
          DO UPDATE SET last_review_ids = $3, last_checked_at = NOW()
        `, [user.id, placeId, JSON.stringify(currentReviewIds)]);

        // If we have new reviews, send alert
        if (newReviews.length > 0 && cachedReviewIds.length > 0) {
          // Only send alerts if this isn't the first check (we have cached IDs)
          const review = newReviews[0]; // Most recent new review
          const rating = review.rating || 5;
          const ratingStars = 'â­'.repeat(rating);
          const reviewSnippet = (review.text || '').slice(0, 150) + ((review.text || '').length > 150 ? '...' : '');
          const reviewerName = review.author_name || 'A customer';

          const subject = `New ${rating}-star review on Google - respond now?`;
          const html = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #1e3a5f;">New Review Alert! ${ratingStars}</h2>
              <p>Your business <strong>${user.business_name}</strong> just received a new ${rating}-star review:</p>
              <blockquote style="border-left: 3px solid ${rating >= 4 ? '#10b981' : '#ef4444'}; padding: 15px; margin: 20px 0; background: #f9fafb; color: #333;">
                "${reviewSnippet}"
                <br><br>
                <em style="color: #666;">- ${reviewerName}</em>
              </blockquote>
              <p>Respond quickly to show customers you care!</p>
              <p style="margin-top: 20px;">
                <a href="${FRONTEND_URL}/dashboard" style="background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                  Respond Now (3 seconds)
                </a>
              </p>
              <p style="color: #666; font-size: 14px; margin-top: 30px;">
                Tip: Use our Chrome Extension to respond directly on Google Maps!
              </p>
            </body>
            </html>
          `;

          // Check parallel-safe
          if (await wasEmailRecentlySent(user.email, 'review_alert')) {
            results.push({
              user: user.email,
              business: user.business_name,
              status: 'skipped',
              reason: 'email_recently_sent'
            });
            continue;
          }

          // Send alert email
          if (process.env.NODE_ENV === 'production') {
            await resend.emails.send({
              from: FROM_EMAIL,
              to: user.email,
              subject,
              html,
            });
          }

          await recordEmailSend(user.email, 'review_alert');
          alertsSent++;

          results.push({
            user: user.email,
            business: user.business_name,
            status: 'alert_sent',
            new_reviews: newReviews.length,
            rating: rating
          });

          console.log(`ðŸ”” Review Alert sent to ${user.email} for ${user.business_name} (${rating} stars)`);
        } else {
          results.push({
            user: user.email,
            business: user.business_name,
            status: 'no_new_reviews',
            total_reviews: reviews.length,
            is_first_check: cachedReviewIds.length === 0
          });
        }

      } catch (userError) {
        console.error(`Review alert error for ${user.email}:`, userError.message);
        results.push({
          user: user.email,
          business: user.business_name,
          status: 'error',
          error: userError.message
        });
      }
    }

    res.json({
      success: true,
      message: `Review alerts: ${alertsSent} sent, ${reviewsFound} reviews checked`,
      users_checked: usersWithBusiness.rows.length,
      alerts_sent: alertsSent,
      reviews_found: reviewsFound,
      results
    });

  } catch (error) {
    console.error('Review alerts error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin endpoint: Get inactive users for Night-Blast Phase 6
app.get('/api/admin/inactive-users', async (req, res) => {
  const { key } = req.query;
  if (!safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const users = await dbQuery(`
      SELECT
        u.id,
        u.email,
        u.business_name,
        u.created_at,
        u.responses_used,
        EXTRACT(DAY FROM NOW() - u.created_at) as days_since_signup,
        (SELECT MAX(email_day) FROM onboarding_emails oe WHERE oe.user_id = u.id) as last_onboarding_day
      FROM users u
      WHERE u.responses_used = 0
        AND u.email IS NOT NULL
      ORDER BY u.created_at DESC
      LIMIT 100
    `);

    res.json({
      success: true,
      count: users.rows.length,
      users: users.rows
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Admin endpoint: Get users for review alerts (Night-Blast Phase 7)
app.get('/api/admin/users-for-review-alerts', async (req, res) => {
  const { key } = req.query;
  if (!safeCompare(key, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const users = await dbQuery(`
      SELECT
        u.id,
        u.email,
        u.business_name,
        u.created_at,
        u.responses_used,
        (SELECT last_checked_at FROM user_review_cache urc WHERE urc.user_id = u.id LIMIT 1) as last_review_check
      FROM users u
      WHERE u.business_name IS NOT NULL
        AND u.business_name != ''
        AND u.email IS NOT NULL
      ORDER BY u.created_at DESC
      LIMIT 100
    `);

    res.json({
      success: true,
      count: users.rows.length,
      users: users.rows
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Weekly Summary Email Campaign - Send weekly stats to users who opted in
// Call this endpoint via cron job (e.g., every Monday at 9am)
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/send-weekly-summary', async (req, res) => {
  // Accept both header and query parameter for secret
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const FRONTEND_URL = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';

  try {
    // Get all users who have weekly summary enabled and have used the service
    const users = await dbQuery(`
      SELECT u.*,
        (SELECT COUNT(*) FROM responses r WHERE r.user_id = u.id AND r.created_at > NOW() - INTERVAL '7 days') as responses_this_week,
        (SELECT COUNT(*) FROM responses r WHERE r.user_id = u.id AND r.created_at > NOW() - INTERVAL '14 days' AND r.created_at <= NOW() - INTERVAL '7 days') as responses_last_week
      FROM users u
      WHERE u.email_weekly_summary = true
        AND u.email_verified = true
        AND (SELECT COUNT(*) FROM responses r WHERE r.user_id = u.id) > 0
    `);

    let sentCount = 0;
    let errorCount = 0;

    for (const user of users.rows) {
      const weeklyResponses = parseInt(user.responses_this_week) || 0;
      const lastWeekResponses = parseInt(user.responses_last_week) || 0;
      const change = weeklyResponses - lastWeekResponses;
      const changeText = change > 0 ? `+${change}` : change.toString();
      const changeColor = change >= 0 ? '#10B981' : '#EF4444';

      // Skip if no activity this week and last week
      if (weeklyResponses === 0 && lastWeekResponses === 0) continue;

      try {
        if (process.env.NODE_ENV === 'production') {
          await resend.emails.send({
            from: FROM_EMAIL,
            to: user.email,
            subject: `Your weekly review response summary`,
            html: `
              <!DOCTYPE html>
              <html>
              <head>
                <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #111827; line-height: 1.6; }
                  .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                  .header { background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
                  .content { background: white; padding: 30px; border: 1px solid #E5E7EB; border-radius: 0 0 8px 8px; }
                  .stat-box { background: #F9FAFB; border: 1px solid #E5E7EB; padding: 20px; border-radius: 8px; margin: 15px 0; text-align: center; }
                  .stat-number { font-size: 36px; font-weight: bold; color: #4F46E5; }
                  .stat-label { color: #6B7280; font-size: 14px; }
                  .cta-button { display: inline-block; background: #4F46E5; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }
                  .footer { text-align: center; padding: 20px; color: #6B7280; font-size: 14px; }
                  .tip-box { background: #EEF2FF; border-left: 4px solid #4F46E5; padding: 15px; margin: 20px 0; }
                </style>
              </head>
              <body>
                <div class="container">
                  <div class="header">
                    <h1>Weekly Summary</h1>
                    <p>Your ReviewResponder stats for this week</p>
                  </div>
                  <div class="content">
                    <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>

                    <p>Here's how you did this week:</p>

                    <div class="stat-box">
                      <div class="stat-number">${weeklyResponses}</div>
                      <div class="stat-label">Responses Generated This Week</div>
                      <div style="color: ${changeColor}; font-weight: 600; margin-top: 5px;">${changeText} vs last week</div>
                    </div>

                    <div class="tip-box">
                      <strong>Pro Tip:</strong> ${
                        weeklyResponses > 0
                          ? 'Great job staying on top of your reviews! Consistent responses help build customer trust and improve your online reputation.'
                          : "Don't let reviews pile up! Responding quickly shows customers you care about their feedback."
                      }
                    </div>

                    <p style="text-align: center; margin: 30px 0;">
                      <a href="${FRONTEND_URL}/dashboard" class="cta-button">View Full Analytics</a>
                    </p>
                  </div>
                  <div class="footer">
                    <p>ReviewResponder - AI-Powered Review Responses</p>
                    <p><a href="${FRONTEND_URL}/profile" style="color: #6B7280;">Unsubscribe from weekly summary</a></p>
                  </div>
                </div>
              </body>
              </html>
            `,
          });
        }

        sentCount++;
        console.log(`Weekly summary sent to ${user.email}`);
      } catch (emailError) {
        console.error(`Failed to send weekly summary to ${user.email}:`, emailError.message);
        errorCount++;
      }
    }

    // Return minimal response for cron-job.org (has size limit)
    res.json({ ok: true, sent: sentCount, err: errorCount });
  } catch (error) {
    console.error('Weekly summary error:', error);
    res.status(500).json({ error: 'Failed to process weekly summary emails' });
  }
});

// ============ ADMIN ENDPOINTS ============

// Rate limiter for admin endpoints (50 attempts per 15 minutes per IP)
const adminRateLimiter = new Map();
const ADMIN_RATE_LIMIT = 50;
const ADMIN_RATE_WINDOW = 15 * 60 * 1000; // 15 minutes

const checkAdminRateLimit = ip => {
  const now = Date.now();
  const record = adminRateLimiter.get(ip);

  if (!record || now - record.windowStart > ADMIN_RATE_WINDOW) {
    adminRateLimiter.set(ip, { windowStart: now, attempts: 1 });
    return true;
  }

  if (record.attempts >= ADMIN_RATE_LIMIT) {
    return false;
  }

  record.attempts++;
  return true;
};

// Timing-safe key comparison
const safeCompare = (a, b) => {
  if (!a || !b) return false;
  const bufA = Buffer.from(a);
  const bufB = Buffer.from(b);
  if (bufA.length !== bufB.length) {
    // Still do comparison to prevent timing attacks on length
    crypto.timingSafeEqual(bufA, Buffer.alloc(bufA.length));
    return false;
  }
  return crypto.timingSafeEqual(bufA, bufB);
};

// GET /api/admin/set-plan - Set user plan (for testing via browser)
app.get('/api/admin/set-plan', async (req, res) => {
  const ip = req.ip || req.connection.remoteAddress;

  if (!checkAdminRateLimit(ip)) {
    return res.status(429).json({ error: 'Too many attempts. Try again in 15 minutes.' });
  }

  const { email, plan, key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret) {
    return res.status(500).json({ error: 'Admin endpoint not configured' });
  }

  if (!safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email || !email.includes('@')) {
    return res.status(400).json({ error: 'Valid email required' });
  }

  // Use PLAN_LIMITS for consistency
  const targetPlan = plan || 'unlimited';
  if (!PLAN_LIMITS[targetPlan]) {
    return res
      .status(400)
      .json({ error: 'Invalid plan. Use: free, starter, professional, unlimited' });
  }

  const planConfig = {
    status: targetPlan === 'free' ? 'inactive' : 'active',
    limit: PLAN_LIMITS[targetPlan].responses,
  };

  try {
    const user = await dbGet(
      'SELECT id, email, subscription_plan FROM users WHERE LOWER(email) = LOWER($1)',
      [email]
    );

    if (!user) {
      return res.status(404).json({ error: `User not found: ${email}` });
    }

    const updateResult = await dbQuery(
      `UPDATE users SET
        subscription_plan = $1,
        subscription_status = $2,
        responses_limit = $3,
        responses_used = 0,
        smart_responses_used = 0,
        standard_responses_used = 0
       WHERE id = $4`,
      [targetPlan, planConfig.status, planConfig.limit, user.id]
    );

    console.log(
      `âœ… Admin set ${email} to ${targetPlan} plan (was: ${user.subscription_plan}), rows affected: ${updateResult.rowCount}`
    );

    // Verify the update worked
    const verifyUser = await dbGet(
      'SELECT subscription_plan, responses_limit FROM users WHERE id = $1',
      [user.id]
    );
    console.log(
      `âœ… Verified: plan=${verifyUser?.subscription_plan}, limit=${verifyUser?.responses_limit}`
    );

    // If redirect=1, send HTML page that forces a full page reload
    if (req.query.redirect === '1') {
      const frontendUrl = process.env.FRONTEND_URL || 'https://tryreviewresponder.com';
      const redirectUrl = `${frontendUrl}/dashboard?plan=${targetPlan}&_t=${Date.now()}`;
      // Send HTML that forces a hard refresh to ensure React remounts
      // Using both meta refresh AND JavaScript for maximum compatibility
      return res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Plan Updated</title>
          <meta http-equiv="refresh" content="1;url=${redirectUrl}">
          <style>
            body { font-family: -apple-system, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f3f4f6; }
            .card { background: white; padding: 40px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center; }
            h1 { color: #10b981; margin-bottom: 10px; }
            p { color: #6b7280; }
            a { color: #3b82f6; }
          </style>
        </head>
        <body>
          <div class="card">
            <h1>âœ“ Plan Updated!</h1>
            <p>Switching to ${targetPlan.toUpperCase()} plan...</p>
            <p style="margin-top: 20px; font-size: 14px;">
              <a href="${redirectUrl}">Click here if not redirected automatically</a>
            </p>
          </div>
          <script>
            // Force a complete page reload to ensure fresh data
            window.location.replace('${redirectUrl}');
          </script>
        </body>
        </html>
      `);
    }

    res.json({
      success: true,
      message: `User ${email} set to ${targetPlan} plan`,
      previous_plan: user.subscription_plan,
      new_plan: targetPlan,
      responses_limit: planConfig.limit,
      rows_affected: updateResult.rowCount,
      verified_plan: verifyUser?.subscription_plan,
      verified_limit: verifyUser?.responses_limit,
    });
  } catch (error) {
    console.error('Admin set-plan error:', error);
    res.status(500).json({ error: 'Failed to update user plan' });
  }
});

// GET /api/admin/set-test-password - Set password for test account (Chrome Web Store review)
app.get('/api/admin/set-test-password', async (req, res) => {
  const { email, password, key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password required' });
  }

  try {
    const user = await dbGet(
      'SELECT id, email FROM users WHERE LOWER(email) = LOWER($1)',
      [email]
    );

    if (!user) {
      return res.status(404).json({ error: `User not found: ${email}` });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    await dbQuery('UPDATE users SET password = $1 WHERE id = $2', [hashedPassword, user.id]);

    console.log(`âœ… Admin set password for test account: ${email}`);

    res.json({
      success: true,
      message: `Password updated for ${email}`,
      note: 'Use this account for Chrome Web Store review testing'
    });
  } catch (error) {
    console.error('Admin set-test-password error:', error);
    res.status(500).json({ error: 'Failed to update password' });
  }
});

// GET /api/admin/delete-user - Delete user completely (for testing)
app.get('/api/admin/delete-user', async (req, res) => {
  const { email, key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    const user = await dbGet(
      'SELECT id, email, oauth_provider FROM users WHERE LOWER(email) = LOWER($1)',
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Delete related data first (foreign key constraints)
    await dbQuery('DELETE FROM responses WHERE user_id = $1', [user.id]);
    await dbQuery('DELETE FROM response_templates WHERE user_id = $1', [user.id]);
    await dbQuery('DELETE FROM team_members WHERE team_owner_id = $1 OR member_user_id = $1', [
      user.id,
    ]);
    await dbQuery('DELETE FROM api_keys WHERE user_id = $1', [user.id]);
    await dbQuery('DELETE FROM blog_articles WHERE user_id = $1', [user.id]);
    await dbQuery('DELETE FROM referrals WHERE referrer_id = $1 OR referred_user_id = $1', [
      user.id,
    ]);
    await dbQuery('DELETE FROM user_feedback WHERE user_id = $1', [user.id]);
    await dbQuery('DELETE FROM drip_emails WHERE user_id = $1', [user.id]);
    await dbQuery('DELETE FROM password_reset_tokens WHERE user_id = $1', [user.id]);
    // Only delete from tables that exist - skip notification_preferences if not created yet
    try {
      await dbQuery('DELETE FROM notification_preferences WHERE user_id = $1', [user.id]);
    } catch (e) {}
    try {
      await dbQuery('DELETE FROM affiliate_clicks WHERE user_id = $1', [user.id]);
    } catch (e) {}
    // Update referrals that reference this user
    await dbQuery('UPDATE referrals SET referred_user_id = NULL WHERE referred_user_id = $1', [
      user.id,
    ]);

    // Delete user
    await dbQuery('DELETE FROM users WHERE id = $1', [user.id]);

    console.log(`âœ… Admin deleted user: ${email} (OAuth: ${user.oauth_provider || 'none'})`);
    res.json({
      success: true,
      message: `User ${email} deleted`,
      oauth_provider: user.oauth_provider,
    });
  } catch (error) {
    console.error('Admin delete-user error:', error);
    res.status(500).json({ error: 'Failed to delete user', details: error.message });
  }
});

// GET /api/admin/delete-email-capture - Delete email from email_captures (for testing exit-intent)
app.get('/api/admin/delete-email-capture', async (req, res) => {
  const { email, key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email || !email.includes('@')) {
    return res.status(400).json({ error: 'Valid email required' });
  }

  try {
    const result = await dbQuery('DELETE FROM email_captures WHERE LOWER(email) = LOWER($1)', [
      email,
    ]);
    res.json({
      success: true,
      message: `Deleted ${result.rowCount} email capture(s) for ${email}`,
      deleted: result.rowCount,
    });
  } catch (error) {
    console.error('Delete email capture error:', error);
    res.status(500).json({ error: 'Failed to delete email capture' });
  }
});

// GET /api/admin/verify-email - Manually verify a user's email
app.get('/api/admin/verify-email', async (req, res) => {
  const { email, key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email || !email.includes('@')) {
    return res.status(400).json({ error: 'Valid email required' });
  }

  try {
    const result = await dbQuery(
      'UPDATE users SET email_verified = TRUE WHERE LOWER(email) = LOWER($1)',
      [email]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ success: true, message: `Email ${email} verified` });
  } catch (error) {
    console.error('Admin verify-email error:', error);
    res.status(500).json({ error: 'Failed to verify email' });
  }
});

// POST /api/admin/upgrade-user - Upgrade a user to Unlimited plan (legacy)
app.post('/api/admin/upgrade-user', async (req, res) => {
  const ip = req.ip || req.connection.remoteAddress;

  // Rate limiting
  if (!checkAdminRateLimit(ip)) {
    console.log(`âš ï¸ Admin rate limit exceeded for IP: ${ip}`);
    return res.status(429).json({ error: 'Too many attempts. Try again in 15 minutes.' });
  }

  const { email, key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  // Check if ADMIN_SECRET is configured
  if (!adminSecret) {
    console.error('âŒ ADMIN_SECRET environment variable not configured');
    return res.status(500).json({ error: 'Admin endpoint not configured' });
  }

  // Validate key with timing-safe comparison
  if (!safeCompare(key, adminSecret)) {
    console.log(`âš ï¸ Invalid admin key attempt for email: ${email} from IP: ${ip}`);
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  // Validate email
  if (!email || !email.includes('@')) {
    return res.status(400).json({ error: 'Valid email required' });
  }

  try {
    // Find user
    const user = await dbGet(
      'SELECT id, email, subscription_plan FROM users WHERE LOWER(email) = LOWER($1)',
      [email]
    );

    if (!user) {
      return res.status(404).json({ error: `User not found: ${email}` });
    }

    // Upgrade user
    await dbQuery(
      `UPDATE users SET
        subscription_plan = 'unlimited',
        subscription_status = 'active',
        responses_limit = 999999
       WHERE id = $1`,
      [user.id]
    );

    console.log(`âœ… Admin upgraded user ${email} to Unlimited (was: ${user.subscription_plan})`);

    res.json({
      success: true,
      message: `User ${email} upgraded to Unlimited plan`,
      previous_plan: user.subscription_plan,
      new_plan: 'unlimited',
    });
  } catch (error) {
    console.error('Admin upgrade error:', error);
    res.status(500).json({ error: 'Failed to upgrade user' });
  }
});

// ==========================================
// ADMIN - AFFILIATE MANAGEMENT
// ==========================================

// Middleware for admin authentication
const authenticateAdmin = (req, res, next) => {
  const ip = req.ip || req.connection.remoteAddress;

  if (!checkAdminRateLimit(ip)) {
    return res.status(429).json({ error: 'Too many attempts. Try again in 15 minutes.' });
  }

  const adminKey = req.headers['x-admin-key'];
  const adminSecret = process.env.ADMIN_SECRET;

  console.log(
    `ðŸ” Admin auth attempt - Key provided: ${adminKey ? 'yes (' + adminKey.substring(0, 4) + '...)' : 'no'}, Secret configured: ${adminSecret ? 'yes' : 'no'}`
  );

  if (!adminSecret) {
    console.log('âŒ ADMIN_SECRET not configured in environment');
    return res
      .status(500)
      .json({ error: 'ADMIN_SECRET not configured. Add it to Render environment variables.' });
  }

  if (!adminKey) {
    return res.status(401).json({ error: 'No admin key provided' });
  }

  if (!safeCompare(adminKey, adminSecret)) {
    console.log(`âš ï¸ Invalid admin key attempt from IP: ${ip}`);
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  console.log(`âœ… Admin authenticated from IP: ${ip}`);
  next();
};

// GET /api/admin/affiliates - List all affiliate applications
app.get('/api/admin/affiliates', authenticateAdmin, async (req, res) => {
  try {
    const { status } = req.query;

    let query = `
      SELECT a.*, u.email, u.business_name
      FROM affiliates a
      JOIN users u ON a.user_id = u.id
    `;
    const params = [];

    if (status && ['pending', 'approved', 'rejected', 'suspended'].includes(status)) {
      query += ' WHERE a.status = $1';
      params.push(status);
    }

    query += ' ORDER BY a.applied_at DESC';

    const affiliates = await dbAll(query, params);

    // Get summary counts
    const counts = await dbGet(`
      SELECT
        COUNT(*) FILTER (WHERE status = 'pending') as pending,
        COUNT(*) FILTER (WHERE status = 'approved') as approved,
        COUNT(*) FILTER (WHERE status = 'rejected') as rejected,
        COUNT(*) FILTER (WHERE status = 'suspended') as suspended,
        COUNT(*) as total
      FROM affiliates
    `);

    res.json({
      affiliates,
      counts: {
        pending: parseInt(counts.pending) || 0,
        approved: parseInt(counts.approved) || 0,
        rejected: parseInt(counts.rejected) || 0,
        suspended: parseInt(counts.suspended) || 0,
        total: parseInt(counts.total) || 0,
      },
    });
  } catch (error) {
    console.error('Admin get affiliates error:', error);
    res.status(500).json({ error: 'Failed to get affiliates' });
  }
});

// GET /api/admin/affiliates/:id - Get single affiliate with details
app.get('/api/admin/affiliates/:id', authenticateAdmin, async (req, res) => {
  try {
    const affiliate = await dbGet(
      `
      SELECT a.*, u.email, u.business_name, u.created_at as user_created_at
      FROM affiliates a
      JOIN users u ON a.user_id = u.id
      WHERE a.id = $1
    `,
      [req.params.id]
    );

    if (!affiliate) {
      return res.status(404).json({ error: 'Affiliate not found' });
    }

    // Get conversions
    const conversions = await dbAll(
      `
      SELECT ac.*, u.email as converted_email
      FROM affiliate_conversions ac
      LEFT JOIN users u ON ac.referred_user_id = u.id
      WHERE ac.affiliate_id = $1
      ORDER BY ac.created_at DESC
      LIMIT 50
    `,
      [req.params.id]
    );

    // Get payouts
    const payouts = await dbAll(
      `
      SELECT * FROM affiliate_payouts
      WHERE affiliate_id = $1
      ORDER BY created_at DESC
    `,
      [req.params.id]
    );

    res.json({ affiliate, conversions, payouts });
  } catch (error) {
    console.error('Admin get affiliate error:', error);
    res.status(500).json({ error: 'Failed to get affiliate details' });
  }
});

// PUT /api/admin/affiliates/:id/status - Approve/reject/suspend an affiliate
app.put('/api/admin/affiliates/:id/status', authenticateAdmin, async (req, res) => {
  try {
    const { status, note } = req.body;
    const { id } = req.params;

    if (!['pending', 'approved', 'rejected', 'suspended'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }

    const affiliate = await dbGet('SELECT * FROM affiliates WHERE id = $1', [id]);
    if (!affiliate) {
      return res.status(404).json({ error: 'Affiliate not found' });
    }

    const updates = ['status = $1'];
    const params = [status];
    let paramIndex = 2;

    if (status === 'approved' && affiliate.status !== 'approved') {
      updates.push(`approved_at = NOW()`);
    }

    params.push(id);

    await dbQuery(`UPDATE affiliates SET ${updates.join(', ')} WHERE id = $${paramIndex}`, params);

    // Get user email for notification
    const user = await dbGet('SELECT email, business_name FROM users WHERE id = $1', [
      affiliate.user_id,
    ]);

    // Send email notification if Resend is configured
    if (resend && user) {
      try {
        let subject, html;

        if (status === 'approved') {
          subject = 'Your Affiliate Application is Approved!';
          html = `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h1 style="color: #10B981;">Congratulations! You're Now a ReviewResponder Affiliate</h1>
              <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>
              <p>Great news! Your affiliate application has been approved.</p>
              <p><strong>Your Affiliate Code:</strong> ${affiliate.affiliate_code}</p>
              <p><strong>Commission Rate:</strong> ${affiliate.commission_rate}% recurring</p>
              <p>You can now start earning by sharing your unique affiliate link:</p>
              <p style="background: #F3F4F6; padding: 15px; border-radius: 8px; font-family: monospace;">
                https://tryreviewresponder.com/?aff=${affiliate.affiliate_code}
              </p>
              <p>Visit your <a href="https://tryreviewresponder.com/affiliate/dashboard">Affiliate Dashboard</a> to track your earnings and get marketing materials.</p>
              <p>Best,<br>The ReviewResponder Team</p>
            </div>
          `;
        } else if (status === 'rejected') {
          subject = 'Update on Your Affiliate Application';
          html = `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h1 style="color: #6B7280;">Affiliate Application Update</h1>
              <p>Hi${user.business_name ? ' ' + user.business_name : ''},</p>
              <p>Thank you for your interest in the ReviewResponder affiliate program.</p>
              <p>After reviewing your application, we've decided not to move forward at this time.</p>
              ${note ? `<p><strong>Note:</strong> ${note}</p>` : ''}
              <p>You're welcome to reapply in the future if your circumstances change.</p>
              <p>Best,<br>The ReviewResponder Team</p>
            </div>
          `;
        }

        if (subject && html) {
          await resend.emails.send({
            from: FROM_EMAIL,
            to: user.email,
            subject,
            html,
          });
        }
      } catch (emailError) {
        console.error('Failed to send affiliate status email:', emailError);
      }
    }

    console.log(`âœ… Admin updated affiliate ${id} status to ${status}`);

    res.json({
      success: true,
      message: `Affiliate ${status === 'approved' ? 'approved' : status === 'rejected' ? 'rejected' : 'updated'}`,
      affiliate_code: affiliate.affiliate_code,
    });
  } catch (error) {
    console.error('Admin update affiliate status error:', error);
    res.status(500).json({ error: 'Failed to update affiliate status' });
  }
});

// PUT /api/admin/affiliates/:id/commission - Update commission rate
app.put('/api/admin/affiliates/:id/commission', authenticateAdmin, async (req, res) => {
  try {
    const { commissionRate } = req.body;
    const { id } = req.params;

    if (typeof commissionRate !== 'number' || commissionRate < 0 || commissionRate > 50) {
      return res.status(400).json({ error: 'Commission rate must be between 0 and 50%' });
    }

    await dbQuery('UPDATE affiliates SET commission_rate = $1 WHERE id = $2', [commissionRate, id]);

    console.log(`âœ… Admin updated affiliate ${id} commission to ${commissionRate}%`);

    res.json({ success: true, message: `Commission rate updated to ${commissionRate}%` });
  } catch (error) {
    console.error('Admin update commission error:', error);
    res.status(500).json({ error: 'Failed to update commission rate' });
  }
});

// POST /api/admin/affiliates/:id/payout - Mark a payout as processed
app.post('/api/admin/affiliates/:id/payout', authenticateAdmin, async (req, res) => {
  try {
    const { amount, method, transactionId, note } = req.body;
    const { id } = req.params;

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Valid payout amount required' });
    }

    const affiliate = await dbGet('SELECT * FROM affiliates WHERE id = $1', [id]);
    if (!affiliate) {
      return res.status(404).json({ error: 'Affiliate not found' });
    }

    // Create payout record
    await dbQuery(
      `
      INSERT INTO affiliate_payouts (affiliate_id, amount, method, transaction_id, status, note, processed_at)
      VALUES ($1, $2, $3, $4, 'completed', $5, NOW())
    `,
      [id, amount, method || affiliate.payout_method, transactionId, note]
    );

    // Update affiliate totals
    await dbQuery(
      `
      UPDATE affiliates
      SET total_paid = total_paid + $1, pending_balance = pending_balance - $1
      WHERE id = $2
    `,
      [amount, id]
    );

    console.log(`âœ… Admin processed payout of $${amount} for affiliate ${id}`);

    res.json({ success: true, message: `Payout of $${amount} processed` });
  } catch (error) {
    console.error('Admin process payout error:', error);
    res.status(500).json({ error: 'Failed to process payout' });
  }
});

// GET /api/admin/sales-state - Get sales automation state for Claude sessions
app.get('/api/admin/sales-state', authenticateAdmin, async (req, res) => {
  try {
    const state = await getSalesState();
    res.json(state);
  } catch (error) {
    console.error('Error getting sales state:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/admin/sales-note - Add a note for next Claude session
app.post('/api/admin/sales-note', authenticateAdmin, async (req, res) => {
  try {
    const { note } = req.body;
    if (!note) {
      return res.status(400).json({ error: 'Note is required' });
    }
    await addSessionNote(note);
    res.json({ ok: true, message: 'Note added' });
  } catch (error) {
    console.error('Error adding sales note:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET /api/admin/stats - Get overall admin stats
app.get('/api/admin/stats', authenticateAdmin, async (req, res) => {
  try {
    // Use central test email filter
    const excludeEmailsClause = getTestEmailExcludeClause('email');

    // User stats - this should always work
    let userStats = { total_users: 0, paying_users: 0, new_users_week: 0, new_users_month: 0 };
    try {
      userStats =
        (await dbGet(`
        SELECT
          COUNT(*) as total_users,
          COUNT(*) FILTER (WHERE subscription_plan != 'free') as paying_users,
          COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as new_users_week,
          COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '30 days') as new_users_month
        FROM users
        WHERE 1=1 ${excludeEmailsClause}
      `)) || userStats;
    } catch (e) {
      console.error('User stats query error:', e.message);
    }

    // Revenue stats - might fail if table doesn't exist
    let revenueStats = { total_commissions: 0, total_conversions: 0 };
    try {
      revenueStats =
        (await dbGet(`
        SELECT
          COALESCE(SUM(commission_amount), 0) as total_commissions,
          COUNT(DISTINCT referred_user_id) as total_conversions
        FROM affiliate_conversions
      `)) || revenueStats;
    } catch (e) {
      console.error('Revenue stats query error:', e.message);
    }

    // Affiliate stats - might fail if table doesn't exist
    let affiliateStats = {
      pending_affiliates: 0,
      active_affiliates: 0,
      total_affiliate_earnings: 0,
      total_pending_payouts: 0,
    };
    try {
      affiliateStats =
        (await dbGet(`
        SELECT
          COUNT(*) FILTER (WHERE status = 'pending') as pending_affiliates,
          COUNT(*) FILTER (WHERE status = 'approved') as active_affiliates,
          COALESCE(SUM(total_earned), 0) as total_affiliate_earnings,
          COALESCE(SUM(pending_balance), 0) as total_pending_payouts
        FROM affiliates
      `)) || affiliateStats;
    } catch (e) {
      console.error('Affiliate stats query error:', e.message);
    }

    res.json({
      users: {
        total: parseInt(userStats.total_users) || 0,
        paying: parseInt(userStats.paying_users) || 0,
        newThisWeek: parseInt(userStats.new_users_week) || 0,
        newThisMonth: parseInt(userStats.new_users_month) || 0,
      },
      affiliates: {
        pending: parseInt(affiliateStats.pending_affiliates) || 0,
        active: parseInt(affiliateStats.active_affiliates) || 0,
        totalEarnings: parseFloat(affiliateStats.total_affiliate_earnings) || 0,
        pendingPayouts: parseFloat(affiliateStats.total_pending_payouts) || 0,
      },
      conversions: {
        total: parseInt(revenueStats.total_conversions) || 0,
        totalCommissions: parseFloat(revenueStats.total_commissions) || 0,
      },
    });
  } catch (error) {
    console.error('Admin stats error:', error);
    res.status(500).json({ error: 'Failed to get admin stats' });
  }
});

// GET /api/admin/widget-analytics - Widget performance analytics
app.get('/api/admin/widget-analytics', authenticateAdmin, async (req, res) => {
  try {
    // Total attempts from public_try_usage
    const attemptsResult = await dbGet('SELECT COUNT(*) as count FROM public_try_usage');
    const attempts = parseInt(attemptsResult?.count || 0);

    // Total email captures from instant_demo
    const capturesResult = await dbGet(`
      SELECT COUNT(*) as count FROM email_captures
      WHERE source = 'instant_demo'
    `);
    const captures = parseInt(capturesResult?.count || 0);

    // Capture rate
    const captureRate = attempts > 0 ? ((captures / attempts) * 100).toFixed(1) : 0;

    // By Platform
    const byPlatform = await dbAll(`
      SELECT platform, COUNT(*) as captures
      FROM email_captures
      WHERE source = 'instant_demo' AND platform IS NOT NULL AND platform != ''
      GROUP BY platform
      ORDER BY captures DESC
      LIMIT 10
    `) || [];

    // By Business Type
    const byBusinessType = await dbAll(`
      SELECT business_type, COUNT(*) as captures
      FROM email_captures
      WHERE source = 'instant_demo' AND business_type IS NOT NULL AND business_type != ''
      GROUP BY business_type
      ORDER BY captures DESC
      LIMIT 10
    `) || [];

    // By Landing Page (top 10)
    const byLandingPage = await dbAll(`
      SELECT landing_page, COUNT(*) as captures
      FROM email_captures
      WHERE source = 'instant_demo' AND landing_page IS NOT NULL AND landing_page != ''
      GROUP BY landing_page
      ORDER BY captures DESC
      LIMIT 10
    `) || [];

    // Recent captures (last 7 days trend)
    const recentTrend = await dbAll(`
      SELECT DATE(created_at) as date, COUNT(*) as captures
      FROM email_captures
      WHERE source = 'instant_demo' AND created_at > NOW() - INTERVAL '7 days'
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `) || [];

    // Attempts by platform (for conversion rate calculation)
    const attemptsByPlatform = await dbAll(`
      SELECT platform, COUNT(*) as attempts
      FROM public_try_usage
      WHERE platform IS NOT NULL AND platform != ''
      GROUP BY platform
      ORDER BY attempts DESC
      LIMIT 10
    `) || [];

    // Attempts by business type (for conversion rate calculation)
    const attemptsByBusinessType = await dbAll(`
      SELECT business_type, COUNT(*) as attempts
      FROM public_try_usage
      WHERE business_type IS NOT NULL AND business_type != ''
      GROUP BY business_type
      ORDER BY attempts DESC
      LIMIT 10
    `) || [];

    res.json({
      summary: {
        attempts,
        captures,
        captureRate: parseFloat(captureRate),
      },
      byPlatform,
      byBusinessType,
      byLandingPage,
      recentTrend,
      attemptsByPlatform,
      attemptsByBusinessType,
    });
  } catch (error) {
    console.error('Widget analytics error:', error);
    res.status(500).json({ error: 'Failed to get widget analytics' });
  }
});

// GET /api/admin/user-list - List all users with response counts for activation targeting
// WICHTIG: Unterscheidet echte Leads von Test/Freunde Accounts!
app.get('/api/admin/user-list', authenticateAdmin, async (req, res) => {
  try {
    const includeTest = req.query.include_test === 'true';

    const allUsers = await dbAll(`
      SELECT
        id,
        email,
        business_name,
        subscription_plan as plan,
        responses_used as response_count,
        created_at,
        COALESCE(created_via_magic_link, false) as is_magic_link,
        CASE WHEN COALESCE(created_via_magic_link, false) THEN 'magic_link' ELSE 'normal_signup' END as signup_source,
        CASE
          WHEN responses_used = 0 THEN 'never_used'
          WHEN responses_used < 5 THEN 'low_usage'
          WHEN responses_used < 15 THEN 'medium_usage'
          WHEN responses_used >= 15 THEN 'high_usage'
        END as usage_tier,
        ROUND(EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400) as days_since_signup
      FROM users
      ORDER BY responses_used DESC, created_at DESC
    `) || [];

    // Flag each user as test or real using isTestEmail()
    const usersWithFlag = allUsers.map(u => ({
      ...u,
      is_test_account: isTestEmail(u.email),
    }));

    // Separate test vs real users
    const testUsers = usersWithFlag.filter(u => u.is_test_account);
    const realUsers = usersWithFlag.filter(u => !u.is_test_account);

    // Return based on include_test parameter
    const users = includeTest ? usersWithFlag : realUsers;

    // Summary stats - NUR echte User (keine Tests/Freunde)
    const summary = {
      total_raw: allUsers.length,
      total_test: testUsers.length,
      total_real: realUsers.length,
      // Echte Metriken (ohne Tests)
      real: {
        total: realUsers.length,
        never_used: realUsers.filter(u => u.usage_tier === 'never_used').length,
        low_usage: realUsers.filter(u => u.usage_tier === 'low_usage').length,
        medium_usage: realUsers.filter(u => u.usage_tier === 'medium_usage').length,
        high_usage: realUsers.filter(u => u.usage_tier === 'high_usage').length,
        activated: realUsers.filter(u => u.response_count > 0).length,
        activation_rate: realUsers.length > 0
          ? Math.round(100 * realUsers.filter(u => u.response_count > 0).length / realUsers.length) + '%'
          : '0%',
      },
      // Test-Accounts Breakdown (fÃ¼r Transparenz)
      test: {
        total: testUsers.length,
        activated: testUsers.filter(u => u.response_count > 0).length,
        emails: testUsers.map(u => u.email).slice(0, 10),
      },
    };

    res.json({ summary, users });
  } catch (error) {
    console.error('User list error:', error);
    res.status(500).json({ error: 'Failed to get user list' });
  }
});

// GET /api/admin/parallel-safe-status - View parallel-safe email system status
app.get('/api/admin/parallel-safe-status', authenticateAdmin, async (req, res) => {
  try {
    // Active locks
    const activeLocks = await dbAll(`
      SELECT resource_type, resource_id, session_id, acquired_at, expires_at
      FROM processing_locks
      WHERE expires_at > NOW()
      ORDER BY acquired_at DESC
      LIMIT 50
    `) || [];

    // Recent email history (last 24h)
    const recentEmails = await dbAll(`
      SELECT email_address, email_type, sequence_number, session_id, sent_at
      FROM email_send_history
      WHERE sent_at > NOW() - INTERVAL '24 hours'
      ORDER BY sent_at DESC
      LIMIT 100
    `) || [];

    // Stats by email type
    const emailStats = await dbAll(`
      SELECT
        email_type,
        COUNT(*) as total_sent,
        COUNT(DISTINCT email_address) as unique_recipients,
        COUNT(DISTINCT session_id) as sessions_used
      FROM email_send_history
      WHERE sent_at > NOW() - INTERVAL '24 hours'
      GROUP BY email_type
      ORDER BY total_sent DESC
    `) || [];

    // Duplicate prevention stats (how many would have been duplicates)
    const duplicatesBlocked = await dbGet(`
      SELECT COUNT(*) as count
      FROM email_send_history e1
      WHERE EXISTS (
        SELECT 1 FROM email_send_history e2
        WHERE e2.email_address = e1.email_address
        AND e2.email_type = e1.email_type
        AND e2.id < e1.id
        AND e2.sent_at > e1.sent_at - INTERVAL '60 minutes'
      )
    `) || { count: 0 };

    // Expired locks cleaned up
    const expiredLocks = await dbGet(`
      SELECT COUNT(*) as count
      FROM processing_locks
      WHERE expires_at <= NOW()
    `) || { count: 0 };

    // Clean up expired locks
    await dbQuery(`DELETE FROM processing_locks WHERE expires_at <= NOW()`);

    res.json({
      status: 'healthy',
      active_locks: activeLocks.length,
      locks: activeLocks,
      recent_emails_24h: recentEmails.length,
      email_history: recentEmails.slice(0, 20), // Just show 20 for brevity
      email_stats_by_type: emailStats,
      duplicates_blocked: parseInt(duplicatesBlocked.count) || 0,
      expired_locks_cleaned: parseInt(expiredLocks.count) || 0,
      current_session: process.env.CLAUDE_SESSION || 'unknown'
    });
  } catch (error) {
    console.error('Parallel-safe status error:', error);
    res.status(500).json({ error: 'Failed to get parallel-safe status', details: error.message });
  }
});

// GET /api/admin/sales-dashboard - Comprehensive sales dashboard data
app.get('/api/admin/sales-dashboard', authenticateAdmin, async (req, res) => {
  try {
    // Use central test email filter
    const excludeEmailsClause = getTestEmailExcludeClause('email');

    // ========== REVENUE METRICS ==========
    // MRR calculation: Starter $29, Pro $49, Unlimited $99
    const planPrices = { starter: 29, pro: 49, unlimited: 99 };
    const planCounts = await dbAll(`
      SELECT subscription_plan, COUNT(*) as count
      FROM users
      WHERE 1=1 ${excludeEmailsClause}
      GROUP BY subscription_plan
    `);

    let mrr = 0;
    const planBreakdown = {};
    for (const p of planCounts) {
      planBreakdown[p.subscription_plan] = parseInt(p.count);
      if (planPrices[p.subscription_plan]) {
        mrr += planPrices[p.subscription_plan] * parseInt(p.count);
      }
    }

    // ========== USER METRICS ==========
    const userMetrics = await dbGet(`
      SELECT
        COUNT(*) as total_users,
        COUNT(*) FILTER (WHERE subscription_plan != 'free') as paying_users,
        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as new_today,
        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as new_this_week,
        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '30 days') as new_this_month,
        COUNT(*) FILTER (WHERE email_verified = true) as verified_users
      FROM users
      WHERE 1=1 ${excludeEmailsClause}
    `);

    // ========== ACTIVITY METRICS ==========
    // Active users (generated response in last 7 days)
    let activityMetrics = {
      active_7d: 0,
      active_30d: 0,
      total_responses: 0,
      responses_today: 0,
      responses_week: 0,
    };
    try {
      activityMetrics =
        (await dbGet(`
        SELECT
          COUNT(DISTINCT user_id) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as active_7d,
          COUNT(DISTINCT user_id) FILTER (WHERE created_at > NOW() - INTERVAL '30 days') as active_30d,
          COUNT(*) as total_responses,
          COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as responses_today,
          COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as responses_week
        FROM responses
      `)) || activityMetrics;
    } catch (e) {
      console.error('Activity query error:', e.message);
    }

    // ========== FUNNEL METRICS ==========
    // Users who have generated at least 1 response (activated)
    let activatedCount = 0;
    try {
      const activated = await dbGet(`
        SELECT COUNT(DISTINCT r.user_id) as count
        FROM responses r
        JOIN users u ON r.user_id = u.id
        WHERE 1=1 ${excludeEmailsClause.replace(/email/g, 'u.email')}
      `);
      activatedCount = parseInt(activated?.count || 0);
    } catch (e) {
      console.error('Activated query error:', e.message);
    }

    // ========== RECENT SIGNUPS ==========
    const recentSignups = await dbAll(`
      SELECT id, email, subscription_plan, created_at, email_verified, stripe_customer_id
      FROM users
      WHERE 1=1 ${excludeEmailsClause}
      ORDER BY created_at DESC
      LIMIT 15
    `);

    // ========== USER ACTIVITY DETAILS ==========
    // Power users (most responses)
    let powerUsers = [];
    try {
      powerUsers = await dbAll(`
        SELECT u.email, u.subscription_plan, COUNT(r.id) as response_count, MAX(r.created_at) as last_activity
        FROM users u
        LEFT JOIN responses r ON u.id = r.user_id
        WHERE 1=1 ${excludeEmailsClause.replace(/email/g, 'u.email')}
        GROUP BY u.id, u.email, u.subscription_plan
        HAVING COUNT(r.id) > 0
        ORDER BY response_count DESC
        LIMIT 10
      `);
    } catch (e) {
      console.error('Power users query error:', e.message);
    }

    // Users near their plan limit (upgrade candidates)
    let upgradeOpportunities = [];
    try {
      const limits = { free: 20, starter: 300, pro: 800 };
      upgradeOpportunities = await dbAll(`
        SELECT u.email, u.subscription_plan, u.monthly_response_count, u.smart_response_count
        FROM users u
        WHERE u.subscription_plan IN ('free', 'starter', 'pro')
        AND u.monthly_response_count >= 15
        ${excludeEmailsClause.replace(/email/g, 'u.email')}
        ORDER BY u.monthly_response_count DESC
        LIMIT 10
      `);
      // Add percentage to limit
      upgradeOpportunities = upgradeOpportunities.map(u => ({
        ...u,
        limit: limits[u.subscription_plan] || 20,
        usage_percent: Math.round(
          (u.monthly_response_count / (limits[u.subscription_plan] || 20)) * 100
        ),
      }));
    } catch (e) {
      console.error('Upgrade opportunities query error:', e.message);
    }

    // Inactive paying users (churn risk) - paid but no activity in 14+ days
    let churnRisk = [];
    try {
      churnRisk = await dbAll(`
        SELECT u.email, u.subscription_plan, u.created_at,
               MAX(r.created_at) as last_activity
        FROM users u
        LEFT JOIN responses r ON u.id = r.user_id
        WHERE u.subscription_plan != 'free'
        ${excludeEmailsClause.replace(/email/g, 'u.email')}
        GROUP BY u.id, u.email, u.subscription_plan, u.created_at
        HAVING MAX(r.created_at) IS NULL OR MAX(r.created_at) < NOW() - INTERVAL '14 days'
        ORDER BY MAX(r.created_at) DESC NULLS LAST
        LIMIT 10
      `);
    } catch (e) {
      console.error('Churn risk query error:', e.message);
    }

    // High-activity free users (upgrade candidates)
    let freeUpgradeCandidates = [];
    try {
      freeUpgradeCandidates = await dbAll(`
        SELECT u.email, u.monthly_response_count, MAX(r.created_at) as last_activity
        FROM users u
        LEFT JOIN responses r ON u.id = r.user_id
        WHERE u.subscription_plan = 'free'
        AND u.monthly_response_count >= 10
        ${excludeEmailsClause.replace(/email/g, 'u.email')}
        GROUP BY u.id, u.email, u.monthly_response_count
        ORDER BY u.monthly_response_count DESC
        LIMIT 10
      `);
    } catch (e) {
      console.error('Free upgrade candidates query error:', e.message);
    }

    // ========== BLOG STATS ==========
    let blogStats = { total_articles: 0, published: 0 };
    try {
      blogStats =
        (await dbGet(`
        SELECT COUNT(*) as total_articles,
               COUNT(*) FILTER (WHERE published = true) as published
        FROM blog_articles
      `)) || blogStats;
    } catch (e) {
      console.error('Blog stats query error:', e.message);
    }

    // ========== EMAIL VERIFICATION STATS ==========
    let emailStats = { total_tokens: 0, verified: 0 };
    try {
      emailStats =
        (await dbGet(`
        SELECT
          (SELECT COUNT(*) FROM email_verification_tokens) as total_tokens,
          (SELECT COUNT(*) FROM users WHERE email_verified = true ${excludeEmailsClause}) as verified
      `)) || emailStats;
    } catch (e) {
      console.error('Email stats query error:', e.message);
    }

    // ========== DAILY REGISTRATIONS (last 14 days) ==========
    let dailySignups = [];
    try {
      dailySignups = await dbAll(`
        SELECT DATE(created_at) as date, COUNT(*) as count
        FROM users
        WHERE created_at > NOW() - INTERVAL '14 days'
        ${excludeEmailsClause}
        GROUP BY DATE(created_at)
        ORDER BY date DESC
      `);
    } catch (e) {
      console.error('Daily signups query error:', e.message);
    }

    // ========== RESPONSE TREND (last 14 days) ==========
    let dailyResponses = [];
    try {
      dailyResponses = await dbAll(`
        SELECT DATE(created_at) as date, COUNT(*) as count
        FROM responses
        WHERE created_at > NOW() - INTERVAL '14 days'
        GROUP BY DATE(created_at)
        ORDER BY date DESC
      `);
    } catch (e) {
      console.error('Daily responses query error:', e.message);
    }

    res.json({
      revenue: {
        mrr,
        arr: mrr * 12,
        planBreakdown,
        avgRevenuePerUser:
          userMetrics.paying_users > 0 ? (mrr / parseInt(userMetrics.paying_users)).toFixed(2) : 0,
      },
      users: {
        total: parseInt(userMetrics.total_users) || 0,
        paying: parseInt(userMetrics.paying_users) || 0,
        free: (parseInt(userMetrics.total_users) || 0) - (parseInt(userMetrics.paying_users) || 0),
        newToday: parseInt(userMetrics.new_today) || 0,
        newThisWeek: parseInt(userMetrics.new_this_week) || 0,
        newThisMonth: parseInt(userMetrics.new_this_month) || 0,
        verified: parseInt(userMetrics.verified_users) || 0,
        verificationRate:
          userMetrics.total_users > 0
            ? (
                (parseInt(userMetrics.verified_users) / parseInt(userMetrics.total_users)) *
                100
              ).toFixed(1)
            : 0,
      },
      activity: {
        activeUsers7d: parseInt(activityMetrics.active_7d) || 0,
        activeUsers30d: parseInt(activityMetrics.active_30d) || 0,
        totalResponses: parseInt(activityMetrics.total_responses) || 0,
        responsesToday: parseInt(activityMetrics.responses_today) || 0,
        responsesThisWeek: parseInt(activityMetrics.responses_week) || 0,
      },
      funnel: {
        registered: parseInt(userMetrics.total_users) || 0,
        activated: activatedCount,
        activationRate:
          userMetrics.total_users > 0
            ? ((activatedCount / parseInt(userMetrics.total_users)) * 100).toFixed(1)
            : 0,
        paying: parseInt(userMetrics.paying_users) || 0,
        conversionRate:
          userMetrics.total_users > 0
            ? (
                (parseInt(userMetrics.paying_users) / parseInt(userMetrics.total_users)) *
                100
              ).toFixed(1)
            : 0,
      },
      insights: {
        powerUsers,
        upgradeOpportunities,
        churnRisk,
        freeUpgradeCandidates,
      },
      recentSignups,
      trends: {
        dailySignups,
        dailyResponses,
      },
      blog: {
        totalArticles: parseInt(blogStats.total_articles) || 0,
        published: parseInt(blogStats.published) || 0,
      },
    });
  } catch (error) {
    console.error('Sales dashboard error:', error);
    res.status(500).json({ error: 'Failed to get sales dashboard', details: error.message });
  }
});

// GET /api/admin/email-providers - Multi-provider capacity status
app.get('/api/admin/email-providers', authenticateAdmin, async (req, res) => {
  try {
    const counts = await getProviderCountsToday();

    const providers = [
      {
        name: 'ses',
        available: sesClient !== null,
        limit: EMAIL_PROVIDER_LIMITS.ses,
        used: counts.ses,
        remaining: EMAIL_PROVIDER_LIMITS.ses - counts.ses,
        note: 'Amazon SES - $0.10/1000 emails, effectively unlimited',
      },
      {
        name: 'brevo',
        available: brevoApi !== null,
        limit: EMAIL_PROVIDER_LIMITS.brevo,
        used: counts.brevo,
        remaining: EMAIL_PROVIDER_LIMITS.brevo - counts.brevo,
      },
      {
        name: 'mailersend',
        available: mailerSendClient !== null,
        limit: EMAIL_PROVIDER_LIMITS.mailersend,
        used: counts.mailersend,
        remaining: EMAIL_PROVIDER_LIMITS.mailersend - counts.mailersend,
      },
      {
        name: 'sendgrid',
        available: process.env.SENDGRID_API_KEY !== undefined,
        limit: EMAIL_PROVIDER_LIMITS.sendgrid,
        used: counts.sendgrid,
        remaining: EMAIL_PROVIDER_LIMITS.sendgrid - counts.sendgrid,
      },
      {
        name: 'mailgun',
        available: mailgunClient !== null,
        limit: EMAIL_PROVIDER_LIMITS.mailgun,
        used: counts.mailgun,
        remaining: EMAIL_PROVIDER_LIMITS.mailgun - counts.mailgun,
      },
      {
        name: 'resend',
        available: resend !== null,
        limit: EMAIL_PROVIDER_LIMITS.resend,
        used: counts.resend,
        remaining: EMAIL_PROVIDER_LIMITS.resend - counts.resend,
      },
    ];

    const totalLimit = providers.filter(p => p.available).reduce((sum, p) => sum + p.limit, 0);
    const totalUsed = providers.filter(p => p.available).reduce((sum, p) => sum + p.used, 0);
    const totalRemaining = providers.filter(p => p.available).reduce((sum, p) => sum + p.remaining, 0);

    res.json({
      providers,
      summary: {
        active_providers: providers.filter(p => p.available).length,
        total_daily_limit: totalLimit,
        total_used_today: totalUsed,
        total_remaining: totalRemaining,
        utilization_percent: totalLimit > 0 ? Math.round((totalUsed / totalLimit) * 100) : 0,
      },
      setup_instructions: {
        ses: !process.env.AWS_SES_ACCESS_KEY_ID ? 'Add AWS_SES_ACCESS_KEY_ID, AWS_SES_SECRET_ACCESS_KEY, AWS_SES_REGION to Render' : 'âœ“ Configured',
        mailersend: !process.env.MAILERSEND_API_KEY ? 'Add MAILERSEND_API_KEY to Render env vars' : 'âœ“ Configured',
        sendgrid: !process.env.SENDGRID_API_KEY ? 'Add SENDGRID_API_KEY to Render env vars' : 'âœ“ Configured',
        mailgun: !process.env.MAILGUN_API_KEY ? 'Add MAILGUN_API_KEY and MAILGUN_DOMAIN to Render env vars' : 'âœ“ Configured',
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// GET /api/admin/email-dashboard - Unified email dashboard for all providers
app.get('/api/admin/email-dashboard', authenticateAdmin, async (req, res) => {
  try {
    // Summary stats from email_logs
    let summary = {
      total_sent: 0,
      total_today: 0,
      total_failed: 0,
      by_provider: {
        ses: { sent: 0, today: 0, failed: 0 },
        brevo: { sent: 0, today: 0, failed: 0 },
        mailersend: { sent: 0, today: 0, failed: 0 },
        sendgrid: { sent: 0, today: 0, failed: 0 },
        mailgun: { sent: 0, today: 0, failed: 0 },
        resend: { sent: 0, today: 0, failed: 0 },
      },
    };

    try {
      const stats = await dbAll(`
        SELECT
          provider,
          COUNT(*) FILTER (WHERE status = 'sent') as sent,
          COUNT(*) FILTER (WHERE status = 'sent' AND sent_at > NOW() - INTERVAL '24 hours') as today,
          COUNT(*) FILTER (WHERE status = 'failed') as failed
        FROM email_logs
        GROUP BY provider
      `);

      for (const s of stats) {
        if (['brevo', 'mailersend', 'sendgrid', 'mailgun', 'resend'].includes(s.provider)) {
          summary.by_provider[s.provider] = {
            sent: parseInt(s.sent) || 0,
            today: parseInt(s.today) || 0,
            failed: parseInt(s.failed) || 0,
          };
        }
      }

      summary.total_sent = Object.values(summary.by_provider).reduce((sum, p) => sum + p.sent, 0);
      summary.total_today = Object.values(summary.by_provider).reduce((sum, p) => sum + p.today, 0);
      summary.total_failed = Object.values(summary.by_provider).reduce((sum, p) => sum + p.failed, 0);
    } catch (e) {
      console.error('Email summary query error:', e.message);
    }

    // Stats by email type
    let byType = [];
    try {
      byType = await dbAll(`
        SELECT
          type,
          COUNT(*) FILTER (WHERE status = 'sent') as sent,
          COUNT(*) FILTER (WHERE status = 'failed') as failed
        FROM email_logs
        GROUP BY type
        ORDER BY sent DESC
      `);
    } catch (e) {
      console.error('Email by type query error:', e.message);
    }

    // Stats by campaign (for marketing/outreach)
    let byCampaign = [];
    try {
      byCampaign = await dbAll(`
        SELECT
          campaign,
          COUNT(*) as sent,
          COUNT(*) FILTER (WHERE opened_at IS NOT NULL) as opens,
          COUNT(*) FILTER (WHERE clicked_at IS NOT NULL) as clicks
        FROM email_logs
        WHERE campaign IS NOT NULL AND status = 'sent'
        GROUP BY campaign
        ORDER BY sent DESC
        LIMIT 20
      `);
    } catch (e) {
      console.error('Email by campaign query error:', e.message);
    }

    // Also include outreach_tracking data (existing open tracking)
    let outreachStats = { opens: 0, clicks: 0 };
    try {
      const opens = await dbGet(`SELECT COUNT(*) as count FROM outreach_tracking`);
      const clicks = await dbGet(`SELECT COUNT(*) as count FROM outreach_clicks`);
      outreachStats = {
        opens: parseInt(opens?.count) || 0,
        clicks: parseInt(clicks?.count) || 0,
      };
    } catch (e) {
      console.error('Outreach stats query error:', e.message);
    }

    // Recent emails
    let recentEmails = [];
    try {
      recentEmails = await dbAll(`
        SELECT id, to_email, subject, type, campaign, provider, status, sent_at
        FROM email_logs
        ORDER BY sent_at DESC
        LIMIT 50
      `);
    } catch (e) {
      console.error('Recent emails query error:', e.message);
    }

    // Daily trend (last 14 days)
    let dailyTrend = [];
    try {
      dailyTrend = await dbAll(`
        SELECT
          DATE(sent_at) as date,
          COUNT(*) FILTER (WHERE provider = 'brevo') as brevo,
          COUNT(*) FILTER (WHERE provider = 'resend') as resend,
          COUNT(*) as total
        FROM email_logs
        WHERE sent_at > NOW() - INTERVAL '14 days' AND status = 'sent'
        GROUP BY DATE(sent_at)
        ORDER BY date DESC
      `);
    } catch (e) {
      console.error('Daily trend query error:', e.message);
    }

    res.json({
      summary,
      byType: byType.map(t => ({
        type: t.type,
        sent: parseInt(t.sent) || 0,
        failed: parseInt(t.failed) || 0,
      })),
      byCampaign: byCampaign.map(c => ({
        campaign: c.campaign,
        sent: parseInt(c.sent) || 0,
        opens: parseInt(c.opens) || 0,
        clicks: parseInt(c.clicks) || 0,
        openRate: c.sent > 0 ? ((c.opens / c.sent) * 100).toFixed(1) + '%' : '0%',
        clickRate: c.sent > 0 ? ((c.clicks / c.sent) * 100).toFixed(1) + '%' : '0%',
      })),
      outreachStats,
      recentEmails: recentEmails.map(e => ({
        id: e.id,
        to: e.to_email,
        subject: e.subject?.substring(0, 50) + (e.subject?.length > 50 ? '...' : ''),
        type: e.type,
        campaign: e.campaign,
        provider: e.provider,
        status: e.status,
        sentAt: e.sent_at,
      })),
      dailyTrend: dailyTrend.map(d => ({
        date: d.date,
        brevo: parseInt(d.brevo) || 0,
        resend: parseInt(d.resend) || 0,
        total: parseInt(d.total) || 0,
      })),
    });
  } catch (error) {
    console.error('Email dashboard error:', error);
    res.status(500).json({ error: 'Failed to get email dashboard', details: error.message });
  }
});

// Admin: List all users (with fake detection)
app.get('/api/admin/users', authenticateAdmin, async (req, res) => {
  try {
    // Get users with their response counts and activity
    const users = await dbAll(`
      SELECT
        u.id,
        u.email,
        u.subscription_plan,
        u.created_at,
        u.stripe_customer_id,
        u.created_via_magic_link,
        COALESCE(r.response_count, 0) as response_count,
        r.last_response_at,
        r.first_response_at
      FROM users u
      LEFT JOIN (
        SELECT
          user_id,
          COUNT(*) as response_count,
          MAX(created_at) as last_response_at,
          MIN(created_at) as first_response_at
        FROM responses
        GROUP BY user_id
      ) r ON u.id = r.user_id
      ORDER BY u.created_at DESC
      LIMIT 100
    `);

    // Use central isTestEmail function for consistent detection
    const usersWithFlag = users.map(u => ({
      ...u,
      is_test_account: isTestEmail(u.email),
      onboarding_completed: u.response_count > 0,
      is_active:
        u.last_response_at &&
        new Date(u.last_response_at) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
    }));

    const realUsers = usersWithFlag.filter(u => !u.is_test_account);
    const testUsers = usersWithFlag.filter(u => u.is_test_account);
    const onboardedReal = realUsers.filter(u => u.onboarding_completed);
    const activeReal = realUsers.filter(u => u.is_active);
    const magicLinkUsers = realUsers.filter(u => u.created_via_magic_link);

    res.json({
      users: usersWithFlag,
      summary: {
        total: usersWithFlag.length,
        real: realUsers.length,
        test: testUsers.length,
        realPaying: realUsers.filter(u => u.subscription_plan !== 'free').length,
        realOnboarded: onboardedReal.length,
        realActive7d: activeReal.length,
        magicLinkUsers: magicLinkUsers.length,
        onboardingRate:
          realUsers.length > 0 ? Math.round((onboardedReal.length / realUsers.length) * 100) : 0,
      },
    });
  } catch (error) {
    console.error('Admin users error:', error);
    res.status(500).json({ error: 'Failed to get users', details: error.message });
  }
});

// Admin: Backfill magic link flag for existing users
app.post('/api/admin/backfill-magic-link-users', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Find all users whose email exists in magic_links with used_at set
    const result = await dbQuery(`
      UPDATE users u
      SET created_via_magic_link = TRUE
      FROM magic_links ml
      WHERE LOWER(u.email) = LOWER(ml.email)
        AND ml.used_at IS NOT NULL
        AND (u.created_via_magic_link IS NULL OR u.created_via_magic_link = FALSE)
    `);

    const updated = result.rowCount || 0;

    // Also get count of magic link users for reference
    const countResult = await dbGet(`
      SELECT COUNT(*) as total FROM users WHERE created_via_magic_link = TRUE
    `);

    res.json({
      ok: true,
      updated,
      totalMagicLinkUsers: parseInt(countResult?.total || 0),
      message: `Backfilled ${updated} users as magic link users`,
    });
  } catch (error) {
    console.error('Backfill magic link error:', error);
    res.status(500).json({ error: 'Failed to backfill', details: error.message });
  }
});

// Admin: Delete obvious fake/test accounts (keyboard spam emails)
app.delete('/api/admin/cleanup-test-accounts', authenticateAdmin, async (req, res) => {
  try {
    // Only delete accounts that match VERY obvious fake patterns
    // Be conservative - only keyboard spam and obvious test emails
    const fakePatterns = [
      "email LIKE 'asdf%'",
      "email LIKE 'qwer%'",
      "email LIKE 'asd@%'",
      "email LIKE 'qwe@%'",
      "email LIKE 'zxc@%'",
      "email LIKE 'fgh@%'",
      "email LIKE 'jkl@%'",
      "email LIKE 'a@a.%'",
      "email LIKE 'aa@aa.%'",
      "email LIKE 'aaa@%'",
      "email LIKE 'aaaa@%'",
      "email LIKE 'test@test.%'",
      "email LIKE '%@example.com'",
      "email LIKE '%@example.org'",
      "email LIKE 'sdfg%'",
      "email LIKE 'dfgh%'",
      "email LIKE 'xcvb%'",
      "email LIKE '123@%'",
      "email LIKE '1234@%'",
    ];

    // First, get the accounts that would be deleted (for logging)
    const toDelete = await dbAll(`
      SELECT id, email, subscription_plan, created_at
      FROM users
      WHERE (${fakePatterns.join(' OR ')})
      AND stripe_customer_id IS NULL
    `);

    if (toDelete.length === 0) {
      return res.json({ message: 'No obvious fake accounts found', deleted: [] });
    }

    // Delete them (only if they don't have active Stripe subscription)
    const result = await dbQuery(`
      DELETE FROM users
      WHERE (${fakePatterns.join(' OR ')})
      AND stripe_customer_id IS NULL
      RETURNING id, email
    `);

    res.json({
      message: `Deleted ${result.rows?.length || 0} fake accounts`,
      deleted: result.rows || toDelete,
    });
  } catch (error) {
    console.error('Cleanup error:', error);
    res.status(500).json({ error: 'Failed to cleanup accounts' });
  }
});

// Admin: Delete all test accounts except specified real users
app.delete('/api/admin/cleanup-all-tests', authenticateAdmin, async (req, res) => {
  try {
    // These are the ONLY real users to keep (owner accounts + verified real users)
    // NOTE: breihosen@gmail.com was a test account, removed from whitelist
    const realEmails = [
      'berend.mainz@gmail.com',
      'berend.mainz@web.de',
      'tiniwi09@gmail.com',
      'rolicupo.twitch@gmail.com',
      'andrehoellering1732004@gmail.com',
      'rolicupo.games@gmail.com',
      'matiasaseff@hotmail.com',
      'clvalentini24@gmail.com',
      'penelopefier@gmail.com',
      // breihosen@gmail.com - REMOVED: was a test account
    ];

    const emailList = realEmails.map(e => `'${e.toLowerCase()}'`).join(', ');

    // Get accounts that will be deleted
    const toDelete = await dbAll(`
      SELECT id, email, subscription_plan, created_at
      FROM users
      WHERE LOWER(email) NOT IN (${emailList})
    `);

    if (toDelete.length === 0) {
      return res.json({
        message: 'No test accounts to delete',
        deleted: [],
        kept: realEmails.length,
      });
    }

    const userIds = toDelete.map(u => u.id);

    // Delete related data first (foreign key constraints) - ignore if table doesn't exist
    const tablesToClean = [
      { table: 'drip_emails', condition: 'user_id = ANY($1)' },
      { table: 'responses', condition: 'user_id = ANY($1)' },
      { table: 'templates', condition: 'user_id = ANY($1)' },
      { table: 'response_templates', condition: 'user_id = ANY($1)' },
      { table: 'team_members', condition: 'team_owner_id = ANY($1) OR member_user_id = ANY($1)' },
      { table: 'api_keys', condition: 'user_id = ANY($1)' },
      { table: 'referrals', condition: 'referrer_id = ANY($1) OR referred_id = ANY($1)' },
      { table: 'password_reset_tokens', condition: 'user_id = ANY($1)' },
      { table: 'email_verification_tokens', condition: 'user_id = ANY($1)' },
      { table: 'affiliate_conversions', condition: 'referred_user_id = ANY($1)' },
      { table: 'affiliates', condition: 'user_id = ANY($1)' },
      { table: 'user_feedback', condition: 'user_id = ANY($1)' },
      { table: 'support_requests', condition: 'user_id = ANY($1)' },
    ];

    for (const { table, condition } of tablesToClean) {
      try {
        await dbQuery(`DELETE FROM ${table} WHERE ${condition}`, [userIds]);
      } catch (e) {
        // Table might not exist, skip
      }
    }

    // Now delete users
    const result = await dbQuery(`
      DELETE FROM users
      WHERE LOWER(email) NOT IN (${emailList})
      RETURNING id, email
    `);

    res.json({
      message: `Deleted ${result.rows?.length || toDelete.length} test accounts`,
      deleted: result.rows || toDelete,
      kept: realEmails.length,
    });
  } catch (error) {
    console.error('Cleanup all tests error:', error);
    res.status(500).json({ error: 'Failed to cleanup', details: error.message });
  }
});

// Admin: Preview and cleanup test data from outreach tables (without deleting users)
// GET = preview what would be cleaned, POST = actually clean
app.all('/api/admin/cleanup-outreach-tests', authenticateAdmin, async (req, res) => {
  try {
    const isDryRun = req.method === 'GET';

    // Find test emails in outreach tables
    const testEmailsInOutreach = await dbAll(`
      SELECT DISTINCT email FROM outreach_emails
      WHERE 1=1 ${getTestEmailExcludeClause('email').replace(/AND /g, 'OR NOT ')}
    `);

    const testEmailsInClicks = await dbAll(`
      SELECT DISTINCT email FROM outreach_clicks
      WHERE 1=1 ${getTestEmailExcludeClause('email').replace(/AND /g, 'OR NOT ')}
    `);

    const testEmailsInTracking = await dbAll(`
      SELECT DISTINCT email FROM outreach_tracking
      WHERE 1=1 ${getTestEmailExcludeClause('email').replace(/AND /g, 'OR NOT ')}
    `);

    // Simpler approach: use the explicit TEST_EMAILS list
    const testEmailsList = TEST_EMAILS.map(e => `'${e}'`).join(', ');

    // Count affected rows
    const emailsCount = await dbGet(`
      SELECT COUNT(*) as count FROM outreach_emails
      WHERE LOWER(email) IN (${testEmailsList})
    `);

    const clicksCount = await dbGet(`
      SELECT COUNT(*) as count FROM outreach_clicks
      WHERE LOWER(email) IN (${testEmailsList})
    `);

    const trackingCount = await dbGet(`
      SELECT COUNT(*) as count FROM outreach_tracking
      WHERE LOWER(email) IN (${testEmailsList})
    `);

    if (isDryRun) {
      return res.json({
        mode: 'preview',
        message: 'This shows what would be deleted. Use POST to actually delete.',
        affected: {
          outreach_emails: parseInt(emailsCount?.count || 0),
          outreach_clicks: parseInt(clicksCount?.count || 0),
          outreach_tracking: parseInt(trackingCount?.count || 0),
        },
        test_emails: TEST_EMAILS,
      });
    }

    // Actually delete
    const deletedEmails = await dbQuery(`
      DELETE FROM outreach_emails
      WHERE LOWER(email) IN (${testEmailsList})
      RETURNING email
    `);

    const deletedClicks = await dbQuery(`
      DELETE FROM outreach_clicks
      WHERE LOWER(email) IN (${testEmailsList})
      RETURNING email
    `);

    const deletedTracking = await dbQuery(`
      DELETE FROM outreach_tracking
      WHERE LOWER(email) IN (${testEmailsList})
      RETURNING email
    `);

    res.json({
      mode: 'executed',
      message: 'Test data cleaned from outreach tables',
      deleted: {
        outreach_emails: deletedEmails.rows?.length || 0,
        outreach_clicks: deletedClicks.rows?.length || 0,
        outreach_tracking: deletedTracking.rows?.length || 0,
      },
    });
  } catch (error) {
    console.error('Outreach cleanup error:', error);
    res.status(500).json({ error: 'Failed to cleanup outreach data', details: error.message });
  }
});

// ==========================================
// OUTREACH EMAIL TRACKING
// ==========================================

// Track email opens via invisible pixel
// GET because it's loaded as an image src
app.get('/api/outreach/track-open', async (req, res) => {
  try {
    const { email, campaign } = req.query;

    if (email && campaign) {
      // Get IP and user agent for analytics
      const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
      const userAgent = req.headers['user-agent'] || '';

      // Store the open event in tracking table
      await dbQuery(
        `INSERT INTO outreach_tracking (email, campaign, ip_address, user_agent)
         VALUES ($1, $2, $3, $4)`,
        [email, campaign, ip.split(',')[0], userAgent]
      );

      // Also update outreach_emails.opened_at (only first open)
      await dbQuery(
        `UPDATE outreach_emails
         SET opened_at = COALESCE(opened_at, NOW())
         WHERE email = $1 AND opened_at IS NULL`,
        [email]
      );

      // Update A/B test open counts
      const emailRecord = await dbGet(
        'SELECT ab_variant FROM outreach_emails WHERE email = $1 AND ab_variant IS NOT NULL ORDER BY sent_at DESC LIMIT 1',
        [email]
      );

      if (emailRecord?.ab_variant) {
        await dbQuery(
          `UPDATE outreach_ab_tests
           SET variant_${emailRecord.ab_variant}_opens = variant_${emailRecord.ab_variant}_opens + 1
           WHERE test_name = 'sequence1_subject' AND is_active = TRUE`,
          []
        );
        console.log(
          `ðŸ“§ Email opened: ${email} (campaign: ${campaign}, A/B variant: ${emailRecord.ab_variant})`
        );
      } else {
        console.log(`ðŸ“§ Email opened: ${email} (campaign: ${campaign})`);
      }
    }
  } catch (error) {
    // Silent fail - don't break email viewing
    console.error('Tracking error:', error.message);
  }

  // Return 1x1 transparent GIF
  const pixel = Buffer.from('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', 'base64');

  res.set({
    'Content-Type': 'image/gif',
    'Content-Length': pixel.length,
    'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
    Pragma: 'no-cache',
    Expires: '0',
  });

  res.send(pixel);
});

// Track email link clicks via redirect
app.get('/api/outreach/track-click', async (req, res) => {
  try {
    const { url, email, campaign } = req.query;

    if (!url) {
      return res.redirect('https://tryreviewresponder.com');
    }

    // Decode the URL
    const targetUrl = decodeURIComponent(url);

    if (email && campaign) {
      const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
      const userAgent = req.headers['user-agent'] || '';

      // Store the click event
      await dbQuery(
        `INSERT INTO outreach_clicks (email, campaign, clicked_url, ip_address, user_agent)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT DO NOTHING`,
        [email, campaign, targetUrl, ip.split(',')[0], userAgent]
      );

      console.log(`ðŸ–±ï¸ Link clicked: ${email} â†’ ${targetUrl} (campaign: ${campaign})`);
    }

    // Redirect to the actual URL
    res.redirect(targetUrl);
  } catch (error) {
    console.error('Click tracking error:', error.message);
    // Fallback redirect on error
    res.redirect(
      req.query.url ? decodeURIComponent(req.query.url) : 'https://tryreviewresponder.com'
    );
  }
});

// Unsubscribe from mailing list (CAN-SPAM compliance)
app.get('/api/outreach/unsubscribe', async (req, res) => {
  try {
    const { email } = req.query;

    if (!email) {
      return res.status(400).send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Unsubscribe - Error</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
            .error { color: #DC2626; }
          </style>
        </head>
        <body>
          <h1 class="error">Invalid Request</h1>
          <p>No email address provided.</p>
        </body>
        </html>
      `);
    }

    const decodedEmail = decodeURIComponent(email).toLowerCase();

    // Add to unsubscribes table
    await dbQuery(
      `INSERT INTO unsubscribes (email, reason)
       VALUES (LOWER($1), 'user_requested')
       ON CONFLICT (email) DO UPDATE SET unsubscribed_at = NOW()`,
      [decodedEmail]
    );

    // Also update outreach_leads status to prevent future contact
    await dbQuery(
      `UPDATE outreach_leads SET status = 'unsubscribed' WHERE LOWER(email) = LOWER($1)`,
      [decodedEmail]
    );

    console.log(`ðŸ“§ Unsubscribed: ${decodedEmail}`);

    // Show confirmation page
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Unsubscribed - ReviewResponder</title>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; color: #111827; }
          .success { color: #059669; font-size: 48px; margin-bottom: 20px; }
          h1 { color: #111827; }
          p { color: #6B7280; line-height: 1.6; }
          .email { background: #F3F4F6; padding: 8px 16px; border-radius: 6px; font-family: monospace; }
        </style>
      </head>
      <body>
        <div class="success">âœ“</div>
        <h1>You've been unsubscribed</h1>
        <p>The email address <span class="email">${decodedEmail}</span> has been removed from our mailing list.</p>
        <p>You will no longer receive marketing emails from ReviewResponder.</p>
        <p style="margin-top: 30px; font-size: 14px;">We're sorry to see you go. If this was a mistake or you have feedback, please email us at <a href="mailto:berend.mainz@web.de">berend.mainz@web.de</a></p>
      </body>
      </html>
    `);
  } catch (error) {
    console.error('Unsubscribe error:', error.message);
    res.status(500).send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Unsubscribe - Error</title>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          .error { color: #DC2626; }
        </style>
      </head>
      <body>
        <h1 class="error">Something went wrong</h1>
        <p>Please try again or email us at <a href="mailto:berend.mainz@web.de">berend.mainz@web.de</a> to be removed from our mailing list.</p>
      </body>
      </html>
    `);
  }
});

// Get outreach stats (admin only - use with secret)
app.get('/api/outreach/stats', async (req, res) => {
  try {
    const { secret } = req.query;

    // Simple secret check for admin access
    if (!process.env.ADMIN_SECRET || !safeCompare(secret, process.env.ADMIN_SECRET)) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get overall stats
    const totalOpens = await dbGet(`SELECT COUNT(*) as count FROM outreach_tracking`);

    // Get unique opens (by email)
    const uniqueOpens = await dbGet(`SELECT COUNT(DISTINCT email) as count FROM outreach_tracking`);

    // Get opens by campaign
    const byCampaign = await dbAll(
      `SELECT campaign,
              COUNT(*) as total_opens,
              COUNT(DISTINCT email) as unique_opens
       FROM outreach_tracking
       GROUP BY campaign
       ORDER BY total_opens DESC`
    );

    // Get recent opens
    const recentOpens = await dbAll(
      `SELECT email, campaign, opened_at
       FROM outreach_tracking
       ORDER BY opened_at DESC
       LIMIT 20`
    );

    // Get opens by day (last 14 days)
    const byDay = await dbAll(
      `SELECT DATE(opened_at) as date, COUNT(*) as opens
       FROM outreach_tracking
       WHERE opened_at > NOW() - INTERVAL '14 days'
       GROUP BY DATE(opened_at)
       ORDER BY date DESC`
    );

    // Click tracking stats
    let totalClicks = { count: 0 };
    let uniqueClicks = { count: 0 };
    let recentClicks = [];
    let clicksByUrl = [];

    try {
      totalClicks = (await dbGet(`SELECT COUNT(*) as count FROM outreach_clicks`)) || { count: 0 };
      uniqueClicks = (await dbGet(
        `SELECT COUNT(DISTINCT email) as count FROM outreach_clicks`
      )) || { count: 0 };

      recentClicks =
        (await dbAll(
          `SELECT email, campaign, clicked_url, clicked_at
         FROM outreach_clicks
         ORDER BY clicked_at DESC
         LIMIT 20`
        )) || [];

      clicksByUrl =
        (await dbAll(
          `SELECT clicked_url, COUNT(*) as clicks
         FROM outreach_clicks
         GROUP BY clicked_url
         ORDER BY clicks DESC
         LIMIT 10`
        )) || [];
    } catch (e) {
      // Table might not exist yet
      console.log('Click tracking tables not ready:', e.message);
    }

    res.json({
      total_opens: parseInt(totalOpens?.count || 0),
      unique_opens: parseInt(uniqueOpens?.count || 0),
      total_clicks: parseInt(totalClicks?.count || 0),
      unique_clicks: parseInt(uniqueClicks?.count || 0),
      by_campaign: byCampaign,
      recent_opens: recentOpens,
      recent_clicks: recentClicks,
      clicks_by_url: clicksByUrl,
      by_day: byDay,
    });
  } catch (error) {
    console.error('Outreach stats error:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// GET /api/outreach/ab-results - Get A/B test results for email subject lines
app.get('/api/outreach/ab-results', async (req, res) => {
  try {
    const { secret } = req.query;

    // Simple secret check for admin access
    if (!process.env.ADMIN_SECRET || !safeCompare(secret, process.env.ADMIN_SECRET)) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get all A/B tests
    const abTests = await dbAll(`
      SELECT * FROM outreach_ab_tests
      ORDER BY created_at DESC
    `);

    // Calculate stats for each test
    const results = abTests.map(test => {
      const variants = [];

      // Variant A
      if (test.variant_a_subject) {
        const openRate =
          test.variant_a_sent > 0
            ? ((test.variant_a_opens / test.variant_a_sent) * 100).toFixed(2)
            : 0;
        variants.push({
          variant: 'A',
          subject: test.variant_a_subject,
          sent: test.variant_a_sent,
          opens: test.variant_a_opens,
          open_rate: parseFloat(openRate),
        });
      }

      // Variant B
      if (test.variant_b_subject) {
        const openRate =
          test.variant_b_sent > 0
            ? ((test.variant_b_opens / test.variant_b_sent) * 100).toFixed(2)
            : 0;
        variants.push({
          variant: 'B',
          subject: test.variant_b_subject,
          sent: test.variant_b_sent,
          opens: test.variant_b_opens,
          open_rate: parseFloat(openRate),
        });
      }

      // Variant C
      if (test.variant_c_subject) {
        const openRate =
          test.variant_c_sent > 0
            ? ((test.variant_c_opens / test.variant_c_sent) * 100).toFixed(2)
            : 0;
        variants.push({
          variant: 'C',
          subject: test.variant_c_subject,
          sent: test.variant_c_sent,
          opens: test.variant_c_opens,
          open_rate: parseFloat(openRate),
        });
      }

      // Variant D
      if (test.variant_d_subject) {
        const openRate =
          test.variant_d_sent > 0
            ? ((test.variant_d_opens / test.variant_d_sent) * 100).toFixed(2)
            : 0;
        variants.push({
          variant: 'D',
          subject: test.variant_d_subject,
          sent: test.variant_d_sent,
          opens: test.variant_d_opens,
          open_rate: parseFloat(openRate),
        });
      }

      // Sort by open rate and determine winner
      const sortedVariants = [...variants].sort((a, b) => b.open_rate - a.open_rate);
      const totalSent = variants.reduce((sum, v) => sum + v.sent, 0);
      const minSampleSize = 30; // Minimum emails per variant for statistical significance

      // Determine winner (only if we have enough data)
      let currentWinner = null;
      let isSignificant = false;
      if (sortedVariants.length > 0 && totalSent >= minSampleSize * sortedVariants.length) {
        const best = sortedVariants[0];
        const secondBest = sortedVariants[1];
        // Winner needs at least 10% better open rate than second place
        if (!secondBest || best.open_rate >= secondBest.open_rate * 1.1) {
          currentWinner = best.variant;
          isSignificant = true;
        }
      }

      return {
        test_name: test.test_name,
        is_active: test.is_active,
        winner: test.winner || currentWinner,
        is_statistically_significant: isSignificant,
        total_sent: totalSent,
        total_opens: variants.reduce((sum, v) => sum + v.opens, 0),
        variants: sortedVariants,
        created_at: test.created_at,
        recommendation:
          isSignificant && currentWinner
            ? `Use variant ${currentWinner}: "${sortedVariants[0].subject}"`
            : `Need more data (${totalSent}/${minSampleSize * variants.length} emails sent)`,
      };
    });

    res.json({
      success: true,
      ab_tests: results,
      summary: {
        total_tests: results.length,
        active_tests: results.filter(t => t.is_active).length,
        tests_with_winner: results.filter(t => t.winner).length,
      },
    });
  } catch (error) {
    console.error('A/B test results error:', error);
    res.status(500).json({ error: 'Failed to get A/B test results' });
  }
});

// POST /api/admin/import-leads - Import scraped leads (G2, Yelp, TripAdvisor)
app.post('/api/admin/import-leads', async (req, res) => {
  try {
    const authKey = req.headers['x-admin-key'] || req.query.key;
    if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const { leads } = req.body;
    if (!leads || !Array.isArray(leads)) {
      return res.status(400).json({ error: 'leads array required' });
    }

    const imported = [];
    const skipped = [];

    for (const lead of leads) {
      try {
        // Determine lead type based on source
        let leadType = 'restaurant';
        if (lead.source?.toLowerCase().includes('g2')) {
          leadType = 'g2_competitor';
        } else if (lead.source?.toLowerCase().includes('tripadvisor')) {
          leadType = 'tripadvisor';
        } else if (lead.source?.toLowerCase().includes('yelp')) {
          leadType = 'yelp';
        }

        // Extract competitor platform from source (e.g., "G2.com Birdeye Reviews" -> "birdeye")
        let competitorPlatform = null;
        if (leadType === 'g2_competitor') {
          const match = lead.source?.match(/g2.*?(birdeye|podium|yext|reputation)/i);
          if (match) {
            competitorPlatform = match[1].toLowerCase();
          }
        }

        // Insert lead
        const result = await dbQuery(
          `INSERT INTO outreach_leads (
            business_name, business_type, address, city, country,
            phone, website, email, contact_name, source,
            lead_type, competitor_platform, pain_points, platform_url,
            job_title, company_size, review_quote, outreach_angle,
            google_rating, google_reviews_count, status
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, 'new')
          ON CONFLICT (business_name, city) DO UPDATE SET
            phone = COALESCE(EXCLUDED.phone, outreach_leads.phone),
            website = COALESCE(EXCLUDED.website, outreach_leads.website),
            email = COALESCE(EXCLUDED.email, outreach_leads.email),
            contact_name = COALESCE(EXCLUDED.contact_name, outreach_leads.contact_name),
            lead_type = EXCLUDED.lead_type,
            competitor_platform = EXCLUDED.competitor_platform,
            pain_points = EXCLUDED.pain_points,
            platform_url = EXCLUDED.platform_url,
            job_title = EXCLUDED.job_title,
            company_size = EXCLUDED.company_size,
            review_quote = EXCLUDED.review_quote,
            outreach_angle = EXCLUDED.outreach_angle
          RETURNING id, business_name`,
          [
            lead.name || lead.business_name,
            lead.type || lead.business_type || 'unknown',
            lead.address || null,
            lead.city || 'Unknown',
            lead.country || 'DE',
            lead.phone || null,
            lead.website || null,
            lead.email || null,
            lead.contact_name || lead.title || null,
            lead.source || 'manual_import',
            leadType,
            competitorPlatform,
            lead.pain_points
              ? `{${lead.pain_points.map(p => `"${p.replace(/"/g, '\\"')}"`).join(',')}}`
              : null,
            lead.platform_url || lead.yelp_url || lead.tripadvisor_url || null,
            lead.title || lead.job_title || null,
            lead.company_size || null,
            lead.quote || lead.review_quote || null,
            lead.outreach_angle || null,
            lead.rating ? parseFloat(lead.rating) : null,
            lead.reviews ? parseInt(lead.reviews) : null,
          ]
        );
        imported.push({ id: result.id, name: result.business_name });
      } catch (err) {
        console.error('Import lead error:', err.message);
        skipped.push({ name: lead.name || lead.business_name, error: err.message });
      }
    }

    res.json({
      success: true,
      imported: imported.length,
      skipped: skipped.length,
      imported_leads: imported,
      skipped_leads: skipped,
    });
  } catch (error) {
    console.error('Import leads error:', error);
    res.status(500).json({ error: 'Failed to import leads' });
  }
});

// GET /api/admin/scraped-leads - Get all scraped leads
app.get('/api/admin/scraped-leads', async (req, res) => {
  try {
    const authKey = req.headers['x-admin-key'] || req.query.key;
    if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const { lead_type, status, limit = 50 } = req.query;

    let query = `SELECT * FROM outreach_leads WHERE 1=1`;
    const params = [];
    let paramIndex = 1;

    if (lead_type) {
      query += ` AND lead_type = $${paramIndex++}`;
      params.push(lead_type);
    }
    if (status) {
      query += ` AND status = $${paramIndex++}`;
      params.push(status);
    }

    query += ` ORDER BY created_at DESC LIMIT $${paramIndex}`;
    params.push(parseInt(limit));

    const leads = await dbAll(query, params);

    res.json({
      total: leads.length,
      leads: leads,
    });
  } catch (error) {
    console.error('Get scraped leads error:', error);
    res.status(500).json({ error: 'Failed to get leads' });
  }
});

// GET /api/admin/clickers - Get leads who clicked email links (HOT LEADS!)
app.get('/api/admin/clickers', async (req, res) => {
  try {
    const authKey = req.headers['x-admin-key'] || req.query.key;
    if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get unique clickers with their lead details + followup status
    const clickers = await dbAll(`
      SELECT DISTINCT ON (c.email)
        c.email,
        c.campaign,
        c.clicked_url,
        c.clicked_at,
        l.id as lead_id,
        l.business_name,
        l.business_type,
        l.city,
        l.phone,
        l.website,
        l.contact_name,
        l.lead_type,
        l.google_reviews_count,
        f.sent_at as followup_sent_at,
        f.demo_booked,
        f.converted
      FROM outreach_clicks c
      LEFT JOIN outreach_leads l ON LOWER(c.email) = LOWER(l.email)
      LEFT JOIN clicker_followups f ON LOWER(c.email) = LOWER(f.email)
      ORDER BY c.email, c.clicked_at DESC
    `);

    // Format for easy LinkedIn search + followup status
    const formattedClickers = clickers.map(c => ({
      email: c.email,
      business_name: c.business_name || 'Unknown',
      contact_name: c.contact_name || null,
      city: c.city || null,
      phone: c.phone || null,
      website: c.website || null,
      lead_type: c.lead_type || 'unknown',
      reviews: c.google_reviews_count || null,
      clicked_at: c.clicked_at,
      campaign: c.campaign,
      // Followup status
      followup_sent_at: c.followup_sent_at || null,
      demo_booked: c.demo_booked || false,
      converted: c.converted || false,
      // For LinkedIn search
      linkedin_search: c.contact_name ? `${c.contact_name} ${c.business_name}` : c.business_name,
    }));

    // Summary stats
    const followedUp = formattedClickers.filter(c => c.followup_sent_at).length;
    const pending = formattedClickers.filter(c => !c.followup_sent_at).length;

    res.json({
      total: formattedClickers.length,
      followed_up: followedUp,
      pending_followup: pending,
      message:
        pending > 0 ? `${pending} clickers need follow-up!` : 'All clickers have been followed up',
      clickers: formattedClickers,
    });
  } catch (error) {
    console.error('Get clickers error:', error);
    res.status(500).json({ error: 'Failed to get clickers' });
  }
});

// GET /api/admin/clicker-followups-debug - Debug endpoint to check clicker_followups table
app.get('/api/admin/clicker-followups-debug', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const followups = await dbAll(`
      SELECT email, sent_at, second_followup_sent, converted, demo_booked
      FROM clicker_followups
      ORDER BY sent_at DESC
    `);
    res.json({ total: followups.length, followups });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// POST /api/admin/send-hot-lead-demos - Send personalized demos to existing hot leads who never got one
// Added 14.01.2026: For hot leads who already received first followup but without a demo
app.post('/api/admin/send-hot-lead-demos', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend && !brevoApi) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Find hot leads who got first followup but no demo_token
    const hotLeads = await dbAll(`
      SELECT f.email, f.sent_at,
        l.id as lead_id, l.business_name, l.city, l.google_reviews_count
      FROM clicker_followups f
      LEFT JOIN outreach_leads l ON LOWER(f.email) = LOWER(l.email)
      WHERE f.demo_token IS NULL
        AND f.converted = FALSE
        AND l.business_name IS NOT NULL
        AND l.city IS NOT NULL
        ${getTestEmailExcludeClause('f.email')}
        AND f.email NOT LIKE '%vimeo%'
      ORDER BY f.sent_at DESC
      LIMIT 20
    `);

    if (hotLeads.length === 0) {
      return res.json({
        success: true,
        sent: 0,
        message: 'No hot leads without demos found',
      });
    }

    let sent = 0;
    let demosGenerated = 0;
    const results = [];

    for (const lead of hotLeads) {
      try {
        const businessName = lead.business_name;
        const city = lead.city;

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'BrÃ¼ssel',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(c => city.toLowerCase().includes(c.toLowerCase()));

        // Generate personalized demo
        console.log(`ðŸŽ¯ Generating demo for existing hot lead: ${businessName}, ${city}`);

        const placeInfo = await lookupPlaceId(businessName, city);
        if (!placeInfo.placeId) {
          console.log(`âš ï¸ Could not find place ID for ${businessName}`);
          results.push({ email: lead.email, business: businessName, error: 'Place not found' });
          continue;
        }

        // Scrape reviews
        const reviewData = await scrapeGoogleReviews(placeInfo.placeId, 5);
        const reviews = reviewData.reviews || [];

        if (reviews.length === 0) {
          console.log(`âš ï¸ No reviews found for ${businessName}`);
          results.push({ email: lead.email, business: businessName, error: 'No reviews' });
          continue;
        }

        // Generate AI responses
        const reviewsToProcess = reviews.slice(0, 3);
        const demos = [];

        for (const review of reviewsToProcess) {
          try {
            const response = await generateDemoResponse(
              review.text || review.snippet || '',
              review.rating || 3,
              placeInfo.name || businessName
            );
            demos.push({
              review: review.text || review.snippet || '',
              rating: review.rating || 3,
              author: review.author || review.author_name || 'Anonymous',
              response: response,
              review_link: review.review_link || review.link || null,
            });
          } catch (e) {
            console.error(`Failed to generate response:`, e.message);
          }
        }

        if (demos.length === 0) {
          results.push({
            email: lead.email,
            business: businessName,
            error: 'Demo generation failed',
          });
          continue;
        }

        // Save demo
        const demoToken = generateDemoToken();
        await dbQuery(
          `INSERT INTO demo_generations
           (business_name, google_place_id, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses, lead_id)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
          [
            placeInfo.name || businessName,
            placeInfo.placeId,
            city,
            placeInfo.rating || null,
            placeInfo.totalReviews || lead.google_reviews_count,
            JSON.stringify(reviews),
            demoToken,
            JSON.stringify(demos),
            lead.lead_id,
          ]
        );

        const demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;
        demosGenerated++;
        console.log(`âœ… Demo generated: ${demoUrl}`);

        // Update clicker_followups with demo_token
        await dbQuery(
          `UPDATE clicker_followups SET demo_token = $1 WHERE LOWER(email) = LOWER($2)`,
          [demoToken, lead.email]
        );

        // Send email with demo (HTML with CTA button)
        let subject, textBody, htmlBody;
        const demosText = demos.length === 1 ? '1 AI-generated response' : `${demos.length} AI-generated responses`;
        const demosTextDE = demos.length === 1 ? '1 AI-generierte Antwort' : `${demos.length} AI-generierte Antworten`;

        if (isGerman) {
          subject = `Hab mal was fÃ¼r ${businessName} gebaut`;
          textBody = `Hey,

ich hab mir gedacht, statt nochmal nach einem Call zu fragen, zeig ich euch einfach was ReviewResponder kann.

Hier ${demos.length === 1 ? 'ist' : 'sind'} ${demosTextDE} auf eure echten Google Bewertungen:
${demoUrl}

Dauert 30 Sekunden zu checken ob der Ton passt.

Falls es gefÃ¤llt: 20 Antworten/Monat sind kostenlos.
Falls nicht: Kein Problem.

GrÃ¼ÃŸe,
Berend`;

          htmlBody = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
  <p>Hey,</p>
  <p>ich hab mir gedacht, statt nochmal nach einem Call zu fragen, zeig ich euch einfach was ReviewResponder kann.</p>
  <p>Hier ${demos.length === 1 ? 'ist' : 'sind'} <strong>${demosTextDE}</strong> auf eure echten Google Bewertungen:</p>

  <div style="text-align: center; margin: 32px 0;">
    <a href="${demoUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
      â†’ AI-Antworten fÃ¼r ${businessName} ansehen
    </a>
  </div>

  <p style="color: #6b7280; font-size: 14px;">Dauert 30 Sekunden zu checken ob der Ton passt.<br>Falls es gefÃ¤llt: 20 Antworten/Monat sind kostenlos.<br>Falls nicht: Kein Problem.</p>

  <p>GrÃ¼ÃŸe,<br><strong>Berend</strong></p>
</div>`;
        } else {
          subject = `Built something for ${businessName}`;
          textBody = `Hey,

Instead of asking for another call, I figured I'd just show you what ReviewResponder can do.

Here ${demos.length === 1 ? 'is' : 'are'} ${demosText} to your actual Google reviews:
${demoUrl}

Takes 30 seconds to see if the tone matches your brand.

If you like it: 20 responses/month are free.
If not: No worries.

Best,
Berend`;

          htmlBody = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
  <p>Hey,</p>
  <p>Instead of asking for another call, I figured I'd just show you what ReviewResponder can do.</p>
  <p>Here ${demos.length === 1 ? 'is' : 'are'} <strong>${demosText}</strong> to your actual Google reviews:</p>

  <div style="text-align: center; margin: 32px 0;">
    <a href="${demoUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
      â†’ See AI Responses for ${businessName}
    </a>
  </div>

  <p style="color: #6b7280; font-size: 14px;">Takes 30 seconds to see if the tone matches your brand.<br>If you like it: 20 responses/month are free.<br>If not: No worries.</p>

  <p>Best,<br><strong>Berend</strong></p>
</div>`;
        }

        // Send via Brevo (to avoid hitting Resend limits)
        if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: {
              name: 'Berend from ReviewResponder',
              email: 'outreach@tryreviewresponder.com',
            },
            to: [{ email: lead.email }],
            subject: subject,
            htmlContent: htmlBody,
            textContent: textBody,
            tags: ['hot_lead_demo'],
          });
        } else if (resend) {
          await resend.emails.send({
            from: OUTREACH_FROM_EMAIL,
            to: lead.email,
            subject: subject,
            html: htmlBody,
            text: textBody,
            tags: [{ name: 'campaign', value: 'hot_lead_demo' }],
          });
        }

        sent++;
        results.push({
          email: lead.email,
          business: businessName,
          demo_url: demoUrl,
          success: true,
        });

        // Rate limit
        await new Promise(r => setTimeout(r, 3000));
      } catch (err) {
        console.error(`Failed to process hot lead ${lead.email}:`, err.message);
        results.push({ email: lead.email, error: err.message });
      }
    }

    res.json({
      success: true,
      hot_leads_found: hotLeads.length,
      demos_generated: demosGenerated,
      emails_sent: sent,
      results: results,
    });
  } catch (error) {
    console.error('Send hot lead demos error:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET/POST /api/cron/followup-clickers - Auto-send PERSONALIZED DEMO to people who clicked
// Updated 14.01.2026: Now generates actual demo with AI responses instead of asking for Zoom call
app.all('/api/cron/followup-clickers', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Create tracking table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS clicker_followups (
        id SERIAL PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        demo_booked BOOLEAN DEFAULT FALSE,
        converted BOOLEAN DEFAULT FALSE
      )
    `);

    // Add demo_token column if not exists
    try {
      await dbQuery(`ALTER TABLE clicker_followups ADD COLUMN IF NOT EXISTS demo_token TEXT`);
    } catch (e) {
      /* Column might already exist */
    }

    // Find clickers who haven't received follow-up yet
    const clickers = await dbAll(`
      SELECT DISTINCT c.email, c.clicked_at,
        l.id as lead_id, l.business_name, l.contact_name, l.city, l.phone,
        l.google_reviews_count, l.website
      FROM outreach_clicks c
      LEFT JOIN outreach_leads l ON LOWER(c.email) = LOWER(l.email)
      LEFT JOIN clicker_followups f ON LOWER(c.email) = LOWER(f.email)
      WHERE f.id IS NULL
        ${getTestEmailExcludeClause('c.email')}
      ORDER BY c.clicked_at DESC
      LIMIT 20
    `);

    let sent = 0;
    let demosGenerated = 0;
    let skippedParallelSafe = 0;
    const results = [];

    for (const clicker of clickers) {
      try {
        // PARALLEL-SAFE: Check if this email was recently processed
        const recentlySent = await wasEmailRecentlySent(clicker.email, 'clicker_followup', 60);
        if (recentlySent) {
          console.log(`â­ï¸ Skipping ${clicker.email} - clicker followup recently sent`);
          skippedParallelSafe++;
          continue;
        }

        const businessName = clicker.business_name || 'your restaurant';
        const reviewCount = clicker.google_reviews_count || null;
        const city = clicker.city || '';

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'BrÃ¼ssel',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(c => city.toLowerCase().includes(c.toLowerCase()));

        // Try to generate a personalized demo for this business
        let demoUrl = null;
        let demoToken = null;
        let demoGenerated = false;
        let demosCount = 3; // Default fallback

        if (businessName && businessName !== 'your restaurant' && city) {
          try {
            // Check if demo already exists for this lead
            const existingDemo = await dbGet(
              'SELECT demo_token, generated_responses FROM demo_generations WHERE lead_id = $1',
              [clicker.lead_id]
            );

            if (existingDemo?.demo_token) {
              demoToken = existingDemo.demo_token;
              demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;
              // Get actual demo count from existing data
              try {
                const responses = JSON.parse(existingDemo.generated_responses || '[]');
                demosCount = responses.length || 3;
              } catch (e) {
                demosCount = 3;
              }
              console.log(`ðŸ“‹ Using existing demo for ${businessName}: ${demoUrl} (${demosCount} responses)`);
            } else {
              // Generate new demo
              console.log(`ðŸŽ¯ Generating demo for hot lead: ${businessName}, ${city}`);

              // Lookup place ID
              const placeInfo = await lookupPlaceId(businessName, city);
              if (placeInfo.placeId) {
                // Scrape reviews
                const reviewData = await scrapeGoogleReviews(placeInfo.placeId, 5);
                const reviews = reviewData.reviews || [];

                if (reviews.length > 0) {
                  // Generate AI responses for up to 3 reviews
                  const reviewsToProcess = reviews.slice(0, 3);
                  const demos = [];

                  for (const review of reviewsToProcess) {
                    try {
                      const response = await generateDemoResponse(
                        review.text || review.snippet || '',
                        review.rating || 3,
                        placeInfo.name || businessName
                      );
                      demos.push({
                        review: review.text || review.snippet || '',
                        rating: review.rating || 3,
                        author: review.author || review.author_name || 'Anonymous',
                        response: response,
                        review_link: review.review_link || review.link || null,
                      });
                    } catch (e) {
                      console.error(`Failed to generate response for review:`, e.message);
                    }
                  }

                  if (demos.length > 0) {
                    // Save demo to database
                    demoToken = generateDemoToken();
                    await dbQuery(
                      `INSERT INTO demo_generations
                       (business_name, google_place_id, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses, lead_id)
                       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
                      [
                        placeInfo.name || businessName,
                        placeInfo.placeId,
                        city,
                        placeInfo.rating || null,
                        placeInfo.totalReviews || reviewCount,
                        JSON.stringify(reviews),
                        demoToken,
                        JSON.stringify(demos),
                        clicker.lead_id,
                      ]
                    );

                    demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;
                    demoGenerated = true;
                    demosCount = demos.length;
                    demosGenerated++;
                    console.log(`âœ… Demo generated for ${businessName}: ${demoUrl} (${demosCount} responses)`);
                  }
                }
              }
            }
          } catch (demoError) {
            console.error(`Failed to generate demo for ${businessName}:`, demoError.message);
          }
        }

        let subject, textBody, htmlBody;

        if (demoUrl) {
          // Email WITH personalized demo link - much better conversion!
          const demosTextEN = demosCount === 1 ? '1 AI-generated response' : `${demosCount} AI-generated responses`;
          const demosTextDE = demosCount === 1 ? '1 AI-generierte Antwort' : `${demosCount} AI-generierte Antworten`;

          if (isGerman) {
            subject = `${demosCount} AI-Antworten fÃ¼r ${businessName} â€“ schon fertig`;
            textBody = `Hey,

ich hab gesehen, dass ihr auf meine Email geklickt habt.

Statt lange zu reden, hab ich einfach mal gemacht: Hier ${demosCount === 1 ? 'ist' : 'sind'} ${demosTextDE} auf eure echten Google Bewertungen:

${demoUrl}

Schaut euch an ob der Ton passt. Dauert 30 Sekunden.

Falls es gefÃ¤llt: 20 Antworten/Monat sind kostenlos. Falls nicht: Kein Problem, einfach ignorieren.

GrÃ¼ÃŸe,
Berend

P.S. Code DEMO30 = 30% Rabatt wenn ihr upgraden wollt.`;

            htmlBody = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
  <p>Hey,</p>
  <p>ich hab gesehen, dass ihr auf meine Email geklickt habt.</p>
  <p>Statt lange zu reden, hab ich einfach mal gemacht: Hier ${demosCount === 1 ? 'ist' : 'sind'} <strong>${demosTextDE}</strong> auf eure echten Google Bewertungen:</p>

  <div style="text-align: center; margin: 32px 0;">
    <a href="${demoUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
      â†’ AI-Antworten fÃ¼r ${businessName} ansehen
    </a>
  </div>

  <p style="color: #6b7280; font-size: 14px;">Schaut euch an ob der Ton passt. Dauert 30 Sekunden.<br>Falls es gefÃ¤llt: 20 Antworten/Monat sind kostenlos.<br>Falls nicht: Kein Problem, einfach ignorieren.</p>

  <p>GrÃ¼ÃŸe,<br><strong>Berend</strong></p>
  <p style="color: #6b7280; font-size: 13px;">P.S. Code DEMO30 = 30% Rabatt wenn ihr upgraden wollt.</p>
</div>`;
          } else {
            subject = `${demosCount} AI responses for ${businessName} â€“ already done`;
            textBody = `Hey,

I noticed someone from ${businessName} clicked on my email.

Instead of asking for a call, I just went ahead and made this for you: ${demosTextEN} to your actual Google reviews:

${demoUrl}

Takes 30 seconds to see if the tone matches your brand.

If you like it: 20 responses/month are free. If not: No worries, just ignore this.

Best,
Berend

P.S. Use code DEMO30 for 30% off if you upgrade.`;

            htmlBody = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
  <p>Hey,</p>
  <p>I noticed someone from ${businessName} clicked on my email.</p>
  <p>Instead of asking for a call, I just went ahead and made this for you: <strong>${demosTextEN}</strong> to your actual Google reviews:</p>

  <div style="text-align: center; margin: 32px 0;">
    <a href="${demoUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
      â†’ See AI Responses for ${businessName}
    </a>
  </div>

  <p style="color: #6b7280; font-size: 14px;">Takes 30 seconds to see if the tone matches your brand.<br>If you like it: 20 responses/month are free.<br>If not: No worries, just ignore this.</p>

  <p>Best,<br><strong>Berend</strong></p>
  <p style="color: #6b7280; font-size: 13px;">P.S. Use code DEMO30 for 30% off if you upgrade.</p>
</div>`;
          }
        } else {
          // Fallback email WITHOUT demo (if demo generation failed)
          const fallbackUrl = 'https://tryreviewresponder.com?ref=hot_lead';

          if (isGerman) {
            const reviewText = reviewCount
              ? `Mit Ã¼ber ${reviewCount.toLocaleString('de-DE')} Google Bewertungen`
              : 'Mit so vielen Bewertungen';
            subject = reviewCount
              ? `${reviewCount.toLocaleString('de-DE')}+ Bewertungen â€“ wie antwortet ihr?`
              : `Kurze Frage zu ${businessName}`;

            textBody = `Hey,

ich hab gesehen, dass ihr auf meine Email geklickt habt.

${reviewText} habt ihr wahrscheinlich einiges zu tun beim Beantworten. ReviewResponder macht das in Sekunden statt Minuten.

Hier kÃ¶nnt ihr es direkt an euren echten Bewertungen testen:
${fallbackUrl}

20 Antworten/Monat kostenlos, keine Kreditkarte.

GrÃ¼ÃŸe,
Berend

P.S. Code DEMO30 = 30% Rabatt wenn ihr upgraden wollt.`;

            htmlBody = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
  <p>Hey,</p>
  <p>ich hab gesehen, dass ihr auf meine Email geklickt habt.</p>
  <p>${reviewText} habt ihr wahrscheinlich einiges zu tun beim Beantworten. ReviewResponder macht das in Sekunden statt Minuten.</p>

  <div style="text-align: center; margin: 32px 0;">
    <a href="${fallbackUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
      â†’ Jetzt kostenlos testen
    </a>
  </div>

  <p style="color: #6b7280; font-size: 14px;">20 Antworten/Monat kostenlos, keine Kreditkarte.</p>

  <p>GrÃ¼ÃŸe,<br><strong>Berend</strong></p>
  <p style="color: #6b7280; font-size: 13px;">P.S. Code DEMO30 = 30% Rabatt wenn ihr upgraden wollt.</p>
</div>`;
          } else {
            const reviewText = reviewCount
              ? `${reviewCount.toLocaleString()} reviews`
              : 'hundreds of reviews';
            subject = reviewCount
              ? `${reviewCount.toLocaleString()}+ reviews â€“ how do you respond?`
              : `Quick question about ${businessName}`;

            textBody = `Hey,

I noticed someone from ${businessName} clicked on my email.

With ${reviewText}, responding to all of them takes time. ReviewResponder does it in seconds instead of minutes.

Try it on your actual reviews here:
${fallbackUrl}

20 responses/month free, no credit card.

Best,
Berend

P.S. Use code DEMO30 for 30% off if you upgrade.`;

            htmlBody = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; line-height: 1.6; color: #374151;">
  <p>Hey,</p>
  <p>I noticed someone from ${businessName} clicked on my email.</p>
  <p>With ${reviewText}, responding to all of them takes time. ReviewResponder does it in seconds instead of minutes.</p>

  <div style="text-align: center; margin: 32px 0;">
    <a href="${fallbackUrl}" style="display: inline-block; background: #2563eb; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
      â†’ Try It Free Now
    </a>
  </div>

  <p style="color: #6b7280; font-size: 14px;">20 responses/month free, no credit card.</p>

  <p>Best,<br><strong>Berend</strong></p>
  <p style="color: #6b7280; font-size: 13px;">P.S. Use code DEMO30 for 30% off if you upgrade.</p>
</div>`;
          }
        }

        await resend.emails.send({
          from: OUTREACH_FROM_EMAIL,
          to: clicker.email,
          subject: subject,
          html: htmlBody,
          text: textBody,
          tags: [{ name: 'campaign', value: 'clicker_followup' }],
        });

        // Track that we sent follow-up (with demo token if generated)
        await dbQuery(
          `INSERT INTO clicker_followups (email, demo_token) VALUES ($1, $2) ON CONFLICT (email) DO UPDATE SET demo_token = $2`,
          [clicker.email, demoToken]
        );

        // PARALLEL-SAFE: Record in history
        await recordEmailSend(clicker.email, 'clicker_followup', 1, `clicker:${clicker.email}:${Date.now()}`);

        sent++;
        results.push({
          email: clicker.email,
          business: businessName,
          demo_url: demoUrl,
          demo_generated: demoGenerated,
        });

        // Longer delay between emails due to demo generation
        await new Promise(r => setTimeout(r, 2000));
      } catch (err) {
        console.error(`Failed to send followup to ${clicker.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      sent: sent,
      demos_generated: demosGenerated,
      skipped_parallel_safe: skippedParallelSafe,
      followups_sent: results,
      message:
        sent > 0 ? `Sent ${sent} personalized demos to hot leads!` : 'No new clickers to follow up',
    });
  } catch (error) {
    console.error('Clicker followup error:', error);
    res.status(500).json({ error: 'Failed to send followups' });
  }
});

// GET /api/cron/second-followup - Send SECOND follow-up with better offer to clickers who haven't converted
app.all('/api/cron/second-followup', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!brevoApi) {
    return res.status(500).json({ error: 'Brevo not configured' });
  }

  try {
    // Add second_followup_sent column if not exists
    try {
      await dbQuery(
        `ALTER TABLE clicker_followups ADD COLUMN IF NOT EXISTS second_followup_sent TIMESTAMP`
      );
    } catch (e) {
      /* Column might already exist */
    }

    // Check for force parameter to skip 2-day wait
    const forceNow = req.query.force === 'true';

    // Find clickers who received first followup but not second, and haven't converted
    // Include demo_token from first followup to reference their personalized demo
    const clickers = await dbAll(`
      SELECT f.email, f.sent_at as first_followup_sent, f.demo_token,
        l.business_name, l.contact_name, l.city,
        l.google_reviews_count
      FROM clicker_followups f
      LEFT JOIN outreach_leads l ON LOWER(f.email) = LOWER(l.email)
      WHERE f.converted = FALSE
        AND f.second_followup_sent IS NULL
        ${forceNow ? '' : "AND f.sent_at < NOW() - INTERVAL '2 days'"}
        ${getTestEmailExcludeClause('f.email')}
        AND f.email NOT LIKE '%vimeo%'
      ORDER BY f.sent_at ASC
      LIMIT 20
    `);

    if (clickers.length === 0) {
      // Debug: Check how many are in clicker_followups table
      const total = await dbQuery(`SELECT COUNT(*) as count FROM clicker_followups`);
      const notConverted = await dbQuery(
        `SELECT COUNT(*) as count FROM clicker_followups WHERE converted = FALSE`
      );
      const noSecond = await dbQuery(
        `SELECT COUNT(*) as count FROM clicker_followups WHERE converted = FALSE AND second_followup_sent IS NULL`
      );
      return res.json({
        success: true,
        sent: 0,
        message: 'No clickers ready for second follow-up',
        debug: {
          total_in_followups: parseInt(total?.count || 0),
          not_converted: parseInt(notConverted?.count || 0),
          no_second_sent: parseInt(noSecond?.count || 0),
          force_param: forceNow,
        },
      });
    }

    let sent = 0;
    let skippedParallelSafe = 0;
    const results = [];

    for (const clicker of clickers) {
      try {
        // PARALLEL-SAFE: Check if second followup was recently sent
        const recentlySent = await wasEmailRecentlySent(clicker.email, 'second_followup', 60);
        if (recentlySent) {
          console.log(`â­ï¸ Skipping ${clicker.email} - second followup recently sent`);
          skippedParallelSafe++;
          continue;
        }

        const businessName = clicker.business_name || 'your restaurant';
        const city = clicker.city || '';
        const demoUrl = clicker.demo_token
          ? `https://tryreviewresponder.com/demo/${clicker.demo_token}`
          : null;

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'BrÃ¼ssel',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(c => city.toLowerCase().includes(c.toLowerCase()));

        let subject, body;

        if (isGerman) {
          // German second follow-up - with demo link if available
          subject = `Letzte Chance: 1 Monat gratis fÃ¼r ${businessName}`;
          const demoLine = demoUrl
            ? `\nFalls ihr die Demo noch nicht gesehen habt:\n${demoUrl}\n`
            : '';
          body = `Hey,

ich melde mich ein letztes Mal.
${demoLine}
Mein Angebot: 1 VOLLER MONAT KOSTENLOS fÃ¼r ${businessName}.

Nicht 20 Antworten â€“ unbegrenzt. Ich richte es fÃ¼r euch ein.

Interesse? Einfach auf diese Email antworten.

GrÃ¼ÃŸe,
Berend

P.S. Keine Antwort = kein Interesse. Kein Problem, dann hÃ¶re ich auf.`;
        } else {
          // English second follow-up - with demo link if available
          subject = `Last chance: 1 month free for ${businessName}`;
          const demoLine = demoUrl ? `\nIf you haven't seen the demo yet:\n${demoUrl}\n` : '';
          body = `Hey,

Last email from me.
${demoLine}
My offer: 1 FULL MONTH FREE for ${businessName}.

Not 20 responses â€“ unlimited. I'll set it up for you.

Interested? Just reply to this email.

Best,
Berend

P.S. No reply = no interest. No problem, I'll stop reaching out.`;
        }

        await brevoApi.sendTransacEmail({
          sender: { name: 'Berend from ReviewResponder', email: 'outreach@tryreviewresponder.com' },
          to: [{ email: clicker.email }],
          subject: subject,
          textContent: body,
          tags: ['second_followup'],
        });

        // Track second followup
        await dbQuery(
          `UPDATE clicker_followups SET second_followup_sent = NOW() WHERE LOWER(email) = LOWER($1)`,
          [clicker.email]
        );

        // PARALLEL-SAFE: Record in history
        await recordEmailSend(clicker.email, 'second_followup', 2, `second:${clicker.email}:${Date.now()}`);

        sent++;
        results.push({ email: clicker.email, business: businessName });

        // Rate limit
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send second followup to ${clicker.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      sent: sent,
      skipped_parallel_safe: skippedParallelSafe,
      followups_sent: results,
      message: sent > 0 ? `Sent ${sent} second follow-ups with better offer!` : 'No emails sent',
    });
  } catch (error) {
    console.error('Second followup error:', error);
    res.status(500).json({ error: 'Failed to send second followups' });
  }
});

// GET /api/cron/hot-lead-attack - HIGH FREQUENCY follow-up for recent clickers (every 2 hours)
// Added 14.01.2026: Part of Night Turbo Automation System
app.get('/api/cron/hot-lead-attack', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Create hot_lead_attacks tracking table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS hot_lead_attacks (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        lead_id INTEGER,
        attack_type TEXT DEFAULT 'immediate',
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        demo_token TEXT,
        converted_at TIMESTAMP,
        UNIQUE(email, attack_type)
      )
    `);

    // Find clickers from last 4 hours who haven't been attacked yet
    // This runs every 2 hours, so catches people quickly
    const hotClickers = await dbAll(`
      SELECT DISTINCT c.email, c.clicked_at, c.clicked_url,
        l.id as lead_id, l.business_name, l.contact_name, l.city,
        l.google_reviews_count, l.website,
        d.demo_token
      FROM outreach_clicks c
      LEFT JOIN outreach_leads l ON LOWER(c.email) = LOWER(l.email)
      LEFT JOIN demo_generations d ON d.lead_id = l.id
      LEFT JOIN hot_lead_attacks h ON LOWER(c.email) = LOWER(h.email) AND h.attack_type = 'immediate'
      WHERE c.clicked_at > NOW() - INTERVAL '4 hours'
        AND h.id IS NULL
        ${getTestEmailExcludeClause('c.email')}
      ORDER BY c.clicked_at DESC
      LIMIT 30
    `);

    let sent = 0;
    const results = [];

    for (const clicker of hotClickers) {
      try {
        const businessName = clicker.business_name || 'your business';
        const city = clicker.city || '';
        const demoToken = clicker.demo_token;
        const demoUrl = demoToken
          ? `https://tryreviewresponder.com/demo/${demoToken}?discount=DEMO30`
          : null;

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'BrÃ¼ssel',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(gc => city.toLowerCase().includes(gc.toLowerCase()));

        let subject, body;

        if (demoUrl) {
          // They already have a demo - quick nudge
          if (isGerman) {
            subject = `Gesehen aber nicht getestet? ðŸŽ¯`;
            body = `Hey,

ich hab gesehen, dass du gerade auf meine Email geklickt hast.

Falls du die Demo verpasst hast - hier nochmal der direkte Link:
${demoUrl}

30 Sekunden und du weiÃŸt ob ReviewResponder zu ${businessName} passt.

Code DEMO30 = 30% Rabatt wenn du upgraden willst.

GrÃ¼ÃŸe,
Berend`;
          } else {
            subject = `Saw you checking us out ðŸ‘€`;
            body = `Hey,

I noticed you just clicked through to ReviewResponder.

In case you missed the demo I made for ${businessName}:
${demoUrl}

Takes 30 seconds. See if you like them.

Use code DEMO30 for 30% off if you decide to upgrade.

Best,
Berend`;
          }
        } else {
          // No demo yet - offer to make one
          if (isGerman) {
            subject = `Soll ich was fÃ¼r ${businessName} machen?`;
            body = `Hey,

ich hab gesehen, dass du gerade auf meine Email geklickt hast.

Wenn du willst, mache ich dir eine kostenlose Demo mit echten AI-Antworten auf eure Google Bewertungen.

Antworte einfach mit "Ja" und ich schick dir den Link in 5 Minuten.

GrÃ¼ÃŸe,
Berend

P.S. Code DEMO30 = 30% Rabatt wenn du spÃ¤ter upgraden willst.`;
          } else {
            subject = `Want me to make something for ${businessName}?`;
            body = `Hey,

I noticed you just clicked on my email.

Want me to create a free demo with real AI responses to your Google reviews?

Just reply "Yes" and I'll send you the link in 5 minutes.

Best,
Berend

P.S. Use code DEMO30 for 30% off if you upgrade later.`;
          }
        }

        await resend.emails.send({
          from: OUTREACH_FROM_EMAIL,
          to: clicker.email,
          subject: subject,
          text: body,
          tags: [{ name: 'campaign', value: 'hot_lead_attack' }],
        });

        // Track the attack
        await dbQuery(
          `INSERT INTO hot_lead_attacks (email, lead_id, attack_type, demo_token)
           VALUES ($1, $2, 'immediate', $3)
           ON CONFLICT (email, attack_type) DO NOTHING`,
          [clicker.email, clicker.lead_id, demoToken]
        );

        sent++;
        results.push({
          email: clicker.email,
          business: businessName,
          clicked_at: clicker.clicked_at,
          has_demo: !!demoUrl,
        });

        // Rate limit
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to attack hot lead ${clicker.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      sent: sent,
      hot_leads_attacked: results,
      message:
        sent > 0
          ? `ðŸ”¥ Attacked ${sent} hot leads within 4h of clicking!`
          : 'No hot leads to attack right now',
      next_run: 'Every 2 hours',
    });
  } catch (error) {
    console.error('Hot lead attack error:', error);
    res.status(500).json({ error: 'Failed to attack hot leads' });
  }
});

// GET /api/cron/turbo-scrape - Wave-based scraping for 6x more leads per day
// Added 14.01.2026: Part of Night Turbo Automation System
// Runs 6 times per day at: 00:00, 04:00, 08:00, 12:00, 16:00, 20:00
app.get('/api/cron/turbo-scrape', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const wave = parseInt(req.query.wave) || 1;
  console.log(`ðŸŒŠ Starting Turbo Scrape Wave ${wave}...`);

  // Wave-based city distribution for global coverage
  const waveConfig = {
    1: {
      // 00:00 UTC - DACH Region
      cities: ['Berlin', 'MÃ¼nchen', 'Hamburg', 'Wien', 'ZÃ¼rich'],
      name: 'DACH Night',
    },
    2: {
      // 04:00 UTC - US East Coast
      cities: ['New York', 'Boston', 'Philadelphia', 'Miami', 'Chicago'],
      name: 'US East',
    },
    3: {
      // 08:00 UTC - US West Coast
      cities: ['Los Angeles', 'San Francisco', 'Seattle', 'Denver', 'Phoenix'],
      name: 'US West',
    },
    4: {
      // 12:00 UTC - UK & Ireland
      cities: ['London', 'Dublin', 'Manchester', 'Edinburgh', 'Birmingham'],
      name: 'UK Ireland',
    },
    5: {
      // 16:00 UTC - Benelux & Scandinavia
      cities: ['Amsterdam', 'BrÃ¼ssel', 'Copenhagen', 'Stockholm', 'Oslo'],
      name: 'Benelux Nordic',
    },
    6: {
      // 20:00 UTC - Random rotation of all other cities
      cities: ['Leipzig', 'Dresden', 'Salzburg', 'Graz', 'Basel', 'Austin', 'Portland', 'Atlanta'],
      name: 'Random Mix',
    },
  };

  const config = waveConfig[wave] || waveConfig[1];
  const cities = config.cities;

  // Rotate through 3 industries per wave (20 total industries / 6 waves â‰ˆ 3 per wave)
  const industries = [
    'restaurant',
    'hotel',
    'dental office',
    'law firm',
    'auto repair shop',
    'hair salon',
    'gym',
    'real estate agency',
    'medical clinic',
    'retail store',
    'spa',
    'veterinary clinic',
    'physiotherapy',
    'accounting firm',
    'bakery',
    'coffee shop',
    'car dealership',
    'optician',
    'pharmacy',
    'florist',
  ];

  // Pick 3 industries based on wave number
  const industryStartIdx = ((wave - 1) * 3) % industries.length;
  const waveIndustries = [
    industries[industryStartIdx % industries.length],
    industries[(industryStartIdx + 1) % industries.length],
    industries[(industryStartIdx + 2) % industries.length],
  ];

  let totalScraped = 0;
  let totalSkipped = 0;
  const results = [];

  if (!process.env.GOOGLE_PLACES_API_KEY) {
    return res.status(500).json({ error: 'Google Places API not configured' });
  }

  try {
    // Scrape each city + industry combination
    for (const city of cities) {
      for (const industry of waveIndustries) {
        try {
          const scrapeUrl = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(industry + ' in ' + city)}&key=${process.env.GOOGLE_PLACES_API_KEY}`;
          const response = await fetch(scrapeUrl);
          const data = await response.json();

          if (data.results) {
            let cityScraped = 0;
            let citySkipped = 0;

            for (const place of data.results.slice(0, 10)) {
              // 10 per combo to save API costs
              try {
                // Check if lead already exists (dedup)
                const existing = await dbGet(
                  'SELECT id FROM outreach_leads WHERE LOWER(business_name) = LOWER($1) AND LOWER(city) = LOWER($2)',
                  [place.name, city]
                );

                if (existing) {
                  citySkipped++;
                  continue;
                }

                // Fetch Place Details
                const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${place.place_id}&fields=name,formatted_address,formatted_phone_number,website,rating,user_ratings_total,reviews&key=${process.env.GOOGLE_PLACES_API_KEY}`;
                const detailsResponse = await fetch(detailsUrl);
                const details = await detailsResponse.json();

                if (details.status === 'OK') {
                  const result = details.result;

                  // Find worst review for personalization
                  let worstReview = null;
                  if (result.reviews && result.reviews.length > 0) {
                    const badReviews = result.reviews.filter(r => r.rating <= 2);
                    if (badReviews.length > 0) {
                      worstReview = badReviews.reduce((worst, current) =>
                        (current.text?.length || 0) > (worst.text?.length || 0) ? current : worst
                      );
                    }
                  }

                  await dbQuery(
                    `INSERT INTO outreach_leads (business_name, business_type, city, address, phone, website, google_rating, google_reviews_count, source, worst_review_text, worst_review_rating, worst_review_author, has_bad_review)
                     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'turbo_scrape', $9, $10, $11, $12)
                     ON CONFLICT (business_name, city) DO NOTHING`,
                    [
                      result.name,
                      industry,
                      city,
                      result.formatted_address || null,
                      result.formatted_phone_number || null,
                      result.website || null,
                      result.rating || null,
                      result.user_ratings_total || null,
                      worstReview?.text || null,
                      worstReview?.rating || null,
                      worstReview?.author_name || null,
                      worstReview !== null,
                    ]
                  );
                  cityScraped++;
                  totalScraped++;
                }

                // Rate limiting
                await new Promise(r => setTimeout(r, 150));
              } catch (e) {
                console.error(`Place details error for ${place.name}:`, e.message);
              }
            }

            results.push({
              city,
              industry,
              scraped: cityScraped,
              skipped: citySkipped,
            });
            totalSkipped += citySkipped;
          }

          // Rate limit between searches
          await new Promise(r => setTimeout(r, 300));
        } catch (e) {
          console.error(`Scrape error for ${city} ${industry}:`, e.message);
        }
      }
    }

    res.json({
      success: true,
      wave: wave,
      wave_name: config.name,
      cities: cities,
      industries: waveIndustries,
      total_scraped: totalScraped,
      total_skipped: totalSkipped,
      breakdown: results,
      message: `ðŸŒŠ Wave ${wave} complete: Scraped ${totalScraped} new leads, skipped ${totalSkipped} existing`,
      next_wave: wave < 6 ? wave + 1 : 1,
    });
  } catch (error) {
    console.error('Turbo scrape error:', error);
    res.status(500).json({ error: 'Failed to run turbo scrape' });
  }
});

// GET /api/cron/turbo-email - Wave-based email sending for 4x more emails per day
// Added 14.01.2026: Part of Night Turbo Automation System
// Runs 4 times per day at: 07:00, 13:00, 14:00, 20:00 UTC
app.get('/api/cron/turbo-email', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const wave = parseInt(req.query.wave) || 1;
  console.log(`ðŸ“§ Starting Turbo Email Wave ${wave}...`);

  // Wave-based geographic targeting for optimal delivery times
  const waveConfig = {
    1: {
      // 07:00 UTC = 08:00 CET - DACH Morning
      regions: [
        'Berlin',
        'MÃ¼nchen',
        'Hamburg',
        'Wien',
        'ZÃ¼rich',
        'Frankfurt',
        'KÃ¶ln',
        'Stuttgart',
        'DÃ¼sseldorf',
      ],
      name: 'DACH Morning',
      limit: 100,
    },
    2: {
      // 13:00 UTC = 14:00 CET - DACH Afternoon
      regions: ['Leipzig', 'Dresden', 'Salzburg', 'Graz', 'Basel', 'Bern', 'Amsterdam', 'BrÃ¼ssel'],
      name: 'DACH Afternoon',
      limit: 100,
    },
    3: {
      // 14:00 UTC = 09:00 EST - US Morning
      regions: ['New York', 'Boston', 'Philadelphia', 'Miami', 'Chicago', 'Atlanta', 'Washington'],
      name: 'US East Morning',
      limit: 100,
    },
    4: {
      // 20:00 UTC = 15:00 EST = 12:00 PST - US Afternoon
      regions: [
        'Los Angeles',
        'San Francisco',
        'Seattle',
        'Denver',
        'Phoenix',
        'Portland',
        'Las Vegas',
      ],
      name: 'US West Afternoon',
      limit: 100,
    },
  };

  const config = waveConfig[wave] || waveConfig[1];

  if (!resend && !brevoApi) {
    return res.status(500).json({ error: 'No email service configured' });
  }

  try {
    // Find leads with emails that haven't been emailed yet, filtered by region
    const regionFilter = config.regions.map(r => `'${r.replace(/'/g, "''")}'`).join(',');
    const leads = await dbAll(`
      SELECT l.id, l.business_name, l.email, l.contact_name, l.city, l.website,
        l.google_rating, l.google_reviews_count, l.worst_review_text, l.worst_review_author,
        d.demo_token
      FROM outreach_leads l
      LEFT JOIN outreach_emails oe ON LOWER(l.email) = LOWER(oe.email)
      LEFT JOIN demo_generations d ON d.lead_id = l.id
      WHERE l.email IS NOT NULL
        AND oe.id IS NULL
        AND l.city IN (${regionFilter})
        ${getTestEmailExcludeClause('l.email')}
      ORDER BY RANDOM()
      LIMIT ${config.limit}
    `);

    let sent = 0;
    let failed = 0;
    const results = [];

    for (const lead of leads) {
      try {
        const businessName = lead.business_name || 'your business';
        const firstName = lead.contact_name?.split(' ')[0] || '';
        const city = lead.city || '';

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'BrÃ¼ssel',
          'Leipzig',
          'Dresden',
          'Salzburg',
          'Graz',
          'Basel',
          'Bern',
          'Amsterdam',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(gc => city.toLowerCase().includes(gc.toLowerCase()));

        // Build demo URL with discount if available
        const demoUrl = lead.demo_token
          ? `https://tryreviewresponder.com/demo/${lead.demo_token}?discount=DEMO30`
          : 'https://tryreviewresponder.com?ref=turbo_email';

        let subject, body;

        if (isGerman) {
          // A/B test subjects based on wave
          const subjects = [
            `${businessName} - AI antwortet auf Bewertungen`,
            `Automatische Antworten fÃ¼r ${businessName}?`,
            `3 Sekunden pro Bewertung statt 5 Minuten`,
          ];
          subject = subjects[(wave - 1) % subjects.length];

          body = `Hey${firstName ? ` ${firstName}` : ''},

ich hab ReviewResponder gebaut - AI die auf Google Bewertungen antwortet. Klingt simpel, spart aber 80% Zeit.

${lead.demo_token ? `Hier ist eine Demo fÃ¼r ${businessName}:\n${demoUrl}` : `Teste es direkt:\n${demoUrl}`}

20 Antworten/Monat kostenlos, keine Kreditkarte.

GrÃ¼ÃŸe,
Berend

P.S. Code DEMO30 = 30% Rabatt wenn du upgraden willst.`;
        } else {
          // A/B test subjects based on wave
          const subjects = [
            `${businessName} - AI replies to reviews`,
            `Automated responses for ${businessName}?`,
            `3 seconds per review instead of 5 minutes`,
          ];
          subject = subjects[(wave - 1) % subjects.length];

          body = `Hey${firstName ? ` ${firstName}` : ''},

I built ReviewResponder - AI that replies to Google reviews. Sounds simple, saves 80% of time.

${lead.demo_token ? `Here's a demo for ${businessName}:\n${demoUrl}` : `Try it directly:\n${demoUrl}`}

20 responses/month free, no credit card.

Best,
Berend

P.S. Use code DEMO30 for 30% off if you upgrade.`;
        }

        // Use Resend for first 100, Brevo as backup
        const emailService = sent < 50 && resend ? 'resend' : 'brevo';

        if (emailService === 'resend' && resend) {
          await resend.emails.send({
            from: OUTREACH_FROM_EMAIL,
            to: lead.email,
            subject: subject,
            text: body,
            tags: [{ name: 'campaign', value: `turbo_email_wave${wave}` }],
          });
        } else if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: {
              name: 'Berend from ReviewResponder',
              email: 'outreach@tryreviewresponder.com',
            },
            to: [{ email: lead.email }],
            subject: subject,
            textContent: body,
            tags: [`turbo_email_wave${wave}`],
          });
        }

        // Track the email
        await dbQuery(
          `INSERT INTO outreach_emails (email, subject, body, campaign, lead_id)
           VALUES ($1, $2, $3, $4, $5)
           ON CONFLICT (email) DO NOTHING`,
          [lead.email, subject, body, `turbo_email_wave${wave}`, lead.id]
        );

        sent++;
        results.push({
          email: lead.email,
          business: businessName,
          city: city,
          has_demo: !!lead.demo_token,
        });

        // Rate limit
        await new Promise(r => setTimeout(r, 300));
      } catch (err) {
        console.error(`Failed to send turbo email to ${lead.email}:`, err.message);
        failed++;
      }
    }

    res.json({
      success: true,
      wave: wave,
      wave_name: config.name,
      regions: config.regions,
      sent: sent,
      failed: failed,
      leads_found: leads.length,
      emails_sent: results,
      message: `ðŸ“§ Wave ${wave} complete: Sent ${sent} emails to ${config.name} region`,
      daily_limit_info: 'Brevo: 300/day, Resend: 100/day = 400 total',
    });
  } catch (error) {
    console.error('Turbo email error:', error);
    res.status(500).json({ error: 'Failed to run turbo email' });
  }
});

// GET /api/cron/yelp-harvest - Harvest leads from Yelp Fusion API (FREE 5000 calls/day trial)
// Added 14.01.2026: Part of Night Turbo Automation System
// Requires: YELP_API_KEY environment variable
app.get('/api/cron/yelp-harvest', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!process.env.YELP_API_KEY) {
    return res.status(500).json({
      error: 'Yelp API not configured',
      setup: 'Get free API key at https://www.yelp.com/developers/v3/manage_app',
      env_var: 'YELP_API_KEY',
    });
  }

  console.log('ðŸ½ï¸ Starting Yelp Harvest...');

  // Cities to harvest - focus on US where Yelp is strongest
  const cities = [
    'New York, NY',
    'Los Angeles, CA',
    'Chicago, IL',
    'Houston, TX',
    'Miami, FL',
    'San Francisco, CA',
    'Seattle, WA',
    'Boston, MA',
    'Denver, CO',
    'Austin, TX',
  ];

  // Categories that need review responses
  const categories = ['restaurants', 'hotels', 'dentists', 'beautysvc', 'autorepair'];

  // Pick city and category based on day rotation
  const dayOfYear = Math.floor(
    (new Date() - new Date(new Date().getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)
  );
  const todayCity = req.query.city || cities[dayOfYear % cities.length];
  const todayCategory =
    req.query.category || categories[Math.floor(dayOfYear / cities.length) % categories.length];

  let totalHarvested = 0;
  let totalSkipped = 0;
  const results = [];

  try {
    // Yelp Fusion API Business Search
    const yelpUrl = `https://api.yelp.com/v3/businesses/search?location=${encodeURIComponent(todayCity)}&categories=${todayCategory}&limit=50&sort_by=review_count`;

    const response = await fetch(yelpUrl, {
      headers: {
        Authorization: `Bearer ${process.env.YELP_API_KEY}`,
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      return res.status(response.status).json({
        error: 'Yelp API error',
        status: response.status,
        details: errorText,
      });
    }

    const data = await response.json();

    if (data.businesses) {
      for (const biz of data.businesses) {
        try {
          // Skip if already exists
          const existing = await dbGet(
            'SELECT id FROM outreach_leads WHERE LOWER(business_name) = LOWER($1) AND LOWER(city) = LOWER($2)',
            [biz.name, todayCity.split(',')[0].trim()]
          );

          if (existing) {
            totalSkipped++;
            continue;
          }

          // Extract website domain from Yelp URL if no direct website
          const website = biz.url ? biz.url : null;

          await dbQuery(
            `INSERT INTO outreach_leads (business_name, business_type, city, address, phone, website, google_rating, google_reviews_count, source)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'yelp_harvest')
             ON CONFLICT (business_name, city) DO NOTHING`,
            [
              biz.name,
              todayCategory,
              todayCity.split(',')[0].trim(),
              biz.location?.display_address?.join(', ') || null,
              biz.phone || null,
              website,
              biz.rating || null,
              biz.review_count || null,
            ]
          );

          totalHarvested++;
          results.push({
            name: biz.name,
            rating: biz.rating,
            reviews: biz.review_count,
            phone: biz.phone ? 'Yes' : 'No',
          });
        } catch (err) {
          console.error(`Failed to save Yelp business ${biz.name}:`, err.message);
        }
      }
    }

    res.json({
      success: true,
      city: todayCity,
      category: todayCategory,
      harvested: totalHarvested,
      skipped: totalSkipped,
      businesses: results.slice(0, 10), // Show first 10
      total_found: data.businesses?.length || 0,
      message: `ðŸ½ï¸ Harvested ${totalHarvested} new leads from Yelp (${todayCity}, ${todayCategory})`,
      api_info: 'Yelp Fusion: 5000 calls/day on free trial',
    });
  } catch (error) {
    console.error('Yelp harvest error:', error);
    res.status(500).json({ error: 'Failed to harvest from Yelp' });
  }
});

// GET /api/cron/demo-followup - Send follow-up to people who viewed demo but didn't convert
app.get('/api/cron/demo-followup', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Ensure followup_sent_at column exists
    try {
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS followup_sent_at TIMESTAMP`
      );
    } catch (e) {
      /* Column might already exist */
    }

    // Find demos viewed >24h ago that haven't converted and no followup sent
    const demoViewers = await dbAll(`
      SELECT
        d.id, d.demo_token, d.business_name, d.demo_page_viewed_at,
        d.generated_responses, d.scraped_reviews,
        l.email, l.contact_name
      FROM demo_generations d
      JOIN outreach_leads l ON d.lead_id = l.id
      WHERE d.demo_page_viewed_at IS NOT NULL
        AND d.converted_at IS NULL
        AND d.followup_sent_at IS NULL
        AND d.demo_page_viewed_at < NOW() - INTERVAL '24 hours'
        AND l.email IS NOT NULL
        ${getTestEmailExcludeClause('l.email')}
      ORDER BY d.demo_page_viewed_at DESC
      LIMIT 10
    `);

    let sent = 0;
    const results = [];

    for (const viewer of demoViewers) {
      try {
        const businessName = viewer.business_name || 'your business';
        const greeting = viewer.contact_name ? `Hi ${viewer.contact_name.split(' ')[0]},` : 'Hi,';
        const demoUrl = `https://tryreviewresponder.com/demo/${viewer.demo_token}`;

        // Get one of the AI responses to showcase
        let responsePreview = '';
        if (viewer.generated_responses) {
          const responses =
            typeof viewer.generated_responses === 'string'
              ? JSON.parse(viewer.generated_responses)
              : viewer.generated_responses;
          if (responses.length > 0) {
            responsePreview = `\n\nHere's one we generated for you:\n"${responses[0].response?.substring(0, 150)}..."\n`;
          }
        }

        const subject = `Did the AI responses work for ${businessName}?`;
        const body = `${greeting}

I noticed you checked out the personalized demo we created for ${businessName} yesterday.

What did you think of the AI-generated review responses?${responsePreview}
If you'd like to see more, just sign up free - you'll get 20 responses/month at no cost:
${demoUrl}

Or if you have questions, just reply to this email!

Best,
Berend

P.S. Use code DEMOFOLLOWUP for 30% off if you upgrade within 48h.`;

        await resend.emails.send({
          from: OUTREACH_FROM_EMAIL,
          to: viewer.email,
          subject: subject,
          text: body,
          tags: [{ name: 'campaign', value: 'demo_followup' }],
        });

        // Mark as followed up
        await dbQuery(`UPDATE demo_generations SET followup_sent_at = NOW() WHERE id = $1`, [
          viewer.id,
        ]);

        sent++;
        results.push({
          email: viewer.email,
          business: businessName,
          demo_token: viewer.demo_token,
        });

        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send demo followup to ${viewer.email}:`, err.message);
      }
    }

    res.json({
      ok: true,
      sent,
      followups: results,
      message:
        sent > 0 ? `Sent ${sent} follow-ups to demo viewers` : 'No demo viewers to follow up',
    });
  } catch (error) {
    console.error('Demo followup error:', error);
    res.status(500).json({ error: 'Failed to send demo followups' });
  }
});

// GET /api/cron/hot-demo-visitors - Email people who viewed demo 3+ times (Phase 3a)
// SAFEGUARDS: Max 1 email per demo ever, only for unconverted demos
app.get('/api/cron/hot-demo-visitors', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Ensure columns exist
    try {
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS demo_view_count INTEGER DEFAULT 0`
      );
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS hot_demo_followup_sent_at TIMESTAMP`
      );
    } catch (e) {
      /* Columns might already exist */
    }

    // Find hot demos: viewed 3+ times, not converted, no hot followup sent yet
    const hotDemos = await dbAll(`
      SELECT
        d.id, d.demo_token, d.business_name, d.demo_view_count,
        d.demo_page_viewed_at, d.generated_responses,
        l.email, l.contact_name
      FROM demo_generations d
      JOIN outreach_leads l ON d.lead_id = l.id
      WHERE d.demo_view_count >= 3
        AND d.converted_at IS NULL
        AND d.hot_demo_followup_sent_at IS NULL
        AND l.email IS NOT NULL
        ${getTestEmailExcludeClause('l.email')}
      ORDER BY d.demo_view_count DESC, d.demo_page_viewed_at DESC
      LIMIT 10
    `);

    let sent = 0;
    const results = [];

    for (const demo of hotDemos) {
      try {
        const businessName = demo.business_name || 'your business';
        const firstName = demo.contact_name ? demo.contact_name.split(' ')[0] : '';
        const greeting = firstName ? `Hey ${firstName},` : 'Hey,';
        const viewCount = demo.demo_view_count;
        const demoUrl = `https://tryreviewresponder.com/demo/${demo.demo_token}?discount=HOTLEAD40`;

        const subject = `Still thinking about ${businessName}?`;
        const body = `${greeting}

I noticed you've been back to check out the AI responses we created for ${businessName} a few times now (${viewCount} visits).

That tells me you're seriously considering this. So let me make it easy:

Use code HOTLEAD40 for 40% off any plan. That's our best discount, only for people who are really interested.

Your personalized demo is here:
${demoUrl}

Questions? Just hit reply.

Berend

P.S. This code expires in 48 hours.`;

        await resend.emails.send({
          from: OUTREACH_FROM_EMAIL,
          to: demo.email,
          subject: subject,
          text: body,
          tags: [{ name: 'campaign', value: 'hot_demo_visitor' }],
        });

        // Mark as sent
        await dbQuery(`UPDATE demo_generations SET hot_demo_followup_sent_at = NOW() WHERE id = $1`, [
          demo.id,
        ]);

        sent++;
        results.push({
          email: demo.email,
          business: businessName,
          view_count: viewCount,
        });

        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send hot demo email to ${demo.email}:`, err.message);
      }
    }

    res.json({
      ok: true,
      sent,
      hot_visitors: results,
      message: sent > 0 ? `Sent ${sent} hot visitor emails` : 'No hot demo visitors found',
    });
  } catch (error) {
    console.error('Hot demo visitors error:', error);
    res.status(500).json({ error: 'Failed to send hot demo emails' });
  }
});

// GET /api/cron/exit-survey-followup - Send reason-based follow-ups (Phase 3b)
// SAFEGUARDS: Max 1 response per survey ever
app.get('/api/cron/exit-survey-followup', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Ensure response_sent_at column exists
    try {
      await dbQuery(
        `ALTER TABLE exit_surveys ADD COLUMN IF NOT EXISTS response_sent_at TIMESTAMP`
      );
    } catch (e) {
      /* Column might already exist */
    }

    // Find surveys without response, join with user email
    const pendingSurveys = await dbAll(`
      SELECT
        es.id, es.user_id, es.reason, es.context, es.created_at,
        u.email, u.business_name
      FROM exit_surveys es
      JOIN users u ON es.user_id = u.id
      WHERE es.response_sent_at IS NULL
        AND u.email IS NOT NULL
        AND es.created_at > NOW() - INTERVAL '7 days'
        ${getTestEmailExcludeClause('u.email')}
      ORDER BY es.created_at DESC
      LIMIT 10
    `);

    let sent = 0;
    const results = [];

    // Email templates based on reason
    const templates = {
      too_expensive: {
        subject: 'What if it was just $5?',
        body: (name) => `${name ? `Hey ${name.split(' ')[0]},` : 'Hey,'}

You mentioned price was the blocker. Totally get it.

What if you could get 10 AI responses for just $5? No subscription, no commitment. Just pay once, use whenever.

Would that work better for you?

If yes, just reply "yes" and I'll set it up for you personally.

Berend`,
      },
      not_right_time: {
        subject: 'Quick question',
        body: (name) => `${name ? `Hey ${name.split(' ')[0]},` : 'Hey,'}

You mentioned timing wasn't right. No worries.

When would be a better time to look at this? I can send you a reminder in:
- 2 weeks
- 1 month
- 3 months

Just reply with whichever works and I'll ping you then.

Berend`,
      },
      missing_feature: {
        subject: "What's missing?",
        body: (name, context) => `${name ? `Hey ${name.split(' ')[0]},` : 'Hey,'}

You mentioned we're missing something you need.${context ? ` You said: "${context}"` : ''}

I'd love to know more. What feature would make this a no-brainer for you?

We're actively building based on user feedback, so your input actually matters.

Just reply with what you'd need.

Berend`,
      },
      just_testing: {
        subject: 'Did the AI responses look good?',
        body: (name) => `${name ? `Hey ${name.split(' ')[0]},` : 'Hey,'}

You were just testing things out. Fair enough.

But I'm curious, what did you think of the AI-generated responses? Did they look like something you'd actually send?

We've spent a lot of time making them sound human and not "AI-ish". Here's what actual users are saying:
https://tryreviewresponder.com/testimonials

If you ever want to try it for real, the free plan gives you 20 responses/month.

Berend`,
      },
      other: {
        subject: 'Quick question',
        body: (name, context) => `${name ? `Hey ${name.split(' ')[0]},` : 'Hey,'}

I saw you checked out ReviewResponder but decided not to upgrade.${context ? ` You mentioned: "${context}"` : ''}

Would love to know what held you back. Understanding real feedback helps us build something people actually want.

No sales pitch, just curious.

Berend`,
      },
    };

    for (const survey of pendingSurveys) {
      try {
        const reason = survey.reason || 'other';
        const template = templates[reason] || templates.other;
        const subject = template.subject;
        // Use business_name but it's usually not a person's name, so templates use generic greeting
        const body = template.body(null, survey.context);

        await resend.emails.send({
          from: OUTREACH_FROM_EMAIL,
          to: survey.email,
          subject: subject,
          text: body,
          tags: [{ name: 'campaign', value: 'exit_survey_followup' }, { name: 'reason', value: reason }],
        });

        // Mark as sent
        await dbQuery(`UPDATE exit_surveys SET response_sent_at = NOW() WHERE id = $1`, [
          survey.id,
        ]);

        sent++;
        results.push({
          email: survey.email,
          reason: reason,
        });

        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send exit survey response to ${survey.email}:`, err.message);
      }
    }

    res.json({
      ok: true,
      sent,
      responses: results,
      message: sent > 0 ? `Sent ${sent} exit survey responses` : 'No pending exit surveys',
    });
  } catch (error) {
    console.error('Exit survey followup error:', error);
    res.status(500).json({ error: 'Failed to send exit survey followups', details: error.message });
  }
});

// ============================================================================
// MAGIC LINK AUTHENTICATION SYSTEM
// Auto-creates accounts and logs in users without password
// Added 14.01.2026: Part of Re-Engagement for hot leads
// ============================================================================

// GET /api/auth/magic-login/:token - Verify magic link and login user
app.get('/api/auth/magic-login/:token', async (req, res) => {
  try {
    const { token } = req.params;

    // Create magic_links table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS magic_links (
        id SERIAL PRIMARY KEY,
        token TEXT UNIQUE NOT NULL,
        email TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        used_at TIMESTAMP,
        expires_at TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '7 days')
      )
    `);

    // Find and validate magic link
    const magicLink = await dbGet(
      `SELECT * FROM magic_links
       WHERE token = $1
       AND used_at IS NULL
       AND expires_at > NOW()`,
      [token]
    );

    if (!magicLink) {
      // Redirect to login with error
      return res.redirect('https://tryreviewresponder.com/login?error=invalid_magic_link');
    }

    // Track magic link click in reengagement_emails
    try {
      await dbQuery(
        `UPDATE reengagement_emails SET clicked_at = NOW() WHERE magic_link_token = $1 AND clicked_at IS NULL`,
        [token]
      );
    } catch (e) {
      // Table might not exist yet
    }

    // Check if user exists
    let user = await dbGet('SELECT * FROM users WHERE LOWER(email) = LOWER($1)', [magicLink.email]);

    if (!user) {
      // Auto-create user account
      const randomPassword = crypto.randomBytes(32).toString('hex');
      const hashedPassword = await bcrypt.hash(randomPassword, 10);

      // Get business info from outreach leads if available
      const leadInfo = await dbGet(
        'SELECT business_name, city FROM outreach_leads WHERE LOWER(email) = LOWER($1)',
        [magicLink.email]
      );

      const result = await dbQuery(
        `INSERT INTO users (email, password, business_name, subscription_plan, responses_limit, email_verified, created_via_magic_link)
         VALUES ($1, $2, $3, 'free', 20, true, true)
         RETURNING *`,
        [magicLink.email, hashedPassword, leadInfo?.business_name || null]
      );
      user = result.rows ? result.rows[0] : result;

      console.log(`ðŸ”® Magic link auto-created user: ${magicLink.email}`);
    }

    // Mark magic link as used
    await dbQuery('UPDATE magic_links SET used_at = NOW() WHERE id = $1', [magicLink.id]);

    // Generate JWT token
    const jwtToken = jwt.sign({ id: user.id, email: user.email }, process.env.JWT_SECRET, {
      expiresIn: '7d',
    });

    // Redirect to dashboard with token
    res.redirect(`https://tryreviewresponder.com/magic-login?token=${jwtToken}`);
  } catch (error) {
    console.error('Magic login error:', error);
    res.redirect('https://tryreviewresponder.com/login?error=magic_login_failed');
  }
});

// Helper function to generate magic link token
function generateMagicLinkToken() {
  return crypto.randomBytes(32).toString('hex');
}

// Helper function to create magic link for email
async function createMagicLink(email) {
  // Create table if not exists
  await dbQuery(`
    CREATE TABLE IF NOT EXISTS magic_links (
      id SERIAL PRIMARY KEY,
      token TEXT UNIQUE NOT NULL,
      email TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      used_at TIMESTAMP,
      expires_at TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '7 days')
    )
  `);

  const token = generateMagicLinkToken();
  await dbQuery(`INSERT INTO magic_links (token, email) VALUES ($1, $2)`, [token, email]);

  return `https://review-responder.onrender.com/api/auth/magic-login/${token}`;
}

// ============================================================================
// RE-ENGAGEMENT CRON - Magic links for clickers who haven't registered
// ============================================================================

// GET /api/cron/reengage-clickers - Send magic login links to hot leads
app.all('/api/cron/reengage-clickers', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!brevoApi && !resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Create reengagement tracking table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS reengagement_emails (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        magic_link_token TEXT,
        clicked_at TIMESTAMP,
        registered_at TIMESTAMP
      )
    `);

    // Find clickers who:
    // 1. Clicked in last 14 days
    // 2. NOT registered as users
    // 3. Have received followup (clicker_followups exists)
    // 4. Have NOT received reengagement email yet
    const hotLeads = await dbAll(`
      SELECT DISTINCT
        c.email,
        c.clicked_at,
        l.business_name,
        l.contact_name,
        l.city,
        f.demo_token
      FROM outreach_clicks c
      LEFT JOIN users u ON LOWER(u.email) = LOWER(c.email)
      LEFT JOIN outreach_leads l ON LOWER(l.email) = LOWER(c.email)
      LEFT JOIN clicker_followups f ON LOWER(f.email) = LOWER(c.email)
      LEFT JOIN reengagement_emails r ON LOWER(r.email) = LOWER(c.email)
      WHERE u.id IS NULL
        AND c.clicked_at > NOW() - INTERVAL '14 days'
        AND f.id IS NOT NULL
        AND r.id IS NULL
        ${getTestEmailExcludeClause('c.email')}
      ORDER BY c.clicked_at DESC
      LIMIT 10
    `);

    if (hotLeads.length === 0) {
      return res.json({
        success: true,
        sent: 0,
        message: 'No hot leads ready for re-engagement',
      });
    }

    let sent = 0;
    const results = [];

    for (const lead of hotLeads) {
      try {
        // Generate magic link
        const magicLinkUrl = await createMagicLink(lead.email);
        const magicToken = magicLinkUrl.split('/').pop();

        const businessName = lead.business_name || 'your business';
        const city = lead.city || '';
        const demoUrl = lead.demo_token
          ? `https://tryreviewresponder.com/demo/${lead.demo_token}`
          : null;

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'BrÃ¼ssel',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(gc => city.toLowerCase().includes(gc.toLowerCase()));

        let subject, body;

        if (isGerman) {
          subject = `Dein Account ist bereit â€“ kein Passwort nÃ¶tig`;
          body = `Hey,

ich hab gesehen, dass du ReviewResponder angeschaut hast.

Ich hab dir einen Account angelegt â€“ kein Passwort nÃ¶tig, einfach klicken:

${magicLinkUrl}

${demoUrl ? `Deine personalisierte Demo ist immer noch hier: ${demoUrl}` : ''}

20 Antworten/Monat sind kostenlos. Einfach loslegen.

GrÃ¼ÃŸe,
Berend

P.S. Der Link funktioniert 7 Tage.`;
        } else {
          subject = `Your account is ready â€“ no password needed`;
          body = `Hey,

I noticed you checked out ReviewResponder.

I set up an account for you â€“ no password needed, just click:

${magicLinkUrl}

${demoUrl ? `Your personalized demo is still here: ${demoUrl}` : ''}

20 responses/month are free. Just start using it.

Best,
Berend

P.S. This link works for 7 days.`;
        }

        // Send via Brevo (higher deliverability for outreach)
        if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: {
              name: 'Berend from ReviewResponder',
              email: 'outreach@tryreviewresponder.com',
            },
            to: [{ email: lead.email }],
            subject: subject,
            textContent: body,
            tags: ['reengagement', 'magic_link'],
          });
        } else {
          await resend.emails.send({
            from: OUTREACH_FROM_EMAIL,
            to: lead.email,
            subject: subject,
            text: body,
            tags: [{ name: 'campaign', value: 'reengagement' }],
          });
        }

        // Track reengagement email
        await dbQuery(`INSERT INTO reengagement_emails (email, magic_link_token) VALUES ($1, $2)`, [
          lead.email,
          magicToken,
        ]);

        sent++;
        results.push({
          email: lead.email,
          business: businessName,
          magic_link: magicLinkUrl,
        });

        // Rate limit
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send reengagement to ${lead.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      sent: sent,
      reengagements_sent: results,
      message: sent > 0 ? `Sent ${sent} magic link re-engagement emails!` : 'No emails sent',
    });
  } catch (error) {
    console.error('Reengagement cron error:', error);
    res.status(500).json({ error: 'Failed to send reengagement emails' });
  }
});

// ============================================================================
// DEMO EXPIRATION CRON - Create urgency with expiring demos
// ============================================================================

// GET /api/cron/demo-expiration-emails - Send urgency emails for expiring demos
app.all('/api/cron/demo-expiration-emails', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!brevoApi && !resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Add expiration tracking columns if not exist
    try {
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS expiration_email_day3 BOOLEAN DEFAULT false`
      );
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS expiration_email_day5 BOOLEAN DEFAULT false`
      );
      await dbQuery(
        `ALTER TABLE demo_generations ADD COLUMN IF NOT EXISTS expired BOOLEAN DEFAULT false`
      );
    } catch (e) {
      /* Columns might already exist */
    }

    const results = {
      day3: [],
      day5: [],
      expired: [],
    };

    // Day 3 emails - "Your demo expires in 4 days"
    const day3Demos = await dbAll(`
      SELECT d.*, l.email, l.contact_name, l.city
      FROM demo_generations d
      LEFT JOIN outreach_leads l ON d.lead_id = l.id
      WHERE d.created_at BETWEEN NOW() - INTERVAL '4 days' AND NOW() - INTERVAL '3 days'
        AND d.converted_at IS NULL
        AND d.expiration_email_day3 = false
        AND l.email IS NOT NULL
        ${getTestEmailExcludeClause('l.email')}
      LIMIT 20
    `);

    for (const demo of day3Demos) {
      try {
        const demoUrl = `https://tryreviewresponder.com/demo/${demo.demo_token}`;
        const businessName = demo.business_name || 'your business';
        const city = demo.city || '';

        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
        ];
        const isGerman = germanCities.some(gc => city.toLowerCase().includes(gc.toLowerCase()));

        let subject, body;
        if (isGerman) {
          subject = `Deine ${businessName} Demo lÃ¤uft in 4 Tagen ab`;
          body = `Hey,

deine personalisierte Demo fÃ¼r ${businessName} lÃ¤uft in 4 Tagen ab.

Schau sie dir nochmal an bevor sie weg ist:
${demoUrl}

Falls sie dir gefÃ¤llt: 20 Antworten/Monat kostenlos.

GrÃ¼ÃŸe,
Berend`;
        } else {
          subject = `Your ${businessName} demo expires in 4 days`;
          body = `Hey,

Your personalized demo for ${businessName} expires in 4 days.

Check it out before it's gone:
${demoUrl}

If you like it: 20 responses/month are free.

Best,
Berend`;
        }

        if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: {
              name: 'Berend from ReviewResponder',
              email: 'outreach@tryreviewresponder.com',
            },
            to: [{ email: demo.email }],
            subject: subject,
            textContent: body,
            tags: ['demo_expiration', 'day3'],
          });
        }

        await dbQuery('UPDATE demo_generations SET expiration_email_day3 = true WHERE id = $1', [
          demo.id,
        ]);
        results.day3.push({ email: demo.email, business: businessName });
        await new Promise(r => setTimeout(r, 300));
      } catch (e) {
        console.error(`Day 3 email failed for ${demo.email}:`, e.message);
      }
    }

    // Day 5 emails - "Last chance - demo expires tomorrow"
    const day5Demos = await dbAll(`
      SELECT d.*, l.email, l.contact_name, l.city
      FROM demo_generations d
      LEFT JOIN outreach_leads l ON d.lead_id = l.id
      WHERE d.created_at BETWEEN NOW() - INTERVAL '6 days' AND NOW() - INTERVAL '5 days'
        AND d.converted_at IS NULL
        AND d.expiration_email_day5 = false
        AND l.email IS NOT NULL
        ${getTestEmailExcludeClause('l.email')}
      LIMIT 20
    `);

    for (const demo of day5Demos) {
      try {
        const demoUrl = `https://tryreviewresponder.com/demo/${demo.demo_token}`;
        const businessName = demo.business_name || 'your business';
        const city = demo.city || '';

        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
        ];
        const isGerman = germanCities.some(gc => city.toLowerCase().includes(gc.toLowerCase()));

        let subject, body;
        if (isGerman) {
          subject = `Letzte Chance: ${businessName} Demo lÃ¤uft MORGEN ab`;
          body = `Hey,

das ist die letzte Erinnerung.

Deine personalisierte Demo fÃ¼r ${businessName} lÃ¤uft MORGEN ab:
${demoUrl}

Danach sind die AI-generierten Antworten fÃ¼r deine echten Bewertungen weg.

Falls du sie behalten willst: Einfach kostenlos registrieren.

GrÃ¼ÃŸe,
Berend`;
        } else {
          subject = `Last chance: ${businessName} demo expires TOMORROW`;
          body = `Hey,

This is the final reminder.

Your personalized demo for ${businessName} expires TOMORROW:
${demoUrl}

After that, the AI-generated responses for your real reviews will be gone.

If you want to keep them: Just sign up for free.

Best,
Berend`;
        }

        if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: {
              name: 'Berend from ReviewResponder',
              email: 'outreach@tryreviewresponder.com',
            },
            to: [{ email: demo.email }],
            subject: subject,
            textContent: body,
            tags: ['demo_expiration', 'day5'],
          });
        }

        await dbQuery('UPDATE demo_generations SET expiration_email_day5 = true WHERE id = $1', [
          demo.id,
        ]);
        results.day5.push({ email: demo.email, business: businessName });
        await new Promise(r => setTimeout(r, 300));
      } catch (e) {
        console.error(`Day 5 email failed for ${demo.email}:`, e.message);
      }
    }

    // Mark demos as expired after 7 days
    const expiredResult = await dbQuery(`
      UPDATE demo_generations
      SET expired = true
      WHERE created_at < NOW() - INTERVAL '7 days'
        AND expired = false
        AND converted_at IS NULL
      RETURNING id, business_name
    `);

    if (expiredResult.rows) {
      results.expired = expiredResult.rows.map(r => r.business_name);
    }

    res.json({
      success: true,
      day3_sent: results.day3.length,
      day5_sent: results.day5.length,
      demos_expired: results.expired.length,
      details: results,
      message: `Sent ${results.day3.length} day-3 emails, ${results.day5.length} day-5 emails, expired ${results.expired.length} demos`,
    });
  } catch (error) {
    console.error('Demo expiration cron error:', error);
    res.status(500).json({ error: 'Failed to process demo expirations' });
  }
});

// ====================================================================================
// NIGHT AUTOMATION SYSTEM - Runs autonomously 22:00-06:00 UTC
// Added 14.01.2026: Full autonomous night loop for sales conversion optimization
// ====================================================================================

// GET /api/cron/night-loop - Master endpoint for all nightly automation
// Schedule at cron-job.org: 0 22-6 * * * (hourly from 22:00-06:00 UTC)
app.all('/api/cron/night-loop', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const dryRun = req.query.dry_run === 'true';
  const forceHour = req.query.hour ? parseInt(req.query.hour) : null;
  const hour = forceHour !== null ? forceHour : new Date().getUTCHours();
  const actions = [];
  const results = {};

  console.log(`ðŸŒ™ Night Loop starting - Hour: ${hour} UTC, Dry Run: ${dryRun}`);

  try {
    // Hour 22: Hot Lead Follow-Ups (people who clicked but didn't convert)
    if (hour === 22) {
      console.log('ðŸ”¥ 22:00 - Running Hot Lead Follow-Ups (followup-clickers)');
      actions.push({
        hour: 22,
        action: 'followup-clickers',
        description: 'Send personalized demos to email clickers',
      });

      if (!dryRun) {
        // Find clickers who haven't received follow-up yet
        const clickers = await dbAll(`
          SELECT DISTINCT c.email, c.clicked_at,
            l.id as lead_id, l.business_name, l.contact_name, l.city
          FROM outreach_clicks c
          LEFT JOIN outreach_leads l ON LOWER(c.email) = LOWER(l.email)
          LEFT JOIN clicker_followups f ON LOWER(c.email) = LOWER(f.email)
          WHERE f.id IS NULL
            ${getTestEmailExcludeClause('c.email')}
          ORDER BY c.clicked_at DESC
          LIMIT 5
        `);
        results.hot_leads_found = clickers.length;
        results.hot_leads_message =
          clickers.length > 0
            ? `Found ${clickers.length} hot leads to follow up`
            : 'All hot leads already followed up';
      }
    }

    // Hour 23: Second Follow-Up (better offer to non-converters)
    if (hour === 23) {
      console.log('ðŸ“§ 23:00 - Running Second Follow-Up (1 month free offer)');
      actions.push({
        hour: 23,
        action: 'second-followup',
        description: 'Send "1 month free" to non-converters',
      });

      if (!dryRun) {
        const pending = await dbGet(`
          SELECT COUNT(*) as count FROM clicker_followups
          WHERE converted = FALSE
            AND second_followup_sent IS NULL
            AND sent_at < NOW() - INTERVAL '2 days'
            ${getTestEmailExcludeClause('email')}
        `);
        results.second_followup_pending = parseInt(pending?.count || 0);
      }
    }

    // Hour 0: Stats Collection & Demo Expiration Emails
    if (hour === 0) {
      console.log('ðŸ“Š 00:00 - Collecting nightly stats + Demo Expiration Emails');
      actions.push({
        hour: 0,
        action: 'stats-collection',
        description: 'Collect metrics for daily report',
      });
      actions.push({
        hour: 0,
        action: 'demo-expiration',
        description: 'Send urgency emails for expiring demos',
      });

      if (!dryRun) {
        const totalLeads = await dbGet(`SELECT COUNT(*) as count FROM outreach_leads`);
        const totalEmails = await dbGet(`SELECT COUNT(*) as count FROM outreach_emails`);
        const totalClicks = await dbGet(
          `SELECT COUNT(DISTINCT email) as count FROM outreach_clicks`
        );
        const conversions = await dbGet(
          `SELECT COUNT(*) as count FROM clicker_followups WHERE converted = TRUE`
        );

        results.nightly_stats = {
          total_leads: parseInt(totalLeads?.count || 0),
          total_emails_sent: parseInt(totalEmails?.count || 0),
          unique_clickers: parseInt(totalClicks?.count || 0),
          conversions: parseInt(conversions?.count || 0),
        };

        // Call demo expiration endpoint internally
        try {
          const baseUrl = process.env.BACKEND_URL || 'https://review-responder.onrender.com';
          const expirationResponse = await fetch(
            `${baseUrl}/api/cron/demo-expiration-emails?secret=${process.env.CRON_SECRET}`
          );
          const expirationData = await expirationResponse.json();
          results.demo_expiration = expirationData;
          console.log(
            `ðŸ“† Demo expiration: ${expirationData.day3_sent || 0} day-3, ${expirationData.day5_sent || 0} day-5, ${expirationData.demos_expired || 0} expired`
          );
        } catch (e) {
          console.error('Demo expiration call failed:', e.message);
          results.demo_expiration = { error: e.message };
        }
      }
    }

    // Hour 1: Dead Lead Revival
    if (hour === 1) {
      console.log('ðŸ’€ 01:00 - Running Dead Lead Revival');
      actions.push({
        hour: 1,
        action: 'dead-lead-revival',
        description: 'Revive leads 7+ days without response',
      });

      if (!dryRun) {
        // Find leads that were emailed 7+ days ago, never clicked, never got revival email
        const deadLeads = await dbAll(`
          SELECT DISTINCT ON (e.email) e.email, e.sent_at, l.business_name, l.city
          FROM outreach_emails e
          LEFT JOIN outreach_leads l ON LOWER(e.email) = LOWER(l.email)
          LEFT JOIN outreach_clicks c ON LOWER(e.email) = LOWER(c.email)
          WHERE c.email IS NULL
            AND e.sent_at < NOW() - INTERVAL '7 days'
            AND e.revival_sent IS NULL
            ${getTestEmailExcludeClause('e.email')}
          ORDER BY e.email, e.sent_at DESC
          LIMIT 10
        `);
        results.dead_leads_found = deadLeads.length;
      }
    }

    // Hour 2: A/B Test Evaluation + Re-Engagement Magic Links
    if (hour === 2) {
      console.log('ðŸ”¬ 02:00 - Evaluating A/B Tests + Re-Engagement Magic Links');
      actions.push({
        hour: 2,
        action: 'ab-test-evaluate',
        description: 'Evaluate email subject/CTA tests',
      });
      actions.push({
        hour: 2,
        action: 'reengage-clickers',
        description: 'Send magic links to unregistered clickers',
      });

      if (!dryRun) {
        const activeTests = await dbAll(`
          SELECT * FROM email_ab_tests
          WHERE winner IS NULL AND ended_at IS NULL
        `);
        results.active_ab_tests = activeTests?.length || 0;

        // Call re-engagement endpoint internally
        try {
          const baseUrl = process.env.BACKEND_URL || 'https://review-responder.onrender.com';
          const reengageResponse = await fetch(
            `${baseUrl}/api/cron/reengage-clickers?secret=${process.env.CRON_SECRET}`
          );
          const reengageData = await reengageResponse.json();
          results.reengagement = reengageData;
          console.log(`ðŸ”® Re-engagement: ${reengageData.sent || 0} magic link emails sent`);
        } catch (e) {
          console.error('Re-engagement call failed:', e.message);
          results.reengagement = { error: e.message };
        }
      }
    }

    // Hour 3: Magic User Nudge - Activate users who clicked magic links but haven't used product
    if (hour === 3) {
      console.log('ðŸ”® 03:00 - Running Magic User Activation Nudge');
      actions.push({
        hour: 3,
        action: 'nudge-magic-users',
        description: 'Nudge magic link users who haven\'t used the product',
      });

      if (!dryRun) {
        // Call magic nudge endpoint internally
        try {
          const baseUrl = process.env.BACKEND_URL || 'https://review-responder.onrender.com';
          const nudgeResponse = await fetch(
            `${baseUrl}/api/cron/nudge-magic-users?secret=${process.env.CRON_SECRET}`
          );
          const nudgeData = await nudgeResponse.json();
          results.magic_nudge = nudgeData;
          console.log(`ðŸ”®ðŸ“§ Magic nudge: ${nudgeData.sent || 0} activation emails sent`);
        } catch (e) {
          console.error('Magic nudge call failed:', e.message);
          results.magic_nudge = { error: e.message };
        }

        // Also run broader dormant user activation
        try {
          const activateResponse = await fetch(
            `${baseUrl}/api/cron/activate-dormant-users?secret=${process.env.CRON_SECRET}&limit=10`
          );
          const activateData = await activateResponse.json();
          results.dormant_activation = activateData;
          console.log(`ðŸš€ðŸ“§ Dormant activation: ${activateData.sent || 0} emails sent`);
        } catch (e) {
          console.error('Dormant activation call failed:', e.message);
          results.dormant_activation = { error: e.message };
        }
      }
    }

    // Hour 4-5: Preparation & Idle
    if (hour >= 4 && hour <= 5) {
      console.log(`ðŸ˜´ ${hour}:00 - Night cycle winding down`);
      actions.push({ hour, action: 'idle', description: 'Preparing for morning outreach' });
    }

    // Log night loop completion
    console.log(`ðŸŒ™ Night Loop completed - ${actions.length} actions scheduled`);

    res.json({
      success: true,
      hour,
      dry_run: dryRun,
      actions,
      results,
      next_action: hour < 6 ? `Hour ${hour + 1}` : 'Night loop complete',
      message: dryRun ? 'Dry run - no actions taken' : `Night loop executed for hour ${hour}`,
    });
  } catch (error) {
    console.error('Night loop error:', error);
    res.status(500).json({ error: 'Night loop failed', message: error.message });
  }
});

// GET /api/cron/revive-dead-leads - Send revival emails to leads 7+ days without response
// Added 14.01.2026: Part of night automation system
app.all('/api/cron/revive-dead-leads', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!brevoApi && !resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const dryRun = req.query.dry_run === 'true';

  try {
    // Ensure revival_sent column exists
    try {
      await dbQuery(`ALTER TABLE outreach_emails ADD COLUMN IF NOT EXISTS revival_sent TIMESTAMP`);
    } catch (e) {
      /* Column might already exist */
    }

    // Find leads: emailed 7+ days ago, no clicks, no revival sent
    const deadLeads = await dbAll(`
      SELECT DISTINCT ON (e.email)
        e.id as email_id, e.email, e.sent_at,
        l.business_name, l.city, l.contact_name,
        l.google_reviews_count
      FROM outreach_emails e
      LEFT JOIN outreach_leads l ON LOWER(e.email) = LOWER(l.email)
      LEFT JOIN outreach_clicks c ON LOWER(e.email) = LOWER(c.email)
      WHERE c.email IS NULL
        AND e.sent_at < NOW() - INTERVAL '7 days'
        AND e.revival_sent IS NULL
        ${getTestEmailExcludeClause('e.email')}
        AND e.email NOT LIKE '%vimeo%'
      ORDER BY e.email, e.sent_at DESC
      LIMIT 10
    `);

    if (deadLeads.length === 0) {
      return res.json({
        success: true,
        sent: 0,
        message: 'No dead leads to revive (all leads either clicked or already got revival email)',
      });
    }

    if (dryRun) {
      return res.json({
        success: true,
        dry_run: true,
        leads_found: deadLeads.length,
        leads: deadLeads.map(l => ({ email: l.email, business: l.business_name, city: l.city })),
        message: `Would revive ${deadLeads.length} dead leads`,
      });
    }

    let sent = 0;
    let skippedParallelSafe = 0;
    const results = [];

    for (const lead of deadLeads) {
      try {
        // PARALLEL-SAFE: Check if revival email was recently sent
        const recentlySent = await wasEmailRecentlySent(lead.email, 'revival', 60);
        if (recentlySent) {
          console.log(`â­ï¸ Skipping ${lead.email} - revival recently sent`);
          skippedParallelSafe++;
          continue;
        }

        const businessName = lead.business_name || 'your restaurant';
        const city = lead.city || '';

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen',
          'Berlin',
          'Hamburg',
          'Frankfurt',
          'KÃ¶ln',
          'Stuttgart',
          'DÃ¼sseldorf',
          'Wien',
          'ZÃ¼rich',
          'Genf',
          'Munich',
          'Cologne',
          'Vienna',
          'Zurich',
          'Geneva',
        ];
        const isGerman = germanCities.some(c => city.toLowerCase().includes(c.toLowerCase()));

        let subject, body;

        if (isGerman) {
          subject = `Problem gelÃ¶st?`;
          body = `Hey,

ich hatte dir letzte Woche geschrieben wegen ${businessName}.

Falls ihr immer noch keine Zeit habt, Reviews zu beantworten - kein Problem. Wollte nur nochmal nachhaken.

Falls doch: Antworte einfach auf diese Email und ich zeige dir wie wir das in 5 Minuten automatisieren kÃ¶nnen.

GrÃ¼ÃŸe,
Berend

P.S. Falls kein Interesse, einfach ignorieren - ich nerve nicht weiter.`;
        } else {
          subject = `Problem solved?`;
          body = `Hey,

I reached out last week about ${businessName}.

If you're still too busy to respond to reviews - no worries at all. Just wanted to follow up once.

If you'd like help: Just reply and I'll show you how to automate this in 5 minutes.

Best,
Berend

P.S. If not interested, just ignore this - I won't bug you again.`;
        }

        // Send via Brevo or Resend
        if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: {
              name: 'Berend @ ReviewResponder',
              email: OUTREACH_FROM_EMAIL.replace(/.*<|>.*/g, ''),
            },
            to: [{ email: lead.email }],
            subject: subject,
            textContent: body,
            tags: ['revival', 'night_automation'],
          });
        } else if (resend) {
          await resend.emails.send({
            from: OUTREACH_FROM_EMAIL,
            to: lead.email,
            subject: subject,
            text: body,
            tags: [{ name: 'campaign', value: 'revival' }],
          });
        }

        // Mark as revival sent
        await dbQuery(`UPDATE outreach_emails SET revival_sent = NOW() WHERE id = $1`, [
          lead.email_id,
        ]);

        // PARALLEL-SAFE: Record in history
        await recordEmailSend(lead.email, 'revival', 1, `revival:${lead.email}:${Date.now()}`);

        sent++;
        results.push({ email: lead.email, business: businessName });
        console.log(`ðŸ’€âž¡ï¸âœ‰ï¸ Revival sent to ${lead.email} (${businessName})`);

        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send revival to ${lead.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      sent,
      skipped_parallel_safe: skippedParallelSafe,
      leads_revived: results,
      message:
        sent > 0 ? `Revived ${sent} dead leads with "Problem solved?" email` : 'No emails sent',
    });
  } catch (error) {
    console.error('Dead lead revival error:', error);
    res.status(500).json({ error: 'Failed to revive dead leads' });
  }
});

// ============================================================================
// GET /api/cron/nudge-magic-users - Send activation emails to inactive magic link users
// Added 15.01.2026: Magic link users who clicked but never used the product
// ============================================================================
app.all('/api/cron/nudge-magic-users', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!brevoApi && !resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const dryRun = req.query.dry_run === 'true';

  try {
    // Ensure nudge tracking column exists on users table
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS magic_nudge_sent TIMESTAMP`);
    } catch (e) {
      /* Column might already exist */
    }

    // Find magic link users who:
    // 1. Were created via magic link (email in magic_links with used_at NOT NULL)
    // 2. Have not used the product (responses_used = 0)
    // 3. Created more than 24 hours ago
    // 4. Haven't been nudged yet
    const inactiveMagicUsers = await dbAll(`
      SELECT DISTINCT ON (u.email)
        u.id, u.email, u.business_name, u.created_at,
        ml.used_at as magic_link_used_at,
        l.city, l.contact_name
      FROM users u
      INNER JOIN magic_links ml ON LOWER(u.email) = LOWER(ml.email)
      LEFT JOIN outreach_leads l ON LOWER(u.email) = LOWER(l.email)
      WHERE ml.used_at IS NOT NULL
        AND u.responses_used = 0
        AND u.created_at < NOW() - INTERVAL '24 hours'
        AND u.magic_nudge_sent IS NULL
        ${getTestEmailExcludeClause('u.email')}
      ORDER BY u.email, u.created_at DESC
      LIMIT 20
    `);

    if (inactiveMagicUsers.length === 0) {
      return res.json({
        success: true,
        sent: 0,
        message: 'No inactive magic link users to nudge',
      });
    }

    if (dryRun) {
      return res.json({
        success: true,
        dry_run: true,
        users_found: inactiveMagicUsers.length,
        users: inactiveMagicUsers.map(u => ({
          email: u.email,
          business: u.business_name,
          created: u.created_at
        })),
        message: `Would nudge ${inactiveMagicUsers.length} inactive magic link users`,
      });
    }

    let sent = 0;
    const results = [];

    for (const user of inactiveMagicUsers) {
      try {
        // PARALLEL-SAFE: Check if nudge was recently sent
        const recentlySent = await wasEmailRecentlySent(user.email, 'magic_nudge', 60);
        if (recentlySent) {
          console.log(`â­ï¸ Skipping ${user.email} - magic nudge recently sent`);
          continue;
        }

        const businessName = user.business_name || user.contact_name || 'your business';
        const city = user.city || '';
        const firstName = user.contact_name?.split(' ')[0] || '';

        // Detect German-speaking cities
        const germanCities = [
          'MÃ¼nchen', 'Berlin', 'Hamburg', 'Frankfurt', 'KÃ¶ln', 'Stuttgart',
          'DÃ¼sseldorf', 'Wien', 'ZÃ¼rich', 'Genf', 'Munich', 'Cologne',
          'Vienna', 'Zurich', 'Geneva'
        ];
        const isGerman = germanCities.some(c => city.toLowerCase().includes(c.toLowerCase()));

        let subject, body;

        if (isGerman) {
          subject = firstName ? `${firstName}, dein Account ist bereit` : `Dein Account ist bereit`;
          body = `Hey${firstName ? ` ${firstName}` : ''},

du hast vorgestern auf unseren Demo-Link geklickt - cool!

Du hast jetzt ein kostenloses ReviewResponder Konto:
â†’ 20 KI-Antworten gratis
â†’ Funktioniert mit Google, Yelp, TripAdvisor, etc.
â†’ Keine Kreditkarte nÃ¶tig

Einfach einloggen und ausprobieren:
https://tryreviewresponder.com/login

Falls du Fragen hast, antworte einfach auf diese Email.

GrÃ¼ÃŸe,
Berend

P.S. Die meisten Restaurants sparen 2-3 Stunden pro Woche mit automatischen Review-Antworten.`;
        } else {
          subject = firstName ? `${firstName}, your account is ready` : `Your account is ready`;
          body = `Hey${firstName ? ` ${firstName}` : ''},

You clicked our demo link the other day - awesome!

You now have a free ReviewResponder account:
â†’ 20 AI responses free
â†’ Works with Google, Yelp, TripAdvisor, etc.
â†’ No credit card needed

Just log in and try it out:
https://tryreviewresponder.com/login

If you have any questions, just reply to this email.

Best,
Berend

P.S. Most restaurants save 2-3 hours per week with automated review responses.`;
        }

        // Send email
        const emailResult = await sendEmail({
          to: user.email,
          subject,
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; line-height: 1.6;">${body.replace(/\n/g, '<br>').replace(/(https:\/\/[^\s<]+)/g, '<a href="$1" style="color: #2563eb;">$1</a>')}</div>`,
          text: body,
          tags: ['magic_nudge', 'activation'],
        });

        if (!emailResult.success) {
          console.error(`Failed to send magic nudge to ${user.email}:`, emailResult.error);
          continue;
        }

        // Mark user as nudged
        await dbQuery('UPDATE users SET magic_nudge_sent = NOW() WHERE id = $1', [user.id]);

        // Record in email history for parallel-safety
        await recordEmailSend(user.email, 'magic_nudge', 1, `magic_nudge:${user.email}:${Date.now()}`);

        sent++;
        results.push({ email: user.email, business: businessName });
        console.log(`ðŸ”®ðŸ“§ Magic nudge sent to ${user.email} (${businessName})`);

        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send magic nudge to ${user.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      sent,
      users_nudged: results,
      message: sent > 0
        ? `Sent ${sent} activation nudges to inactive magic link users`
        : 'No nudges sent',
    });
  } catch (error) {
    console.error('Magic user nudge error:', error);
    res.status(500).json({ error: 'Failed to nudge magic users' });
  }
});

// ============================================================================
// GET /api/cron/activate-dormant-users - Send activation emails to ALL users with 0 responses
// Added 15.01.2026: Broader activation for all dormant users, not just magic link
// ============================================================================
app.all('/api/cron/activate-dormant-users', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!brevoApi && !resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  const dryRun = req.query.dry_run === 'true';
  const limit = parseInt(req.query.limit) || 10; // Max 10 per run to avoid spam

  try {
    // Ensure activation tracking column exists
    try {
      await dbQuery(`ALTER TABLE users ADD COLUMN IF NOT EXISTS activation_email_sent TIMESTAMP`);
    } catch (e) {
      /* Column might already exist */
    }

    // Find ALL dormant users:
    // 1. Have not used the product (responses_used = 0)
    // 2. Created more than 12 hours ago (give them time to explore)
    // 3. Haven't been sent an activation email yet
    // 4. Not test emails
    // WICHTIG: Trackt ob User via Magic Link kam!
    const dormantUsers = await dbAll(`
      SELECT id, email, business_name, created_at,
        COALESCE(created_via_magic_link, false) as is_magic_link
      FROM users
      WHERE responses_used = 0
        AND created_at < NOW() - INTERVAL '12 hours'
        AND activation_email_sent IS NULL
        AND email NOT LIKE '%test%'
        AND email NOT LIKE '%example%'
        AND email != 'berend.mainz@web.de'
        AND email != 'reviewer@tryreviewresponder.com'
      ORDER BY created_at DESC
      LIMIT $1
    `, [limit]) || [];

    // Separate magic link vs normal users
    const magicLinkCount = dormantUsers.filter(u => u.is_magic_link).length;
    const normalCount = dormantUsers.filter(u => !u.is_magic_link).length;

    console.log(`[activate-dormant] Found ${dormantUsers.length} dormant users (${magicLinkCount} magic link, ${normalCount} normal signup)`);

    if (dormantUsers.length === 0) {
      return res.json({
        success: true,
        sent: 0,
        message: 'No dormant users to activate',
      });
    }

    let sent = 0;
    const results = [];

    for (const user of dormantUsers) {
      // Check email history to avoid duplicates
      if (typeof wasEmailRecentlySent === 'function') {
        const recentlySent = await wasEmailRecentlySent(user.email, 'activation', 7 * 24); // 7 days
        if (recentlySent) {
          console.log(`[activate-dormant] Skipping ${user.email} - recently sent`);
          continue;
        }
      }

      // Detect language from email domain
      const isGerman = user.email.includes('.de') ||
        user.email.includes('.at') ||
        user.email.includes('.ch') ||
        (user.business_name && /[Ã¤Ã¶Ã¼ÃŸ]/i.test(user.business_name));

      const firstName = user.business_name?.split(/[\s,]+/)[0] || '';

      let subject, body;

      if (isGerman) {
        subject = `${user.business_name || 'Ihr Unternehmen'} - 20 kostenlose KI-Antworten warten`;
        body = `Hallo${firstName ? ` ${firstName}` : ''},

Sie haben sich bei ReviewResponder angemeldet, aber noch keine Review-Antwort generiert.

**Das dauert nur 30 Sekunden:**

1. Ã–ffnen Sie eine negative Google/Yelp Review
2. Kopieren Sie den Text
3. FÃ¼gen Sie ihn hier ein â†’ https://tryreviewresponder.com/login
4. Fertig - professionelle Antwort in Sekunden

Sie haben 20 kostenlose KI-Antworten. Die meisten Restaurants/Hotels sparen damit 2-3 Stunden pro Woche.

Bei Fragen: Einfach auf diese Email antworten.

Beste GrÃ¼ÃŸe,
Berend von ReviewResponder

P.S. Falls Sie das Produkt nicht brauchen, ignorieren Sie diese Email einfach - wir schreiben nicht nochmal.`;
      } else {
        subject = `${user.business_name || 'Your business'} - 20 free AI responses waiting`;
        body = `Hi${firstName ? ` ${firstName}` : ''},

You signed up for ReviewResponder but haven't generated a response yet.

**It takes just 30 seconds:**

1. Open a negative Google/Yelp review
2. Copy the text
3. Paste it here â†’ https://tryreviewresponder.com/login
4. Done - professional response in seconds

You have 20 free AI responses. Most restaurants/hotels save 2-3 hours per week with this.

Questions? Just reply to this email.

Best,
Berend from ReviewResponder

P.S. If you don't need this, just ignore this email - we won't write again.`;
      }

      if (dryRun) {
        results.push({
          email: user.email,
          business: user.business_name,
          signup_source: user.is_magic_link ? 'magic_link' : 'normal_signup',
          would_send: true
        });
        continue;
      }

      try {
        // Send via Resend or Brevo
        if (resend) {
          await resend.emails.send({
            from: 'Berend from ReviewResponder <berend@tryreviewresponder.com>',
            to: user.email,
            subject: subject,
            text: body,
          });
        } else if (brevoApi) {
          await brevoApi.sendTransacEmail({
            sender: { email: 'berend@tryreviewresponder.com', name: 'Berend from ReviewResponder' },
            to: [{ email: user.email }],
            subject: subject,
            textContent: body,
          });
        }

        // Mark as sent
        await dbQuery(
          'UPDATE users SET activation_email_sent = NOW() WHERE id = $1',
          [user.id]
        );

        // Record in email history if function exists
        if (typeof recordEmailSend === 'function') {
          await recordEmailSend(user.email, 'activation', { user_id: user.id });
        }

        sent++;
        results.push({
          email: user.email,
          business: user.business_name,
          signup_source: user.is_magic_link ? 'magic_link' : 'normal_signup',
          sent: true
        });
        console.log(`[activate-dormant] Sent activation to ${user.email} (${user.is_magic_link ? 'magic_link' : 'normal'})`);

        // Small delay between emails
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`[activate-dormant] Failed to send to ${user.email}:`, err.message);
        results.push({
          email: user.email,
          signup_source: user.is_magic_link ? 'magic_link' : 'normal_signup',
          error: err.message
        });
      }
    }

    // Count by signup source
    const sentMagicLink = results.filter(r => r.sent && r.signup_source === 'magic_link').length;
    const sentNormal = results.filter(r => r.sent && r.signup_source === 'normal_signup').length;

    res.json({
      success: true,
      sent,
      dry_run: dryRun,
      // WICHTIG: Breakdown nach Signup Source
      breakdown: {
        magic_link: { found: magicLinkCount, sent: sentMagicLink },
        normal_signup: { found: normalCount, sent: sentNormal },
      },
      users_activated: results,
      message: sent > 0
        ? `Sent ${sent} activation emails (${sentMagicLink} magic link, ${sentNormal} normal signup)`
        : dryRun ? `Would send to ${results.length} users (${magicLinkCount} magic link, ${normalCount} normal)` : 'No emails sent',
    });
  } catch (error) {
    console.error('Dormant user activation error:', error);
    res.status(500).json({ error: 'Failed to activate dormant users' });
  }
});

// GET /api/cron/ab-test-evaluate - Evaluate A/B tests and select winners
// Added 14.01.2026: Part of night automation system
app.all('/api/cron/ab-test-evaluate', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Ensure table exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS email_ab_tests (
        id SERIAL PRIMARY KEY,
        test_name TEXT NOT NULL,
        test_type TEXT NOT NULL,
        variant_a TEXT NOT NULL,
        variant_b TEXT NOT NULL,
        sends_a INT DEFAULT 0,
        clicks_a INT DEFAULT 0,
        sends_b INT DEFAULT 0,
        clicks_b INT DEFAULT 0,
        winner TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        ended_at TIMESTAMP
      )
    `);

    // Find tests ready for evaluation (at least 50 sends per variant)
    const testsToEvaluate = await dbAll(`
      SELECT * FROM email_ab_tests
      WHERE winner IS NULL
        AND ended_at IS NULL
        AND sends_a >= 50
        AND sends_b >= 50
    `);

    const evaluated = [];

    for (const test of testsToEvaluate || []) {
      const ctrA = test.sends_a > 0 ? ((test.clicks_a / test.sends_a) * 100).toFixed(2) : 0;
      const ctrB = test.sends_b > 0 ? ((test.clicks_b / test.sends_b) * 100).toFixed(2) : 0;

      // Winner is variant with higher CTR (need at least 20% relative difference to declare winner)
      let winner = null;
      const relativeDiff = Math.abs(ctrA - ctrB) / Math.max(ctrA, ctrB, 0.01);

      if (relativeDiff >= 0.2) {
        winner = parseFloat(ctrA) > parseFloat(ctrB) ? 'A' : 'B';
      }

      if (winner) {
        await dbQuery(`UPDATE email_ab_tests SET winner = $1, ended_at = NOW() WHERE id = $2`, [
          winner,
          test.id,
        ]);

        evaluated.push({
          test_name: test.test_name,
          winner,
          variant_a: test.variant_a,
          variant_b: test.variant_b,
          ctr_a: `${ctrA}%`,
          ctr_b: `${ctrB}%`,
        });

        console.log(
          `ðŸ† A/B Test Winner: ${test.test_name} - Variant ${winner} (${winner === 'A' ? ctrA : ctrB}% CTR)`
        );
      }
    }

    // Get current active tests
    const activeTests = await dbAll(`
      SELECT test_name, test_type, variant_a, variant_b, sends_a, clicks_a, sends_b, clicks_b
      FROM email_ab_tests
      WHERE winner IS NULL AND ended_at IS NULL
    `);

    res.json({
      success: true,
      evaluated: evaluated.length,
      winners: evaluated,
      active_tests: activeTests || [],
      message:
        evaluated.length > 0
          ? `Found ${evaluated.length} A/B test winner(s)`
          : 'No tests ready for evaluation yet (need 50+ sends per variant)',
    });
  } catch (error) {
    console.error('A/B test evaluation error:', error);
    res.status(500).json({ error: 'Failed to evaluate A/B tests' });
  }
});

// POST /api/admin/create-ab-test - Create a new A/B test
// Added 14.01.2026: Admin endpoint for setting up tests
app.post('/api/admin/create-ab-test', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { test_name, test_type, variant_a, variant_b } = req.body;

  if (!test_name || !test_type || !variant_a || !variant_b) {
    return res
      .status(400)
      .json({ error: 'Missing required fields: test_name, test_type, variant_a, variant_b' });
  }

  try {
    // Ensure table exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS email_ab_tests (
        id SERIAL PRIMARY KEY,
        test_name TEXT NOT NULL,
        test_type TEXT NOT NULL,
        variant_a TEXT NOT NULL,
        variant_b TEXT NOT NULL,
        sends_a INT DEFAULT 0,
        clicks_a INT DEFAULT 0,
        sends_b INT DEFAULT 0,
        clicks_b INT DEFAULT 0,
        winner TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        ended_at TIMESTAMP
      )
    `);

    const result = await dbQuery(
      `INSERT INTO email_ab_tests (test_name, test_type, variant_a, variant_b)
       VALUES ($1, $2, $3, $4) RETURNING id`,
      [test_name, test_type, variant_a, variant_b]
    );

    res.json({
      success: true,
      test_id: result.rows?.[0]?.id || result.id,
      message: `A/B test "${test_name}" created`,
      test: { test_name, test_type, variant_a, variant_b },
    });
  } catch (error) {
    console.error('Create A/B test error:', error);
    res.status(500).json({ error: 'Failed to create A/B test' });
  }
});

// GET /api/admin/ab-tests - List all A/B tests
app.get('/api/admin/ab-tests', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const tests = await dbAll(`
      SELECT *,
        CASE WHEN sends_a > 0 THEN ROUND(clicks_a::numeric / sends_a * 100, 2) ELSE 0 END as ctr_a,
        CASE WHEN sends_b > 0 THEN ROUND(clicks_b::numeric / sends_b * 100, 2) ELSE 0 END as ctr_b
      FROM email_ab_tests
      ORDER BY created_at DESC
    `);

    res.json({
      success: true,
      tests: tests || [],
      active: (tests || []).filter(t => !t.winner).length,
      completed: (tests || []).filter(t => t.winner).length,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get A/B tests' });
  }
});

// GET /api/cron/enrich-g2-leads - Find domain and email for G2 competitor leads
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/enrich-g2-leads', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const results = { domains_found: 0, emails_found: 0, leads_processed: 0 };

  try {
    // Step 1: Find domains for G2 leads without website (Clearbit Autocomplete - FREE)
    const leadsNeedingDomain = await dbAll(`
      SELECT id, business_name FROM outreach_leads
      WHERE website IS NULL AND lead_type = 'g2_competitor' AND status = 'new'
      LIMIT 10
    `);

    for (const lead of leadsNeedingDomain) {
      try {
        const clearbitUrl = `https://autocomplete.clearbit.com/v1/companies/suggest?query=${encodeURIComponent(lead.business_name)}`;
        const response = await fetch(clearbitUrl);
        const companies = await response.json();

        if (companies && companies.length > 0 && companies[0].domain) {
          // Strict similarity check to avoid false positives
          const searchName = lead.business_name.toLowerCase().trim();
          const foundName = companies[0].name.toLowerCase().trim();
          const foundFirstWord = foundName.split(' ')[0];

          // Skip if search name is too short (< 5 chars) - too generic
          if (searchName.length < 5) {
            console.log(`âš ï¸ Skipping ${lead.business_name}: name too short for reliable matching`);
            continue;
          }

          // Check similarity: found name should START with search name, or search name should be the first word
          const isGoodMatch =
            foundName.startsWith(searchName) ||
            foundFirstWord === searchName ||
            searchName.startsWith(foundFirstWord);

          if (isGoodMatch) {
            const website = `https://${companies[0].domain}`;
            await dbQuery('UPDATE outreach_leads SET website = $1 WHERE id = $2', [
              website,
              lead.id,
            ]);
            console.log(`âœ… Found domain for ${lead.business_name}: ${companies[0].domain}`);
            results.domains_found++;
          } else {
            console.log(
              `âš ï¸ Skipping ${lead.business_name}: best match "${companies[0].name}" doesn't match well enough`
            );
          }
        }
        await new Promise(r => setTimeout(r, 300));
      } catch (e) {}
    }

    // Step 2: Find emails for G2 leads with website
    const leadsNeedingEmail = await dbAll(`
      SELECT id, business_name, website, contact_name, job_title FROM outreach_leads
      WHERE email IS NULL AND website IS NOT NULL AND lead_type = 'g2_competitor' AND status = 'new'
      LIMIT 10
    `);

    for (const lead of leadsNeedingEmail) {
      let emailFound = null;
      results.leads_processed++;

      // Try website scraper first
      try {
        const scrapedEmail = await scrapeEmailFromWebsite(lead.website);
        if (scrapedEmail) {
          emailFound = scrapedEmail;
          await dbQuery('UPDATE outreach_leads SET email = $1, email_source = $2 WHERE id = $3', [
            emailFound,
            'website_scraper',
            lead.id,
          ]);
          results.emails_found++;
          continue;
        }
      } catch (e) {}

      // Fallback to Hunter.io
      if (!emailFound && process.env.HUNTER_API_KEY) {
        try {
          const domain = lead.website
            .replace(/^https?:\/\//, '')
            .replace(/^www\./, '')
            .split('/')[0];
          const hunterUrl = `https://api.hunter.io/v2/domain-search?domain=${domain}&api_key=${process.env.HUNTER_API_KEY}`;
          const response = await fetch(hunterUrl);
          const data = await response.json();

          if (data.data?.emails && data.data.emails.length > 0) {
            let bestEmail = data.data.emails[0];

            // Try to match job title
            if (lead.job_title || lead.contact_name) {
              const titleKeywords = (lead.job_title || lead.contact_name)
                .toLowerCase()
                .split(/\s+/);
              const matchingEmail = data.data.emails.find(e => {
                const position = (e.position || '').toLowerCase();
                return titleKeywords.some(kw => position.includes(kw));
              });
              if (matchingEmail) bestEmail = matchingEmail;
            }

            await dbQuery('UPDATE outreach_leads SET email = $1, email_source = $2 WHERE id = $3', [
              bestEmail.value,
              'hunter.io',
              lead.id,
            ]);

            if (bestEmail.first_name && bestEmail.last_name) {
              await dbQuery('UPDATE outreach_leads SET contact_name = $1 WHERE id = $2', [
                `${bestEmail.first_name} ${bestEmail.last_name}`,
                lead.id,
              ]);
            }
            results.emails_found++;
          }
          await new Promise(r => setTimeout(r, 500));
        } catch (e) {}
      }
    }

    res.json({ success: true, ...results });
  } catch (error) {
    console.error('Enrich G2 leads error:', error);
    res
      .status(500)
      .json({ error: 'Failed to enrich leads', details: error.message?.substring(0, 100) });
  }
});

// ==========================================
// AUTOMATED OUTREACH SYSTEM
// Fully automated lead generation & cold email
// ==========================================

// Initialize outreach tables
async function initOutreachTables() {
  try {
    // Leads table - stores scraped business contacts
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS outreach_leads (
        id SERIAL PRIMARY KEY,
        business_name TEXT NOT NULL,
        business_type TEXT,
        address TEXT,
        city TEXT,
        state TEXT,
        country TEXT DEFAULT 'US',
        phone TEXT,
        website TEXT,
        google_rating DECIMAL(2,1),
        google_reviews_count INTEGER,
        email TEXT,
        email_verified BOOLEAN DEFAULT FALSE,
        email_source TEXT,
        contact_name TEXT,
        status TEXT DEFAULT 'new',
        source TEXT DEFAULT 'google_places',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(business_name, city)
      )
    `);

    // Email sequences table - tracks sent emails
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS outreach_emails (
        id SERIAL PRIMARY KEY,
        lead_id INTEGER REFERENCES outreach_leads(id),
        email TEXT NOT NULL,
        sequence_number INTEGER DEFAULT 1,
        subject TEXT NOT NULL,
        body TEXT NOT NULL,
        status TEXT DEFAULT 'pending',
        sent_at TIMESTAMP,
        opened_at TIMESTAMP,
        clicked_at TIMESTAMP,
        replied_at TIMESTAMP,
        bounced BOOLEAN DEFAULT FALSE,
        campaign TEXT DEFAULT 'main',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Outreach campaigns config
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS outreach_campaigns (
        id SERIAL PRIMARY KEY,
        name TEXT UNIQUE NOT NULL,
        active BOOLEAN DEFAULT TRUE,
        daily_limit INTEGER DEFAULT 50,
        sent_today INTEGER DEFAULT 0,
        last_reset TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        target_industries TEXT[],
        target_cities TEXT[],
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Insert default campaign if not exists
    await dbQuery(`
      INSERT INTO outreach_campaigns (name, target_industries, target_cities)
      VALUES ('main', ARRAY['restaurant', 'hotel', 'dental', 'medical', 'legal', 'automotive'],
              ARRAY['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Miami', 'Austin', 'Denver'])
      ON CONFLICT (name) DO NOTHING
    `);

    // Add review alert columns (for personalized outreach with AI-generated response drafts)
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS worst_review_text TEXT`);
    await dbQuery(
      `ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS worst_review_rating INTEGER`
    );
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS worst_review_author TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS ai_response_draft TEXT`);
    await dbQuery(
      `ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS has_bad_review BOOLEAN DEFAULT FALSE`
    );

    // Add columns for scraped leads (G2, Yelp, TripAdvisor)
    await dbQuery(
      `ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS lead_type TEXT DEFAULT 'restaurant'`
    ); // 'restaurant', 'g2_competitor', 'tripadvisor'
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS competitor_platform TEXT`); // 'birdeye', 'podium', etc.
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS pain_points TEXT[]`); // Array of pain points
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS platform_url TEXT`); // Original Yelp/G2/TripAdvisor URL
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS job_title TEXT`); // For G2 leads
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS company_size TEXT`); // For G2 leads
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS review_quote TEXT`); // Quote from their negative review
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS outreach_angle TEXT`); // Personalized angle for outreach

    // Demo generation columns for personalized outreach with demo links
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS demo_token TEXT`); // Unique demo page token
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS demo_url TEXT`); // Full demo page URL

    // Omnichannel outreach columns - for multi-platform demo delivery
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS twitter_handle TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS facebook_page TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS instagram_handle TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS linkedin_company TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS google_business_url TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS contact_form_url TEXT`);
    await dbQuery(`ALTER TABLE outreach_leads ADD COLUMN IF NOT EXISTS channels_contacted JSONB DEFAULT '{}'::jsonb`);

    // A/B Testing table for email subject lines
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS outreach_ab_tests (
        id SERIAL PRIMARY KEY,
        test_name TEXT UNIQUE NOT NULL,
        variant_a_subject TEXT NOT NULL,
        variant_b_subject TEXT NOT NULL,
        variant_c_subject TEXT,
        variant_d_subject TEXT,
        variant_a_sent INTEGER DEFAULT 0,
        variant_b_sent INTEGER DEFAULT 0,
        variant_c_sent INTEGER DEFAULT 0,
        variant_d_sent INTEGER DEFAULT 0,
        variant_a_opens INTEGER DEFAULT 0,
        variant_b_opens INTEGER DEFAULT 0,
        variant_c_opens INTEGER DEFAULT 0,
        variant_d_opens INTEGER DEFAULT 0,
        winner TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add ab_test_variant column to outreach_emails to track which variant was sent
    await dbQuery(`ALTER TABLE outreach_emails ADD COLUMN IF NOT EXISTS ab_variant TEXT`);
    await dbQuery(
      `ALTER TABLE outreach_emails ADD COLUMN IF NOT EXISTS provider TEXT DEFAULT 'resend'`
    );

    // Unsubscribes table - respects email opt-outs (CAN-SPAM compliance)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS unsubscribes (
        id SERIAL PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        reason TEXT,
        unsubscribed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await dbQuery(
      `CREATE INDEX IF NOT EXISTS idx_unsubscribes_email ON unsubscribes(LOWER(email))`
    );

    // Email Suppressions table - for bounces, complaints (anti-spam)
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS email_suppressions (
        id SERIAL PRIMARY KEY,
        email_address TEXT NOT NULL,
        reason VARCHAR(50) NOT NULL,
        details TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(email_address, reason)
      )
    `);
    await dbQuery(
      `CREATE INDEX IF NOT EXISTS idx_email_suppressions_email ON email_suppressions(LOWER(email_address))`
    );

    // Initialize default A/B test for sequence1 subject lines (only if not exists)
    await dbQuery(`
      INSERT INTO outreach_ab_tests (test_name, variant_a_subject, variant_b_subject, variant_c_subject, variant_d_subject)
      VALUES (
        'sequence1_subject',
        '{business_name} - quick question',
        'Your {review_count} Google reviews - quick tip',
        'Free response draft for {business_name}',
        '{business_name} - saw your 2-star review'
      )
      ON CONFLICT (test_name) DO NOTHING
    `);

    // Sales Automation Log - tracks all sales actions across Claude sessions
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS sales_automation_log (
        id SERIAL PRIMARY KEY,
        action_type VARCHAR(50) NOT NULL,
        action_category VARCHAR(30) NOT NULL,
        details JSONB,
        session_id VARCHAR(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await dbQuery(
      `CREATE INDEX IF NOT EXISTS idx_sal_type_date ON sales_automation_log(action_type, created_at DESC)`
    );
    await dbQuery(
      `CREATE INDEX IF NOT EXISTS idx_sal_category ON sales_automation_log(action_category)`
    );

    // ============================================
    // PARALLEL-SAFE SYSTEM FOR CLAUDE SESSIONS
    // ============================================
    // Processing locks table - prevents duplicate processing across parallel Claude sessions
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS processing_locks (
        id SERIAL PRIMARY KEY,
        resource_type VARCHAR(50) NOT NULL,
        resource_id VARCHAR(255) NOT NULL,
        session_id VARCHAR(50),
        acquired_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        expires_at TIMESTAMP NOT NULL,
        UNIQUE(resource_type, resource_id)
      )
    `);
    await dbQuery(`CREATE INDEX IF NOT EXISTS idx_locks_expires ON processing_locks(expires_at)`);

    // Email send history - for deduplication across sessions
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS email_send_history (
        id SERIAL PRIMARY KEY,
        email_address TEXT NOT NULL,
        email_type VARCHAR(50) NOT NULL,
        sequence_number INTEGER DEFAULT 1,
        idempotency_key VARCHAR(255) UNIQUE,
        sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        session_id VARCHAR(50)
      )
    `);
    await dbQuery(`CREATE INDEX IF NOT EXISTS idx_email_history_addr ON email_send_history(email_address, email_type)`);
    await dbQuery(`CREATE INDEX IF NOT EXISTS idx_email_history_time ON email_send_history(sent_at DESC)`);

    // Clean up expired locks automatically
    await dbQuery(`DELETE FROM processing_locks WHERE expires_at < NOW()`);

    console.log('âœ… Outreach tables initialized (with parallel-safe system)');
  } catch (error) {
    console.error('Error initializing outreach tables:', error);
  }
}

// Call this after main initDatabase
initOutreachTables();

// ============================================
// PARALLEL-SAFE HELPER FUNCTIONS
// ============================================

/**
 * Acquire a lock on a resource (e.g., lead, email)
 * Returns true if lock acquired, false if resource is already locked
 * @param {string} resourceType - 'lead', 'email', 'scraper', etc.
 * @param {string} resourceId - Unique identifier (lead_id, email address, etc.)
 * @param {number} ttlSeconds - Lock duration in seconds (default: 60)
 */
async function acquireLock(resourceType, resourceId, ttlSeconds = 60) {
  const sessionId = process.env.CLAUDE_SESSION || 'unknown';
  const expiresAt = new Date(Date.now() + ttlSeconds * 1000);

  try {
    // Clean up expired locks first
    await dbQuery(`DELETE FROM processing_locks WHERE expires_at < NOW()`);

    // Try to insert lock (will fail if already exists)
    await dbQuery(
      `INSERT INTO processing_locks (resource_type, resource_id, session_id, expires_at)
       VALUES ($1, $2, $3, $4)`,
      [resourceType, resourceId, sessionId, expiresAt]
    );
    return true;
  } catch (error) {
    if (error.code === '23505') { // Unique violation - lock exists
      console.log(`ðŸ”’ Lock exists for ${resourceType}:${resourceId} (another session processing)`);
      return false;
    }
    console.error('Error acquiring lock:', error);
    return false;
  }
}

/**
 * Release a lock on a resource
 */
async function releaseLock(resourceType, resourceId) {
  try {
    await dbQuery(
      `DELETE FROM processing_locks WHERE resource_type = $1 AND resource_id = $2`,
      [resourceType, resourceId]
    );
  } catch (error) {
    console.error('Error releasing lock:', error);
  }
}

/**
 * Check if an email was recently sent (deduplication)
 * @param {string} emailAddress - Recipient email
 * @param {string} emailType - Type of email ('outreach', 'followup', 'demo', etc.)
 * @param {number} windowMinutes - Time window to check (default: 60 minutes)
 */
async function wasEmailRecentlySent(emailAddress, emailType, windowMinutes = 60) {
  try {
    const result = await dbGet(
      `SELECT COUNT(*) as count FROM email_send_history
       WHERE email_address = $1 AND email_type = $2
       AND sent_at > NOW() - INTERVAL '${windowMinutes} minutes'`,
      [emailAddress.toLowerCase(), emailType]
    );
    return parseInt(result?.count || 0) > 0;
  } catch (error) {
    console.error('Error checking email history:', error);
    return false; // Fail open - allow send if check fails
  }
}

/**
 * Record an email send in history (for deduplication)
 */
async function recordEmailSend(emailAddress, emailType, sequenceNumber = 1, idempotencyKey = null) {
  const sessionId = process.env.CLAUDE_SESSION || 'unknown';
  try {
    await dbQuery(
      `INSERT INTO email_send_history (email_address, email_type, sequence_number, idempotency_key, session_id)
       VALUES ($1, $2, $3, $4, $5)
       ON CONFLICT (idempotency_key) DO NOTHING`,
      [emailAddress.toLowerCase(), emailType, sequenceNumber, idempotencyKey, sessionId]
    );
  } catch (error) {
    console.error('Error recording email send:', error);
  }
}

/**
 * Safe outreach email send - handles locking and deduplication
 * Returns { sent: boolean, reason: string }
 */
async function safeOutreachEmail(leadId, emailAddress, emailType, sendFn) {
  const lockKey = `email:${emailAddress.toLowerCase()}:${emailType}`;
  const sessionId = process.env.CLAUDE_SESSION || 'unknown';

  // 1. Check if email was recently sent (within last 60 min for same type)
  const recentlySent = await wasEmailRecentlySent(emailAddress, emailType, 60);
  if (recentlySent) {
    console.log(`â­ï¸ [${sessionId}] Skipping ${emailType} to ${emailAddress} - recently sent`);
    return { sent: false, reason: 'recently_sent' };
  }

  // 2. Try to acquire lock
  const locked = await acquireLock('email', lockKey, 120); // 2 min lock
  if (!locked) {
    console.log(`â­ï¸ [${sessionId}] Skipping ${emailType} to ${emailAddress} - another session processing`);
    return { sent: false, reason: 'locked_by_other_session' };
  }

  try {
    // 3. Double-check not sent while waiting for lock
    const stillNotSent = !(await wasEmailRecentlySent(emailAddress, emailType, 5));
    if (!stillNotSent) {
      return { sent: false, reason: 'sent_during_lock_wait' };
    }

    // 4. Generate idempotency key
    const idempotencyKey = `${emailType}:${emailAddress}:${Date.now()}:${leadId}`;

    // 5. Send the email
    const result = await sendFn();

    // 6. Record in history
    await recordEmailSend(emailAddress, emailType, 1, idempotencyKey);

    console.log(`âœ… [${sessionId}] Sent ${emailType} to ${emailAddress}`);
    return { sent: true, reason: 'success', result };

  } catch (error) {
    console.error(`âŒ [${sessionId}] Error sending ${emailType} to ${emailAddress}:`, error);
    return { sent: false, reason: 'error', error: error.message };
  } finally {
    // 7. Always release lock
    await releaseLock('email', lockKey);
  }
}

/**
 * Safe lead processing - prevents duplicate processing across sessions
 */
async function safeProcessLead(leadId, processFn) {
  const lockKey = `lead:${leadId}`;
  const sessionId = process.env.CLAUDE_SESSION || 'unknown';

  const locked = await acquireLock('lead', lockKey, 300); // 5 min lock for lead processing
  if (!locked) {
    console.log(`â­ï¸ [${sessionId}] Skipping lead ${leadId} - another session processing`);
    return { processed: false, reason: 'locked_by_other_session' };
  }

  try {
    const result = await processFn();
    console.log(`âœ… [${sessionId}] Processed lead ${leadId}`);
    return { processed: true, result };
  } catch (error) {
    console.error(`âŒ [${sessionId}] Error processing lead ${leadId}:`, error);
    return { processed: false, reason: 'error', error: error.message };
  } finally {
    await releaseLock('lead', lockKey);
  }
}

// ============================================
// SALES AUTOMATION STATE HELPERS
// ============================================

// Log a sales automation action
async function logSalesAction(actionType, category, details = {}) {
  try {
    const sessionId = process.env.CLAUDE_SESSION || 'unknown';
    await dbQuery(
      `INSERT INTO sales_automation_log (action_type, action_category, details, session_id)
       VALUES ($1, $2, $3, $4)`,
      [actionType, category, JSON.stringify(details), sessionId]
    );
  } catch (error) {
    console.error('Error logging sales action:', error);
  }
}

// Get consolidated sales state for Claude sessions
async function getSalesState() {
  try {
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);

    const weekStart = new Date();
    weekStart.setDate(weekStart.getDate() - 7);

    // Today's actions by type
    const todayActions = await dbQuery(
      `SELECT action_type, COUNT(*) as count, SUM((details->>'count')::int) as total_count
       FROM sales_automation_log
       WHERE created_at >= $1
       GROUP BY action_type`,
      [todayStart]
    );

    // Last 10 actions
    const lastActions = await dbQuery(
      `SELECT action_type, action_category, details, session_id, created_at
       FROM sales_automation_log
       ORDER BY created_at DESC
       LIMIT 10`
    );

    // Session notes (action_type = 'session_note')
    const notes = await dbQuery(
      `SELECT details->>'note' as note, created_at
       FROM sales_automation_log
       WHERE action_type = 'session_note'
       ORDER BY created_at DESC
       LIMIT 5`
    );

    // Pending LinkedIn connections
    const pendingLinkedIn = await dbQuery(
      `SELECT COUNT(*) as count FROM linkedin_outreach
       WHERE connection_sent = false AND demo_token IS NOT NULL`
    );

    // Leads without email sent
    const pendingLeads = await dbQuery(
      `SELECT COUNT(*) as count FROM outreach_leads
       WHERE email IS NOT NULL AND status = 'new'`
    );

    // Week stats from existing tables
    const weekEmails = await dbQuery(
      `SELECT COUNT(*) as sent,
              SUM(CASE WHEN opened_at IS NOT NULL THEN 1 ELSE 0 END) as opened
       FROM outreach_emails
       WHERE sent_at >= $1`,
      [weekStart]
    );

    // Format today's stats
    const today = {};
    for (const row of todayActions.rows) {
      today[row.action_type] = parseInt(row.total_count || row.count) || 0;
    }

    return {
      today: {
        leads_scraped: today.scrape_leads || 0,
        emails_sent: today.send_emails || 0,
        twitter_posts: today.twitter_post || 0,
        linkedin_demos: today.linkedin_demo_created || 0,
        demos_generated: today.demo_generated || 0,
      },
      this_week: {
        emails_sent: parseInt(weekEmails.rows[0]?.sent) || 0,
        emails_opened: parseInt(weekEmails.rows[0]?.opened) || 0,
        open_rate:
          weekEmails.rows[0]?.sent > 0
            ? ((weekEmails.rows[0]?.opened / weekEmails.rows[0]?.sent) * 100).toFixed(1) + '%'
            : '0%',
      },
      pending: {
        linkedin_connections: parseInt(pendingLinkedIn.rows[0]?.count) || 0,
        leads_not_emailed: parseInt(pendingLeads.rows[0]?.count) || 0,
      },
      last_actions: lastActions.rows.map(row => ({
        type: row.action_type,
        category: row.action_category,
        details: row.details,
        session: row.session_id,
        at: row.created_at,
      })),
      notes_from_previous_sessions: notes.rows.map(row => ({
        note: row.note,
        at: row.created_at,
      })),
    };
  } catch (error) {
    console.error('Error getting sales state:', error);
    return { error: error.message };
  }
}

// Add a note for next Claude session
async function addSessionNote(note) {
  await logSalesAction('session_note', 'meta', { note });
}

// German-speaking cities for language detection
const GERMAN_CITIES = [
  'Berlin',
  'MÃ¼nchen',
  'Munich',
  'Hamburg',
  'Frankfurt',
  'KÃ¶ln',
  'Cologne',
  'Stuttgart',
  'DÃ¼sseldorf',
  'Wien',
  'Vienna',
  'ZÃ¼rich',
  'Zurich',
  'Salzburg',
  'Graz',
  'Innsbruck',
  'Bern',
  'Basel',
];

// Helper: Detect language based on city
function detectLanguage(city) {
  if (!city) return 'en';
  return GERMAN_CITIES.some(gc => city.toLowerCase().includes(gc.toLowerCase())) ? 'de' : 'en';
}

// Email templates for cold outreach - ENGLISH
const EMAIL_TEMPLATES_EN = {
  sequence1: {
    subject: '{business_name} - quick question',
    body: `Hi,

I noticed {business_name} has {review_count}+ Google reviews - impressive!

Quick question: How much time does your team spend responding to customer reviews each week?

I built a tool that helps with exactly this - 3 seconds per response instead of 5 minutes.

If you're interested: https://tryreviewresponder.com

Cheers,
Berend

P.S. I'm the founder, feel free to reply if you have any questions.`,
  },
  sequence2: {
    subject: 'Re: {business_name}',
    body: `Hey,

just wanted to check if you saw my last email.

Businesses that respond to reviews get higher ratings and up to 9% more revenue (Harvard study) - but I get that time is tight.

If you have 2 minutes: https://tryreviewresponder.com

Cheers,
Berend`,
  },
  sequence3: {
    subject: '{business_name}',
    body: `Hi,

last email from me - promise!

If review management isn't a priority right now, no worries.

But if you ever find reviews piling up: https://tryreviewresponder.com is there.

Wishing you continued success!

Berend`,
  },
};

// Email templates for cold outreach - GERMAN
const EMAIL_TEMPLATES_DE = {
  sequence1: {
    subject: '{business_name} - kurze Frage',
    body: `Hi,

ich hab gesehen dass {business_name} Ã¼ber {review_count} Google Reviews hat - Respekt!

Kurze Frage: Wie viel Zeit verbringt ihr pro Woche damit, auf Kundenrezensionen zu antworten?

Ich hab ein Tool gebaut das genau dabei hilft - 3 Sekunden pro Antwort statt 5 Minuten.

Falls interessant: https://tryreviewresponder.com

GrÃ¼ÃŸe,
Berend

P.S. Bin der GrÃ¼nder, bei Fragen einfach antworten.`,
  },
  sequence2: {
    subject: 'Re: {business_name}',
    body: `Hey nochmal,

wollte nur kurz nachfragen ob du meine letzte Mail gesehen hast.

Wer auf Reviews antwortet bekommt bessere Bewertungen und bis zu 9% mehr Umsatz (Harvard Studie) - aber ich versteh dass Zeit knapp ist.

Falls du mal 2 Minuten hast: https://tryreviewresponder.com

GrÃ¼ÃŸe,
Berend`,
  },
  sequence3: {
    subject: '{business_name}',
    body: `Hi,

letzte Mail von mir - versprochen!

Falls Review-Management gerade keine PrioritÃ¤t ist, kein Problem.

Aber falls Reviews mal liegen bleiben: https://tryreviewresponder.com ist da.

Viel Erfolg weiterhin!

Berend`,
  },
};

// Helper: Extract key complaint from review text for super-personalized subjects
function extractKeyComplaint(reviewText) {
  if (!reviewText || reviewText.length < 10) return null;

  const text = reviewText.toLowerCase();

  // Common complaint patterns with keywords
  const complaintPatterns = [
    { pattern: /wait(ed|ing)?\s*(for\s*)?([\d]+\s*(min|hour|hr)s?|forever|too long|so long)/i, keyword: 'long wait' },
    { pattern: /cold\s*(food|pizza|burger|fries|meal)/i, keyword: 'cold food' },
    { pattern: /(rude|unfriendly|disrespectful)\s*(staff|waiter|server|service)/i, keyword: 'rude staff' },
    { pattern: /wrong\s*(order|food|item|dish)/i, keyword: 'wrong order' },
    { pattern: /(over\s*priced|too\s*expensive|not\s*worth)/i, keyword: 'pricing' },
    { pattern: /(dirty|unclean|disgusting|filthy)/i, keyword: 'cleanliness' },
    { pattern: /(slow|terrible|awful|horrible)\s*service/i, keyword: 'slow service' },
    { pattern: /(hair|bug|insect|fly)\s*(in|on)\s*(my|the|our)/i, keyword: 'hygiene issue' },
    { pattern: /never\s*(coming|going|return)/i, keyword: 'bad experience' },
    { pattern: /(parking|no\s*space|couldn't\s*park)/i, keyword: 'parking' },
    { pattern: /(noisy|loud|couldn't\s*hear)/i, keyword: 'noise' },
    { pattern: /(small\s*portions?|tiny|not\s*enough)/i, keyword: 'portion size' },
  ];

  for (const { pattern, keyword } of complaintPatterns) {
    if (pattern.test(text)) {
      return keyword;
    }
  }

  // Fallback: extract first quoted phrase or first 3 words after negative word
  const negativeMatch = text.match(/(terrible|awful|horrible|worst|bad|disappointing)\s+(\w+\s+\w+\s+\w+)/i);
  if (negativeMatch) {
    return negativeMatch[2].trim();
  }

  return null;
}

// Email templates for REVIEW ALERT outreach - ENGLISH
// These are sent when we find a business with a bad review
const REVIEW_ALERT_TEMPLATES_EN = {
  // With demo link - used when we have 3+ reviews to show
  // SUPER-PERSONALIZED: Uses reviewer name + specific complaint = max open rate
  sequence1: {
    subject: 'Re: {review_author_first}\'s review{complaint_suffix} at {business_name}',
    subjectFallback: '{business_name} - noticed your {review_rating}-star review',
    body: `Hi,

I noticed {business_name} has a {review_rating}-star review on Google:

"{review_text_truncated}"
- {review_author}

Here's a professional response you could use:

---
{ai_response_draft}
---

Feel free to use it directly - it's free.

I also prepared responses to 2 more of your reviews: <a href="{demo_url}" style="color: #4F46E5; text-decoration: underline;">See all responses â†’</a>

Best,
Berend

P.S. I'm the founder. Reply if you have questions.`,
  },
  // Fallback for leads without demo (only 1 bad review or demo generation failed)
  sequence1_no_demo: {
    subject: 'Re: {review_author_first}\'s review{complaint_suffix} at {business_name}',
    subjectFallback: '{business_name} - saw your {review_rating}-star review',
    body: `Hi,

I noticed {business_name} has a {review_rating}-star review on Google:

"{review_text_truncated}"
- {review_author}

Here's a professional response you could use:

---
{ai_response_draft}
---

This response is free - feel free to use it directly.

If you'd like AI-generated responses for all your reviews, try ReviewResponder:
https://tryreviewresponder.com?ref=alert

Best,
Berend

P.S. I'm the founder. Reply if you have questions.`,
  },
};

// Email templates for REVIEW ALERT outreach - GERMAN
const REVIEW_ALERT_TEMPLATES_DE = {
  // With demo link - personal, conversational tone
  // SUPER-PERSONALIZED: Uses reviewer name + specific complaint = max open rate
  sequence1: {
    subject: 'Re: {review_author_first}s Bewertung{complaint_suffix_de} bei {business_name}',
    subjectFallback: '{business_name} - eure {review_rating}-Sterne Bewertung',
    body: `Hey,

bin gerade auf eine Bewertung von {business_name} gestoÃŸen und dachte mir ich schreib dir mal kurz.

Die hier meine ich:
"{review_text_truncated}" - {review_author}

Hab mal eine Antwort formuliert die du nutzen kÃ¶nntest:

{ai_response_draft}

Kannst du einfach so kopieren wenn du magst.

Hab noch 2 weitere Antworten fÃ¼r dich vorbereitet: <a href="{demo_url}" style="color: #4F46E5; text-decoration: underline;">Hier ansehen â†’</a>

Viele GrÃ¼ÃŸe
Berend`,
  },
  // Fallback without demo - personal tone
  sequence1_no_demo: {
    subject: 'Re: {review_author_first}s Bewertung{complaint_suffix_de} bei {business_name}',
    subjectFallback: '{business_name} - eure {review_rating}-Sterne Bewertung',
    body: `Hey,

bin gerade auf eine Bewertung von {business_name} gestoÃŸen und dachte mir ich schreib dir mal kurz.

Die hier meine ich:
"{review_text_truncated}" - {review_author}

Hab mal eine Antwort formuliert die du nutzen kÃ¶nntest:

{ai_response_draft}

Kannst du einfach so kopieren wenn du magst.

Falls du Ã¶fter Hilfe mit Reviews brauchst, schau mal hier vorbei:
https://tryreviewresponder.com?ref=alert

Viele GrÃ¼ÃŸe
Berend`,
  },
};

// Email templates for G2 COMPETITOR outreach - targeting unhappy Birdeye/Podium users
const G2_COMPETITOR_TEMPLATES_EN = {
  sequence1: {
    subject: 'Saw your {competitor_platform} review - found something simpler',
    body: `Hi{contact_name_greeting},

I saw your G2 review about {competitor_platform} - sounds like a frustrating experience.

"{review_quote}"

I hear this feedback a lot. That's why I built ReviewResponder - no complex platform, no daily bugs.

Just AI that writes professional review responses in 3 seconds.

Try 20 free responses: https://tryreviewresponder.com?ref=g2

Best,
Berend

P.S. I'm the founder. If you have questions, just reply.`,
  },
  sequence2: {
    subject: 'Re: {competitor_platform} alternative',
    body: `Hey{contact_name_greeting},

Quick follow-up on my last email.

I know switching tools is a hassle. But if you're still dealing with:
- Bugs every day
- Slow support
- Features that don't work

Maybe worth a quick look: https://tryreviewresponder.com?ref=g2

Cheers,
Berend`,
  },
};

// Email templates for G2 COMPETITOR outreach - GERMAN
const G2_COMPETITOR_TEMPLATES_DE = {
  sequence1: {
    subject: 'Ihre {competitor_platform} Bewertung - einfachere Alternative gefunden',
    body: `Hi{contact_name_greeting},

ich habe Ihre G2 Bewertung zu {competitor_platform} gesehen - klingt nach einer frustrierenden Erfahrung.

"{review_quote}"

Dieses Feedback hÃ¶re ich oft. Deshalb habe ich ReviewResponder gebaut - keine komplexe Plattform, keine tÃ¤glichen Bugs.

Einfach KI die professionelle Review-Antworten in 3 Sekunden schreibt.

20 kostenlose Antworten testen: https://tryreviewresponder.com?ref=g2

GrÃ¼ÃŸe,
Berend

P.S. Bin der GrÃ¼nder. Bei Fragen einfach antworten.`,
  },
  sequence2: {
    subject: 'Re: {competitor_platform} Alternative',
    body: `Hey{contact_name_greeting},

kurzes Follow-up zu meiner letzten Mail.

Ich weiÃŸ, Tool-Wechsel sind nervig. Aber falls Sie noch kÃ¤mpfen mit:
- TÃ¤gliche Bugs
- Langsamer Support
- Features die nicht funktionieren

Vielleicht einen kurzen Blick wert: https://tryreviewresponder.com?ref=g2

GrÃ¼ÃŸe,
Berend`,
  },
};

// Combined templates with language selection
const EMAIL_TEMPLATES = {
  sequence1: EMAIL_TEMPLATES_EN.sequence1,
  sequence2: EMAIL_TEMPLATES_EN.sequence2,
  sequence3: EMAIL_TEMPLATES_EN.sequence3,
  sequence1_de: EMAIL_TEMPLATES_DE.sequence1,
  sequence2_de: EMAIL_TEMPLATES_DE.sequence2,
  sequence3_de: EMAIL_TEMPLATES_DE.sequence3,
  // Review alert templates (only sequence 1 - one-shot value delivery)
  review_alert: REVIEW_ALERT_TEMPLATES_EN.sequence1,
  review_alert_de: REVIEW_ALERT_TEMPLATES_DE.sequence1,
  review_alert_no_demo: REVIEW_ALERT_TEMPLATES_EN.sequence1_no_demo,
  review_alert_no_demo_de: REVIEW_ALERT_TEMPLATES_DE.sequence1_no_demo,
  // G2 competitor templates (for unhappy Birdeye/Podium users)
  g2_competitor_1: G2_COMPETITOR_TEMPLATES_EN.sequence1,
  g2_competitor_2: G2_COMPETITOR_TEMPLATES_EN.sequence2,
  g2_competitor_1_de: G2_COMPETITOR_TEMPLATES_DE.sequence1,
  g2_competitor_2_de: G2_COMPETITOR_TEMPLATES_DE.sequence2,
};

// A/B Test subject line variants (will be dynamically loaded from DB)
const AB_TEST_VARIANTS = ['a', 'b', 'c', 'd'];

// Helper: Select A/B test variant randomly (weighted equally)
function selectABVariant(availableVariants = ['a', 'b', 'c', 'd']) {
  const randomIndex = Math.floor(Math.random() * availableVariants.length);
  return availableVariants[randomIndex];
}

// Helper: Get A/B test subject line for sequence 1
async function getABTestSubject(lead, baseSubject) {
  try {
    // Only run A/B test for sequence 1 emails (first cold email)
    const abTest = await dbGet(
      'SELECT * FROM outreach_ab_tests WHERE test_name = $1 AND is_active = TRUE',
      ['sequence1_subject']
    );

    if (!abTest) {
      return { subject: baseSubject, variant: null };
    }

    // Determine which variants are available (non-null subjects)
    const availableVariants = [];
    if (abTest.variant_a_subject) availableVariants.push('a');
    if (abTest.variant_b_subject) availableVariants.push('b');
    if (abTest.variant_c_subject) availableVariants.push('c');
    if (abTest.variant_d_subject) availableVariants.push('d');

    if (availableVariants.length === 0) {
      return { subject: baseSubject, variant: null };
    }

    // Select random variant
    const selectedVariant = selectABVariant(availableVariants);
    const variantSubject = abTest[`variant_${selectedVariant}_subject`];

    // Update sent count for this variant
    await dbQuery(
      `UPDATE outreach_ab_tests SET variant_${selectedVariant}_sent = variant_${selectedVariant}_sent + 1 WHERE test_name = $1`,
      ['sequence1_subject']
    );

    return { subject: variantSubject, variant: selectedVariant };
  } catch (error) {
    console.error('A/B test selection error:', error.message);
    return { subject: baseSubject, variant: null };
  }
}

// Helper: Get template based on language, lead type, and review status
function getTemplateForLead(sequenceNum, lead) {
  const lang = detectLanguage(lead.city);

  // G2 competitor leads (unhappy Birdeye/Podium users)
  if (lead.lead_type === 'g2_competitor' && sequenceNum <= 2) {
    return lang === 'de'
      ? EMAIL_TEMPLATES[`g2_competitor_${sequenceNum}_de`]
      : EMAIL_TEMPLATES[`g2_competitor_${sequenceNum}`];
  }

  // For leads with bad reviews, use the review alert template (only for first email)
  if (lead.has_bad_review && lead.ai_response_draft && sequenceNum === 1) {
    // Use demo template if demo_url exists, otherwise fallback to no_demo template
    if (lead.demo_url) {
      return lang === 'de' ? EMAIL_TEMPLATES.review_alert_de : EMAIL_TEMPLATES.review_alert;
    } else {
      return lang === 'de'
        ? EMAIL_TEMPLATES.review_alert_no_demo_de
        : EMAIL_TEMPLATES.review_alert_no_demo;
    }
  }

  // Default cold email templates
  const key = lang === 'de' ? `sequence${sequenceNum}_de` : `sequence${sequenceNum}`;
  return EMAIL_TEMPLATES[key];
}

// Helper: Get template with A/B tested subject (async version for sequence 1)
async function getTemplateForLeadWithABTest(sequenceNum, lead) {
  const template = getTemplateForLead(sequenceNum, lead);

  // Only apply A/B testing to sequence 1 of default templates (not G2 or review_alert)
  if (
    sequenceNum === 1 &&
    !lead.lead_type?.startsWith('g2') &&
    !(lead.has_bad_review && lead.ai_response_draft)
  ) {
    const { subject: abSubject, variant } = await getABTestSubject(lead, template.subject);
    return {
      ...template,
      subject: abSubject,
      abVariant: variant,
    };
  }

  return { ...template, abVariant: null };
}

// Helper: Extract owner name from business name
function getOwnerName(businessName) {
  if (!businessName) return 'The Team';
  // "Tony Quach & Co. CPA" â†’ "Tony"
  // "Mario's Pizza" â†’ "Mario"
  // "Smith Law Firm" â†’ "Smith Law Firm Team"
  // "The Coffee House" â†’ "The Coffee House Team"
  // "BLOCK HOUSE" â†’ "BLOCK HOUSE Team"
  // "Augustiner-Keller" â†’ "Augustiner-Keller Team"
  const name = businessName.trim();

  // If starts with "The", use full name + Team
  if (name.toLowerCase().startsWith('the ')) {
    return `${name} Team`;
  }

  // Check if first word looks like a person's name (capitalized, not all caps)
  const words = name.split(' ');
  const firstWord = words[0].replace(/['']s?$/, '');

  // If ALL CAPS (like "BLOCK HOUSE") or contains hyphen (like "Augustiner-Keller"), use brand name + Team
  if (firstWord === firstWord.toUpperCase() && firstWord.length > 2) {
    // Take first two words if available for brand names
    const brandName = words
      .slice(0, 2)
      .join(' ')
      .replace(/\s+(am|im|an|bei|in)\s+.*/i, '');
    return `${brandName} Team`;
  }

  // If contains hyphen, it's likely a brand name
  if (name.includes('-')) {
    const brandPart = name.split(' ')[0];
    return `${brandPart} Team`;
  }

  // Otherwise use first word as owner name (Mario, Tony, etc.)
  return firstWord || 'The Team';
}

// Helper: Get industry-specific context for better AI responses
function getIndustryContext(businessType) {
  const contexts = {
    'accounting firm': 'CPA services, tax preparation, bookkeeping, financial accuracy',
    restaurant: 'food quality, dining experience, service, atmosphere',
    hotel: 'hospitality, guest comfort, cleanliness, amenities',
    'dental office': 'dental care, patient comfort, oral health',
    'law firm': 'legal services, client representation, professionalism',
    'auto repair shop': 'vehicle repair, honest diagnostics, fair pricing',
    'hair salon': 'styling, customer satisfaction, personal care',
    gym: 'fitness, equipment, cleanliness, member experience',
    'real estate agency': 'property transactions, client service, local expertise',
    'medical clinic': 'patient care, health services, medical expertise',
    'retail store': 'product quality, customer service, shopping experience',
    spa: 'relaxation, wellness, treatment quality',
    'veterinary clinic': 'pet care, animal health, compassionate service',
    physiotherapy: 'rehabilitation, patient recovery, therapeutic care',
  };
  return contexts[businessType?.toLowerCase()] || 'professional services, customer satisfaction';
}

// Helper: Generate AI response draft for a bad review (used in outreach emails)
// ========== ANTHROPIC BEST PRACTICES 2025: Full XML Structure ==========
async function generateReviewAlertDraft(
  businessName,
  businessType,
  reviewText,
  reviewRating,
  reviewAuthor,
  city = null,
  googleRating = null,
  totalReviews = null
) {
  try {
    const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

    const ownerName = getOwnerName(businessName);
    const industryContext = getIndustryContext(businessType);

    // Build context parts
    const contextParts = [
      `Business: ${businessName}`,
      `Industry: ${businessType || 'local business'} (${industryContext})`,
    ];
    if (city) contextParts.push(`Location: ${city}`);
    if (googleRating) {
      let ratingStr = `Current Rating: ${googleRating} stars`;
      if (totalReviews) ratingStr += ` (${totalReviews} total reviews)`;
      contextParts.push(ratingStr);
    }

    const systemPrompt = `<role>
You are ${ownerName}, owner/manager of ${businessName}.
You are personally responding to a customer review.
</role>

<context>
<business_details>
${contextParts.join('\n')}
</business_details>
</context>

<voice>
Sound like a real human who cares, not a PR department.
Be warm and specific. Show empathy without being defensive.
</voice>

<style_rules>
- Address the reviewer BY NAME in your first sentence
- Reference SPECIFIC details they mentioned
- If negative: Show you understand their frustration, explain what you'll do differently
- If positive: Be warm about what made their visit special
- Length: 2-3 sentences - concise but meaningful
- End with " - ${businessName}"
</style_rules>

<avoid_patterns>
<forbidden_phrases>
${AI_SLOP_PHRASES.slice(0, 8)
  .map(p => `- "${p}"`)
  .join('\n')}
</forbidden_phrases>

<forbidden_words>
${AI_SLOP_WORDS.slice(0, 15).join(', ')}
</forbidden_words>
</avoid_patterns>

<output_format>
Write the response directly.
No quotes around the response.
No "Response:" prefix.
End with " - ${businessName}"
</output_format>`;

    const userPrompt = `<review rating="${reviewRating}" author="${reviewAuthor || 'a customer'}">
${reviewText}
</review>`;

    const completion = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      system: systemPrompt,
      messages: [{ role: 'user', content: userPrompt }],
    });

    return completion.content[0].text.trim();
  } catch (error) {
    console.error('Failed to generate review alert draft:', error.message);
    return null;
  }
}

// Helper: Generate a personalized demo for an outreach lead (3 reviews + AI responses)
// Returns { demo_url, demo_token, reviews_processed } or null if failed
async function generateDemoForLead(lead) {
  try {
    // Need review scraping API (SerpAPI or Outscraper) + Google Places
    const hasReviewApi = getSerpApiKeyCount() > 0 || process.env.OUTSCRAPER_API_KEY;
    if (!hasReviewApi || !process.env.GOOGLE_PLACES_API_KEY) {
      console.log('Missing API keys for demo generation');
      return null;
    }

    // Try to find the business on Google
    let placeId = null;
    let googleRating = null;
    let totalReviews = 0;

    try {
      const placeResult = await lookupPlaceId(lead.business_name, lead.city || '');
      placeId = placeResult.placeId;
      googleRating = placeResult.rating;
      totalReviews = placeResult.totalReviews || 0;
    } catch (err) {
      console.log(`Place lookup failed for ${lead.business_name}:`, err.message);
      return null;
    }

    if (!placeId) {
      console.log(`No place found for ${lead.business_name}`);
      return null;
    }

    // Scrape reviews via SerpAPI (get more than needed to filter)
    const allReviews = await scrapeGoogleReviews(placeId, 10);

    if (!allReviews || allReviews.length < 2) {
      console.log(`Not enough reviews to generate demo for ${lead.business_name}`);
      return null;
    }

    // === BUSINESS CONTEXT: Multi-Source Fallback System ===
    let scrapedContext = {
      description: null,
      specialties: [],
      ownerName: null,
      foundedYear: null,
      usps: [],
    };

    // Source 1: Website Scraping (FREE - try first)
    const websiteToScrape = lead.website;
    if (websiteToScrape) {
      try {
        console.log(`[1/3] Scraping website: ${websiteToScrape}...`);
        scrapedContext = await scrapeBusinessContext(websiteToScrape);
        if (scrapedContext.description) {
          console.log(
            `âœ“ Website: Found description (${scrapedContext.description.slice(0, 40)}...)`
          );
        }
      } catch (err) {
        console.log(`âœ— Website scrape failed: ${err.message}`);
      }
    }

    // Source 2: Google Places Details API (if no description yet)
    if (!scrapedContext.description && placeId) {
      try {
        console.log(`[2/3] Trying Google Places Details API...`);
        const placeDetails = await getPlaceDetails(placeId);
        if (placeDetails?.description) {
          scrapedContext.description = placeDetails.description;
          console.log(`âœ“ Google Places: Found editorial summary`);
        }
        // Also grab website if we didn't have one
        if (!websiteToScrape && placeDetails?.website) {
          // Try scraping the newly discovered website
          try {
            const websiteContext = await scrapeBusinessContext(placeDetails.website);
            if (websiteContext.ownerName) scrapedContext.ownerName = websiteContext.ownerName;
            if (websiteContext.foundedYear) scrapedContext.foundedYear = websiteContext.foundedYear;
            if (websiteContext.specialties?.length)
              scrapedContext.specialties = websiteContext.specialties;
          } catch {
            // Ignore website scrape errors
          }
        }
      } catch (err) {
        console.log(`âœ— Places Details failed: ${err.message}`);
      }
    }

    // Source 3: Google Knowledge Panel via SerpAPI (last resort)
    if (!scrapedContext.description) {
      try {
        console.log(`[3/3] Trying Google Knowledge Panel...`);
        const kgData = await getKnowledgePanel(lead.business_name, lead.city || '');
        if (kgData?.description) {
          scrapedContext.description = kgData.description;
          console.log(`âœ“ Knowledge Panel: Found description`);
        }
        if (!scrapedContext.ownerName && kgData?.ownerName) {
          scrapedContext.ownerName = kgData.ownerName;
        }
        if (!scrapedContext.foundedYear && kgData?.foundedYear) {
          scrapedContext.foundedYear = kgData.foundedYear;
        }
      } catch (err) {
        console.log(`âœ— Knowledge Panel failed: ${err.message}`);
      }
    }

    // Log final context status
    const contextFound =
      scrapedContext.description || scrapedContext.ownerName || scrapedContext.specialties?.length;
    console.log(
      `Context result for ${lead.business_name}: ${contextFound ? 'âœ“ Found' : 'âœ— None'} (desc: ${!!scrapedContext.description}, owner: ${!!scrapedContext.ownerName}, specialties: ${scrapedContext.specialties?.length || 0})`
    );

    // === Generate auto instructions and context ===
    const autoInstructions = generateAutoInstructions(lead, scrapedContext);
    const autoContext = generateAutoContext(lead, scrapedContext, allReviews);

    if (autoInstructions || autoContext) {
      console.log(`âœ“ Generated auto context/instructions for ${lead.business_name}`);
    }

    // Filter and sort reviews - prioritize negative (1-3 stars)
    const targetReviews = allReviews
      .filter(r => r.rating <= 3)
      .sort((a, b) => a.rating - b.rating)
      .slice(0, 3);

    // If not enough negative reviews, fill with others
    if (targetReviews.length < 3) {
      const remaining = allReviews.filter(r => r.rating > 3).slice(0, 3 - targetReviews.length);
      targetReviews.push(...remaining);
    }

    if (targetReviews.length === 0) {
      console.log(`No suitable reviews for demo for ${lead.business_name}`);
      return null;
    }

    // Generate AI responses for each review (with auto context/instructions)
    const demos = [];
    for (const review of targetReviews) {
      const aiResponse = await generateDemoResponse(
        review,
        lead.business_name,
        lead.business_type,
        lead.city,
        googleRating,
        totalReviews,
        autoContext, // NEW: Pass auto-generated business context
        autoInstructions // NEW: Pass auto-generated custom instructions
      );
      demos.push({
        review: {
          text: review.text,
          rating: review.rating,
          author: review.author,
          date: review.date,
          source: review.source || 'google',
          review_link: review.review_link || null,
          review_id: review.review_id || null,
        },
        ai_response: aiResponse,
      });
    }

    // Generate unique token
    const demoToken = generateDemoToken();
    const demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;

    // Save demo to database
    await dbQuery(
      `INSERT INTO demo_generations
       (business_name, google_place_id, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses, lead_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        lead.business_name,
        placeId,
        lead.city || null,
        googleRating,
        totalReviews,
        JSON.stringify(allReviews),
        demoToken,
        JSON.stringify(demos),
        lead.id || null,
      ]
    );

    console.log(`Demo generated for ${lead.business_name}: ${demoUrl}`);

    return {
      demo_url: demoUrl,
      demo_token: demoToken,
      reviews_processed: demos.length,
      first_ai_response: demos[0]?.ai_response || null,
      first_review: demos[0]?.review || null,
    };
  } catch (error) {
    console.error('Failed to generate demo for lead:', error.message);
    return null;
  }
}

// Helper: Scrape email from website (free fallback when Hunter.io fails)
async function scrapeEmailFromWebsite(websiteUrl) {
  try {
    // Normalize URL
    let url = websiteUrl;
    if (!url.startsWith('http')) {
      url = 'https://' + url;
    }

    // Pages to check for contact emails (expanded list)
    const pagesToCheck = [
      url,
      url.replace(/\/$/, '') + '/contact',
      url.replace(/\/$/, '') + '/contact-us',
      url.replace(/\/$/, '') + '/about',
      url.replace(/\/$/, '') + '/about-us',
      url.replace(/\/$/, '') + '/kontakt',
      url.replace(/\/$/, '') + '/impressum',
      url.replace(/\/$/, '') + '/team',
      url.replace(/\/$/, '') + '/footer', // Some sites have mailto in footer
      url.replace(/\/$/, '') + '/legal',
      url.replace(/\/$/, '') + '/privacy',
    ];

    // Email regex pattern
    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;

    // Blacklist common non-business emails and tracking domains
    const blacklist = [
      'example.com',
      'email.com',
      'domain.com',
      'yoursite.com',
      'website.com',
      'sentry.io',
      'wixpress.com',
      'squarespace.com',
      'mailchimp.com',
      'googleapis.com',
      'google.com',
      'facebook.com',
      'twitter.com',
      'w3.org',
      'schema.org',
      'gravatar.com',
      'wordpress.com',
    ];

    for (const pageUrl of pagesToCheck) {
      try {
        const response = await fetch(pageUrl, {
          headers: {
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            Accept: 'text/html,application/xhtml+xml',
          },
          timeout: 8000,
        });

        if (!response.ok) continue;

        const html = await response.text();

        // Look for mailto: links first (most reliable)
        const mailtoMatch = html.match(/mailto:([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/i);
        if (mailtoMatch) {
          const email = mailtoMatch[1].toLowerCase();
          if (!blacklist.some(b => email.includes(b))) {
            return email;
          }
        }

        // Then try regex on full page
        const emails = html.match(emailRegex) || [];

        // Filter and prioritize emails
        const validEmails = emails
          .map(e => e.toLowerCase())
          .filter(e => !blacklist.some(b => e.includes(b)))
          .filter(
            e =>
              !e.includes('png') &&
              !e.includes('jpg') &&
              !e.includes('gif') &&
              !e.includes('.js') &&
              !e.includes('.css')
          )
          .filter(e => e.length < 60); // Filter overly long "emails"

        // === SMART EMAIL PRIORISIERUNG ===
        // Tier 1: Personal Email Providers (Gmail, Outlook, iCloud = often Owner)
        const personalProviders = ['gmail.com', 'googlemail.com', 'outlook.com', 'hotmail.com', 'icloud.com', 'me.com', 'yahoo.com', 'gmx.de', 'gmx.net', 'web.de', 't-online.de'];

        // Tier 2: Owner/Manager Keywords
        const ownerKeywords = ['owner', 'chef', 'manager', 'inhaber', 'geschaeftsfuehrer', 'geschÃ¤ftsfÃ¼hrer', 'direktor', 'director', 'founder', 'gruender', 'grÃ¼nder', 'ceo', 'boss', 'patron'];

        // Tier 3: Generic Business Prefixes (lowest priority - goes to receptionist)
        const genericPrefixes = [
          'contact', 'info', 'hello', 'support', 'team', 'sales', 'mail', 'office',
          'reservations', 'booking', 'reservierung', 'service', 'anfrage', 'kontakt',
          'admin', 'help', 'general', 'enquiry', 'enquiries', 'reception', 'front',
          'post', 'email', 'webmaster', 'web', 'marketing', 'pr', 'press', 'media',
          'jobs', 'career', 'careers', 'hr', 'recruiting', 'billing', 'invoice', 'accounts',
          'noreply', 'no-reply', 'donotreply', 'newsletter', 'news', 'updates',
        ];

        // Business-type prefixes (NOT personal - often goes to shared inbox)
        const businessTypePrefixes = [
          'restaurant', 'cafe', 'hotel', 'bar', 'pub', 'bistro', 'kitchen', 'dining',
          'flowers', 'florist', 'bakery', 'shop', 'store', 'boutique', 'salon', 'spa',
          'apotheek', 'apotheke', 'pharmacy', 'clinic', 'praxis', 'dental', 'medical',
          'studio', 'gallery', 'atelier', 'design', 'photo', 'agency', 'consulting',
        ];

        // Common first names (to detect firstname@ pattern)
        const commonFirstNames = [
          'max', 'tom', 'tim', 'jan', 'ben', 'paul', 'mark', 'mike', 'john', 'james', 'david', 'daniel', 'michael', 'chris', 'christian', 'peter', 'stefan', 'thomas', 'andreas', 'martin', 'frank', 'matthias', 'alexander', 'sebastian', 'patrick', 'oliver', 'kevin', 'dennis', 'marcel', 'tobias', 'florian', 'dominik', 'pascal', 'felix', 'lukas', 'jonas', 'leon', 'nico', 'simon', 'julian',
          'anna', 'lisa', 'sarah', 'laura', 'julia', 'marie', 'sophie', 'lena', 'emma', 'mia', 'hannah', 'lea', 'nina', 'jana', 'katharina', 'maria', 'sandra', 'claudia', 'nicole', 'andrea', 'petra', 'sabine', 'monika', 'karin', 'christine', 'susanne', 'birgit', 'stefanie', 'melanie', 'nadine', 'jessica', 'jennifer', 'vanessa', 'christina', 'daniela', 'katrin', 'anja', 'carole', 'caroline', 'isabelle', 'charlotte', 'tyler', 'ashley', 'brittany', 'emily', 'jessica', 'amanda', 'samantha',
        ];

        // Helper: Check if email looks like a real person's email
        const isPersonalEmail = (email) => {
          const prefix = email.split('@')[0].toLowerCase();
          const domain = email.split('@')[1]?.toLowerCase() || '';

          // Personal provider = high chance of owner
          if (personalProviders.some(p => domain === p)) return true;

          // Contains owner keyword
          if (ownerKeywords.some(k => prefix.includes(k))) return true;

          // Starts with common first name (firstname@ or firstname.lastname@)
          if (commonFirstNames.some(name => prefix === name || prefix.startsWith(name + '.'))) return true;

          // Contains dot (likely firstname.lastname@)
          if (prefix.includes('.') && !genericPrefixes.some(g => prefix.startsWith(g))) return true;

          return false;
        };

        // Helper: Check if email is generic business email
        const isGenericEmail = (email) => {
          const prefix = email.split('@')[0].toLowerCase();
          return genericPrefixes.some(g => prefix === g || prefix.startsWith(g + '.')) ||
                 businessTypePrefixes.some(b => prefix === b || prefix.startsWith(b));
        };

        // Sort emails by priority
        const tier1 = validEmails.filter(e => isPersonalEmail(e));
        const tier2 = validEmails.filter(e => !isPersonalEmail(e) && !isGenericEmail(e));
        const tier3 = validEmails.filter(e => isGenericEmail(e));

        // Return best available
        if (tier1.length > 0) {
          console.log(`ðŸ“§ TIER 1 - Personal/Owner email: ${tier1[0]} (best quality)`);
          return tier1[0];
        }
        if (tier2.length > 0) {
          console.log(`ðŸ“§ TIER 2 - Business email: ${tier2[0]} (medium quality)`);
          return tier2[0];
        }
        if (tier3.length > 0) {
          console.log(`ðŸ“§ TIER 3 - Generic email: ${tier3[0]} (fallback)`);
          return tier3[0];
        }
        if (validEmails.length > 0) return validEmails[0];

        // Small delay between page requests
        await new Promise(r => setTimeout(r, 200));
      } catch (e) {
        // Page not found or error, try next
        continue;
      }
    }

    return null;
  } catch (e) {
    console.error('Website scrape error:', e.message);
    return null;
  }
}

// === IMPRESSUM SCRAPER (DE/AT/CH) ===
// German/Austrian/Swiss websites MUST have Impressum by law = reliable owner data
async function scrapeImpressum(websiteUrl) {
  try {
    let url = websiteUrl;
    if (!url.startsWith('http')) {
      url = 'https://' + url;
    }

    // Check if it's a DACH domain (Germany, Austria, Switzerland)
    const domain = url.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0].toLowerCase();

    // Impressum pages (German legal requirement)
    const impressumPages = [
      url.replace(/\/$/, '') + '/impressum',
      url.replace(/\/$/, '') + '/imprint',
      url.replace(/\/$/, '') + '/legal',
      url.replace(/\/$/, '') + '/legal-notice',
      url.replace(/\/$/, '') + '/rechtliches',
      url.replace(/\/$/, '') + '/kontakt',
      url.replace(/\/$/, '') + '/about',
      url.replace(/\/$/, '') + '/ueber-uns',
    ];

    // Patterns to find owner/manager names in Impressum
    const ownerPatterns = [
      // German patterns (most common)
      /GeschÃ¤ftsfÃ¼hrer(?:in)?[:\s]+([A-ZÃ„Ã–Ãœa-zÃ¤Ã¶Ã¼ÃŸ\-\s]+?)(?=<|,|\n|;|\(|Telefon|Tel|Fax|Email|E-Mail|USt|Steuer|HRB|Amtsgericht|$)/gi,
      /Inhaber(?:in)?[:\s]+([A-ZÃ„Ã–Ãœa-zÃ¤Ã¶Ã¼ÃŸ\-\s]+?)(?=<|,|\n|;|\(|Telefon|Tel|Fax|Email|E-Mail|USt|Steuer|$)/gi,
      /Vertretungsberechtigte?r?[:\s]+([A-ZÃ„Ã–Ãœa-zÃ¤Ã¶Ã¼ÃŸ\-\s]+?)(?=<|,|\n|;|\(|Telefon|Tel|Fax|Email|$)/gi,
      /Verantwortlich(?:er)?[:\s]+([A-ZÃ„Ã–Ãœa-zÃ¤Ã¶Ã¼ÃŸ\-\s]+?)(?=<|,|\n|;|\(|Telefon|Tel|Fax|Email|$)/gi,
      /Betreiber[:\s]+([A-ZÃ„Ã–Ãœa-zÃ¤Ã¶Ã¼ÃŸ\-\s]+?)(?=<|,|\n|;|\(|Telefon|Tel|Fax|Email|$)/gi,
      // English patterns
      /Owner[:\s]+([A-Za-z\-\s]+?)(?=<|,|\n|;|\(|Phone|Fax|Email|$)/gi,
      /Manager[:\s]+([A-Za-z\-\s]+?)(?=<|,|\n|;|\(|Phone|Fax|Email|$)/gi,
      /Director[:\s]+([A-Za-z\-\s]+?)(?=<|,|\n|;|\(|Phone|Fax|Email|$)/gi,
      /CEO[:\s]+([A-Za-z\-\s]+?)(?=<|,|\n|;|\(|Phone|Fax|Email|$)/gi,
      /Founder[:\s]+([A-Za-z\-\s]+?)(?=<|,|\n|;|\(|Phone|Fax|Email|$)/gi,
    ];

    for (const pageUrl of impressumPages) {
      try {
        const response = await fetch(pageUrl, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml',
            'Accept-Language': 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7',
          },
          timeout: 8000,
        });

        if (!response.ok) continue;

        const html = await response.text();
        // Strip HTML tags for easier text parsing
        const text = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');

        // Try to find owner name
        for (const pattern of ownerPatterns) {
          const match = pattern.exec(text);
          if (match && match[1]) {
            let ownerName = match[1].trim();

            // Clean up the name
            ownerName = ownerName
              .replace(/\s+/g, ' ')
              .replace(/^\s*Dr\.?\s*/i, '') // Remove Dr.
              .replace(/^\s*Prof\.?\s*/i, '') // Remove Prof.
              .replace(/\s*\(.*\)\s*$/, '') // Remove parentheses
              .trim();

            // Validate it looks like a real name (2+ words, 2+ chars each word, starts with capital)
            const nameParts = ownerName.split(/\s+/);
            if (nameParts.length >= 2 &&
                nameParts.every(part => part.length >= 2 && /^[A-ZÃ„Ã–Ãœ]/.test(part)) &&
                ownerName.length >= 5 && ownerName.length <= 50) {

              console.log(`ðŸ“‹ IMPRESSUM: Found owner "${ownerName}" on ${pageUrl}`);
              return {
                ownerName: ownerName,
                source: pageUrl,
                domain: domain
              };
            }
          }
          // Reset regex lastIndex for next iteration
          pattern.lastIndex = 0;
        }

        await new Promise(r => setTimeout(r, 200));
      } catch (e) {
        continue;
      }
    }

    return null;
  } catch (e) {
    console.error('Impressum scrape error:', e.message);
    return null;
  }
}

// === OWNER NAME â†’ EMAIL PATTERN GENERATOR ===
// Generate potential email addresses from owner name and validate
async function generateEmailsFromOwnerName(ownerName, domain) {
  if (!ownerName || !domain) return null;

  // Clean domain
  const cleanDomain = domain
    .replace(/^https?:\/\//, '')
    .replace(/^www\./, '')
    .split('/')[0]
    .toLowerCase();

  // Parse name
  const nameParts = ownerName.trim().split(/\s+/);
  if (nameParts.length < 2) return null;

  const firstName = nameParts[0].toLowerCase();
  const lastName = nameParts[nameParts.length - 1].toLowerCase();

  // Convert German umlauts for email
  const normalizeForEmail = (str) => {
    return str
      .replace(/Ã¤/g, 'ae')
      .replace(/Ã¶/g, 'oe')
      .replace(/Ã¼/g, 'ue')
      .replace(/ÃŸ/g, 'ss')
      .replace(/[^a-z0-9.-]/g, ''); // Remove any other special chars
  };

  const firstNorm = normalizeForEmail(firstName);
  const lastNorm = normalizeForEmail(lastName);
  const firstInitial = firstNorm.charAt(0);

  // Common email patterns (ordered by likelihood)
  const patterns = [
    `${firstNorm}@${cleanDomain}`,                    // max@restaurant.de
    `${firstNorm}.${lastNorm}@${cleanDomain}`,        // max.mustermann@restaurant.de
    `${firstNorm}${lastNorm}@${cleanDomain}`,         // maxmustermann@restaurant.de
    `${firstInitial}.${lastNorm}@${cleanDomain}`,     // m.mustermann@restaurant.de
    `${firstInitial}${lastNorm}@${cleanDomain}`,      // mmustermann@restaurant.de
    `${lastNorm}@${cleanDomain}`,                     // mustermann@restaurant.de
    `${firstNorm}-${lastNorm}@${cleanDomain}`,        // max-mustermann@restaurant.de
    `${lastNorm}.${firstNorm}@${cleanDomain}`,        // mustermann.max@restaurant.de
  ];

  // Check if domain has MX records (can receive email)
  try {
    const dns = await import('dns').then(m => m.promises);
    const mxRecords = await dns.resolveMx(cleanDomain);

    if (mxRecords && mxRecords.length > 0) {
      // Domain can receive email - return best guess patterns
      console.log(`ðŸ“§ Generated ${patterns.length} email patterns for ${ownerName} @ ${cleanDomain}`);
      return {
        ownerName: ownerName,
        domain: cleanDomain,
        primaryEmail: patterns[0], // firstname@domain is most common
        allPatterns: patterns,
        mxVerified: true
      };
    }
  } catch (e) {
    // MX lookup failed, but still return patterns
    console.log(`âš ï¸ MX lookup failed for ${cleanDomain}, returning patterns anyway`);
    return {
      ownerName: ownerName,
      domain: cleanDomain,
      primaryEmail: patterns[0],
      allPatterns: patterns,
      mxVerified: false
    };
  }

  return null;
}

// === ENHANCED EMAIL FINDING (Impressum + Pattern Generation) ===
// Combines Impressum scraping with owner email pattern generation
async function findEnhancedEmail(websiteUrl) {
  // First try regular scraping
  const scrapedEmail = await scrapeEmailFromWebsite(websiteUrl);

  // If we found a personal/owner email (not info@/contact@), use it
  if (scrapedEmail) {
    const prefix = scrapedEmail.split('@')[0].toLowerCase();
    const genericPrefixes = ['info', 'contact', 'hello', 'office', 'mail', 'team', 'support', 'service'];
    if (!genericPrefixes.some(g => prefix === g || prefix.startsWith(g + '.'))) {
      return { email: scrapedEmail, source: 'website_scrape', isPersonal: true };
    }
  }

  // For all domains, try Impressum scraping + pattern generation
  const impressum = await scrapeImpressum(websiteUrl);
  if (impressum && impressum.ownerName) {
    const emailPatterns = await generateEmailsFromOwnerName(impressum.ownerName, impressum.domain);
    if (emailPatterns && emailPatterns.primaryEmail) {
      return {
        email: emailPatterns.primaryEmail,
        ownerName: impressum.ownerName,
        allPatterns: emailPatterns.allPatterns,
        source: 'impressum_pattern',
        isPersonal: true,
        mxVerified: emailPatterns.mxVerified
      };
    }
  }

  // Fallback to scraped email (even if generic)
  if (scrapedEmail) {
    return { email: scrapedEmail, source: 'website_scrape', isPersonal: false };
  }

  return null;
}

// Helper: Guess common email patterns and verify they exist (FREE)
async function guessAndVerifyEmail(domain, businessName) {
  // Common email patterns for businesses
  const patterns = [
    'info',
    'contact',
    'hello',
    'mail',
    'office',
    'team',
    'reservations',
    'booking',
    'support',
  ];

  // Clean domain
  const cleanDomain = domain
    .replace(/^https?:\/\//, '')
    .replace(/^www\./, '')
    .split('/')[0]
    .toLowerCase();

  for (const pattern of patterns) {
    const testEmail = `${pattern}@${cleanDomain}`;

    try {
      // Use a simple DNS MX record check to verify domain accepts mail
      // We can't fully verify the email exists without sending, but MX check helps
      const dns = await import('dns').then(m => m.promises);
      const mxRecords = await dns.resolveMx(cleanDomain);

      if (mxRecords && mxRecords.length > 0) {
        // Domain has MX records, email is likely valid
        // Return the most common pattern for this type of business
        console.log(`âœ‰ï¸ Guessed email for ${businessName}: ${testEmail} (MX verified)`);
        return { email: testEmail, verified: true };
      }
    } catch (e) {
      // MX lookup failed, domain might not accept email
      continue;
    }
  }

  return null;
}

// === BUSINESS-TYPE SPECIFIC ROLE PRIORITIZATION ===
// Different businesses have different decision makers for review management
const ROLE_PRIORITY_BY_BUSINESS_TYPE = {
  // Restaurants/Hospitality: Owner makes decisions, chef has pride in reviews
  restaurant: ['owner', 'founder', 'inhaber', 'geschÃ¤ftsfÃ¼hrer', 'chef', 'manager', 'marketing', 'operations'],
  cafe: ['owner', 'founder', 'inhaber', 'manager', 'barista', 'marketing'],
  hotel: ['owner', 'general manager', 'manager', 'marketing', 'guest relations', 'operations'],
  bar: ['owner', 'founder', 'inhaber', 'manager', 'marketing'],

  // SaaS/Tech: Customer Success owns review responses
  saas: ['customer success', 'customer experience', 'marketing', 'founder', 'ceo', 'head of growth'],
  software: ['customer success', 'marketing', 'founder', 'ceo', 'product'],
  tech: ['customer success', 'marketing', 'founder', 'ceo'],

  // E-Commerce/Retail: Owner or Marketing handles reputation
  ecommerce: ['owner', 'founder', 'marketing', 'operations', 'customer service'],
  retail: ['owner', 'store manager', 'marketing', 'operations'],
  shop: ['owner', 'inhaber', 'manager', 'marketing'],

  // Healthcare/Professional Services: Practice owner or office manager
  dental: ['owner', 'dentist', 'practice manager', 'office manager'],
  medical: ['owner', 'doctor', 'practice manager', 'office manager'],
  clinic: ['owner', 'director', 'practice manager', 'office manager'],
  spa: ['owner', 'manager', 'marketing'],
  salon: ['owner', 'inhaber', 'manager', 'stylist'],

  // Default for unknown business types
  default: ['owner', 'founder', 'ceo', 'geschÃ¤ftsfÃ¼hrer', 'inhaber', 'manager', 'marketing', 'director'],
};

// Helper: Get role priority score for a business type
function getRolePriorityScore(role, businessType) {
  const normalizedType = (businessType || 'default').toLowerCase();
  const roleNormalized = (role || '').toLowerCase();

  // Find matching business type (partial match)
  let priorities = ROLE_PRIORITY_BY_BUSINESS_TYPE.default;
  for (const [type, roles] of Object.entries(ROLE_PRIORITY_BY_BUSINESS_TYPE)) {
    if (normalizedType.includes(type) || type.includes(normalizedType)) {
      priorities = roles;
      break;
    }
  }

  // Find role in priority list (lower index = higher priority)
  for (let i = 0; i < priorities.length; i++) {
    if (roleNormalized.includes(priorities[i]) || priorities[i].includes(roleNormalized)) {
      return priorities.length - i; // Higher score = higher priority
    }
  }

  return 0; // Unknown role = lowest priority
}

// Helper: Generate personal emails from team member names (FREE)
// Converts "Max MÃ¼ller" â†’ max@domain.com, max.mueller@domain.com, etc.
// Now with Business-Type specific role prioritization
async function generatePersonalEmails(domain, teamMembers, businessType = null) {
  if (!teamMembers || teamMembers.length === 0) return null;

  // Clean domain
  const cleanDomain = domain
    .replace(/^https?:\/\//, '')
    .replace(/^www\./, '')
    .split('/')[0]
    .toLowerCase();

  // Helper: Convert German umlauts to ASCII
  const normalizeUmlauts = str =>
    str
      .toLowerCase()
      .replace(/Ã¤/g, 'ae')
      .replace(/Ã¶/g, 'oe')
      .replace(/Ã¼/g, 'ue')
      .replace(/ÃŸ/g, 'ss')
      .replace(/[^a-z]/g, ''); // Remove any other special chars

  // Helper: Generate email patterns from a name
  const generatePatterns = fullName => {
    const parts = fullName.trim().split(/\s+/);
    if (parts.length < 1) return [];

    const firstName = normalizeUmlauts(parts[0]);
    const lastName = parts.length > 1 ? normalizeUmlauts(parts[parts.length - 1]) : '';

    const patterns = [];
    if (firstName) {
      patterns.push(`${firstName}@${cleanDomain}`); // max@domain.com
    }
    if (firstName && lastName) {
      patterns.push(`${firstName}.${lastName}@${cleanDomain}`); // max.mueller@domain.com
      patterns.push(`${firstName[0]}.${lastName}@${cleanDomain}`); // m.mueller@domain.com
      patterns.push(`${firstName}${lastName}@${cleanDomain}`); // maxmueller@domain.com
      patterns.push(`${firstName[0]}${lastName}@${cleanDomain}`); // mmueller@domain.com
      patterns.push(`${lastName}@${cleanDomain}`); // mueller@domain.com
    }
    return patterns;
  };

  // Check if domain has MX records (can receive email)
  let hasMxRecords = false;
  try {
    const dns = await import('dns').then(m => m.promises);
    const mxRecords = await dns.resolveMx(cleanDomain);
    hasMxRecords = mxRecords && mxRecords.length > 0;
  } catch {
    // MX lookup failed, domain might not accept email
    return null;
  }

  if (!hasMxRecords) return null;

  // Sort team members by role priority for this business type
  const sortedMembers = [...teamMembers].sort((a, b) => {
    const scoreA = getRolePriorityScore(a.role, businessType);
    const scoreB = getRolePriorityScore(b.role, businessType);
    return scoreB - scoreA; // Higher score first
  });

  if (businessType) {
    console.log(
      `ðŸ“Š Business-type prioritization (${businessType}):`,
      sortedMembers.slice(0, 3).map(m => `${m.name} (${m.role})`)
    );
  }

  // Generate emails for team members (now sorted by business-type priority)
  for (const member of sortedMembers.slice(0, 3)) {
    // Max 3 members
    const patterns = generatePatterns(member.name);

    if (patterns.length > 0) {
      // Return the first pattern (firstname@domain is most common)
      const email = patterns[0];
      console.log(
        `ðŸ‘¤ Generated personal email for ${member.name} (${member.role}): ${email} (MX verified)`
      );
      return {
        email,
        source: 'personal_generated',
        contactName: member.name,
        role: member.role,
      };
    }
  }

  return null;
}

// Helper: Find email using Snov.io API (50 free credits/month)
async function findEmailWithSnov(domain) {
  if (!process.env.SNOV_CLIENT_ID || !process.env.SNOV_CLIENT_SECRET) {
    return null;
  }

  try {
    // Step 1: Get access token
    const tokenResponse = await fetch('https://api.snov.io/v1/oauth/access_token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'client_credentials',
        client_id: process.env.SNOV_CLIENT_ID,
        client_secret: process.env.SNOV_CLIENT_SECRET,
      }),
    });

    const tokenData = await tokenResponse.json();
    if (!tokenData.access_token) {
      console.log('Snov.io token error:', tokenData);
      return null;
    }

    // Step 2: Domain search
    const searchResponse = await fetch('https://api.snov.io/v2/domain-emails-count', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${tokenData.access_token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ domain }),
    });

    const searchData = await searchResponse.json();

    if (searchData.data?.emails && searchData.data.emails.length > 0) {
      // Return first verified email
      const verifiedEmail =
        searchData.data.emails.find(e => e.status === 'valid') || searchData.data.emails[0];
      console.log(`ðŸ“§ Snov.io found email for ${domain}: ${verifiedEmail.email}`);
      return verifiedEmail.email;
    }

    return null;
  } catch (e) {
    console.error('Snov.io error:', e.message);
    return null;
  }
}

// Helper: Find email using Apollo.io API (95 free credits/month)
async function findEmailWithApollo(domain, companyName) {
  if (!process.env.APOLLO_API_KEY) {
    return null;
  }

  try {
    // Apollo's Organization Enrich API can find contacts by domain
    const response = await fetch('https://api.apollo.io/api/v1/organizations/enrich', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Api-Key': process.env.APOLLO_API_KEY,
      },
      body: JSON.stringify({
        domain: domain,
      }),
    });

    const data = await response.json();

    if (data.organization?.estimated_num_employees > 0) {
      // Try to find people at this organization
      const peopleResponse = await fetch('https://api.apollo.io/api/v1/mixed_people/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Api-Key': process.env.APOLLO_API_KEY,
        },
        body: JSON.stringify({
          organization_ids: [data.organization.id],
          person_titles: ['Owner', 'Manager', 'Director', 'CEO', 'Founder', 'General Manager'],
          page: 1,
          per_page: 5,
        }),
      });

      const peopleData = await peopleResponse.json();

      if (peopleData.people && peopleData.people.length > 0) {
        // Find first person with email
        const personWithEmail = peopleData.people.find(p => p.email);
        if (personWithEmail) {
          console.log(`ðŸš€ Apollo found: ${personWithEmail.email} (${personWithEmail.name})`);
          return {
            email: personWithEmail.email,
            contactName: personWithEmail.name,
            title: personWithEmail.title,
          };
        }
      }
    }

    return null;
  } catch (e) {
    console.error('Apollo.io error:', e.message);
    return null;
  }
}

// ============== AUTO BUSINESS CONTEXT FOR DEMOS ==============
// Scrape website + analyze reviews to generate high-quality demo responses

// Helper: Scrape business context from website About/Contact pages
async function scrapeBusinessContext(websiteUrl) {
  const result = {
    description: null,
    specialties: [],
    ownerName: null,
    foundedYear: null,
    usps: [],
    teamMembers: [], // Array of { name, role } for personal email generation
    phoneNumbers: [], // Phone numbers found on website
    linkedInUrls: [], // LinkedIn profile URLs for team members
    whatsappNumber: null, // WhatsApp Business number if found
  };

  if (!websiteUrl) return result;

  try {
    // Normalize URL
    let baseUrl = websiteUrl;
    if (!baseUrl.startsWith('http')) {
      baseUrl = 'https://' + baseUrl;
    }
    baseUrl = baseUrl.replace(/\/$/, '');

    // Pages to check for business info
    const pagesToCheck = [
      baseUrl + '/about',
      baseUrl + '/about-us',
      baseUrl + '/ueber-uns',
      baseUrl + '/team',
      baseUrl + '/our-story',
      baseUrl, // Homepage as fallback
    ];

    for (const pageUrl of pagesToCheck) {
      try {
        const response = await fetch(pageUrl, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            Accept: 'text/html,application/xhtml+xml',
          },
          timeout: 8000,
        });

        if (!response.ok) continue;

        const html = await response.text();

        // Extract meta description as fallback
        if (!result.description) {
          const metaMatch = html.match(
            /<meta\s+name=["']description["']\s+content=["']([^"']{20,300})["']/i
          );
          if (metaMatch) {
            result.description = metaMatch[1].trim();
          }
        }

        // Look for "About" section content
        // Common patterns: <p> after "About Us", <div class="about">, etc.
        const aboutPatterns = [
          /<(?:div|section)[^>]*class=["'][^"']*about[^"']*["'][^>]*>([\s\S]{50,500}?)<\/(?:div|section)>/i,
          /<p[^>]*>((?:We are|Our (?:restaurant|hotel|practice|company)|Since \d{4}|Founded in)[^<]{30,400})<\/p>/i,
          /(?:About Us|Our Story|Who We Are)<\/(?:h\d|strong)[^>]*>[\s\S]*?<p[^>]*>([^<]{50,400})<\/p>/i,
        ];

        for (const pattern of aboutPatterns) {
          const match = html.match(pattern);
          if (match && match[1]) {
            // Clean HTML tags and excess whitespace
            const cleanText = match[1]
              .replace(/<[^>]+>/g, ' ')
              .replace(/\s+/g, ' ')
              .trim()
              .slice(0, 500);
            if (cleanText.length > 50 && !result.description) {
              result.description = cleanText;
            }
          }
        }

        // Look for founded year
        const yearMatch = html.match(/(?:founded|established|since|seit)\s*(?:in\s*)?(\d{4})/i);
        if (yearMatch) {
          result.foundedYear = yearMatch[1];
        }

        // Blacklist: Words that look like names but aren't (single-word matches)
        // MOVED UP: Now used for both ownerPatterns AND teamMembers
        const nameBlacklist = [
          'manager',
          'director',
          'owner',
          'founder',
          'chef',
          'team',
          'about',
          'lead',
          'agent',
          'design',
          'marketing',
          'operations',
          'customer',
          'integration',
          'president',
          'executive',
          'officer',
          'head',
          'specialist',
          'coordinator',
          'the',
          'and',
          'for',
          'with',
          'from',
          'into',
          'what',
          'how',
          'our',
          'your',
          'across',
          'between',
          'through',
          'within',
          'directly',
          'immediately',
        ];

        // Helper: Validate if a string is likely a real person name
        const isValidPersonName = name => {
          if (!name) return false;
          const words = name.trim().split(/\s+/);
          // Must have at least 2 words (first + last name)
          if (words.length < 2) return false;
          // First word must start with capital letter
          if (!/^[A-ZÃ„Ã–Ãœ]/.test(words[0])) return false;
          // No blacklisted words
          if (words.some(w => nameBlacklist.includes(w.toLowerCase()))) return false;
          // No all-lowercase words (except common German particles like "von", "de")
          const allowedLower = ['von', 'van', 'de', 'la', 'le', 'du', 'der', 'den'];
          if (words.some(w => /^[a-z]+$/.test(w) && !allowedLower.includes(w))) return false;
          // Reasonable length per word
          if (words.some(w => w.length < 2 || w.length > 20)) return false;
          return true;
        };

        // Look for owner/chef/founder name (STRICTER: requires first + last name + validation)
        const ownerPatterns = [
          /(?:owner|founder|chef|inhaber|geschÃ¤ftsfÃ¼hrer)[:\s]+([A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+)/i,
          /([A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+),?\s+(?:owner|founder|chef|inhaber)/i,
        ];
        for (const pattern of ownerPatterns) {
          const ownerMatch = html.match(pattern);
          if (ownerMatch && ownerMatch[1]) {
            const potentialName = ownerMatch[1].trim();
            // Use isValidPersonName for proper validation (includes blacklist check)
            if (isValidPersonName(potentialName) && potentialName.length < 40) {
              result.ownerName = potentialName;
              break;
            }
          }
        }

        // NEU: Extract team members with roles for personal email generation
        // Priority roles for review management (in order of importance)
        const priorityRoles = [
          'owner',
          'founder',
          'ceo',
          'geschÃ¤ftsfÃ¼hrer',
          'inhaber',
          'chef',
          'marketing',
          'customer success',
          'customer experience',
          'customer service',
          'manager',
          'general manager',
          'operations',
          'director',
        ];

        // Pattern 1: "Role: Name" or "Name, Role" format - STRICTER
        // Only match patterns like "Owner: Max MÃ¼ller" or "Max MÃ¼ller, Owner"
        const roleNamePatterns = [
          /(?:owner|founder|ceo|geschÃ¤ftsfÃ¼hrer|inhaber|chef)[:\s]+([A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+(?:\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+)?)/gi,
          /([A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+(?:\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+)?),?\s*[-â€“â€”]\s*(?:owner|founder|ceo|geschÃ¤ftsfÃ¼hrer|inhaber|chef)/gi,
        ];

        for (const pattern of roleNamePatterns) {
          let match;
          pattern.lastIndex = 0;
          while ((match = pattern.exec(html)) !== null) {
            const name = match[1]?.trim();
            if (isValidPersonName(name) && !name.includes('<')) {
              // Extract role from match context
              const context = match[0].toLowerCase();
              let role = 'unknown';
              for (const r of priorityRoles) {
                if (context.includes(r)) {
                  role = r;
                  break;
                }
              }
              // Avoid duplicates
              if (!result.teamMembers.some(m => m.name === name)) {
                result.teamMembers.push({ name, role });
              }
            }
          }
        }

        // Pattern 2: Team member cards (common HTML structure)
        // <div class="team-member"><h3>Max MÃ¼ller</h3><p>Owner</p></div>
        const teamCardPattern =
          /<(?:div|article)[^>]*class=["'][^"']*(?:team|staff|member|employee)[^"']*["'][^>]*>[\s\S]*?<(?:h[2-4]|strong|span)[^>]*>([A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+(?:\s+[A-Z][a-zÃ¤Ã¶Ã¼ÃŸ]+){1,2})<\/(?:h[2-4]|strong|span)>[\s\S]*?<(?:p|span|div)[^>]*>([^<]{3,50})<\/(?:p|span|div)>/gi;
        let cardMatch;
        while ((cardMatch = teamCardPattern.exec(html)) !== null) {
          const name = cardMatch[1]?.trim();
          const roleText = cardMatch[2]?.trim().toLowerCase();
          if (isValidPersonName(name) && roleText && !name.includes('<')) {
            let role = 'unknown';
            for (const r of priorityRoles) {
              if (roleText.includes(r)) {
                role = r;
                break;
              }
            }
            if (!result.teamMembers.some(m => m.name === name)) {
              result.teamMembers.push({ name, role });
            }
          }
        }

        // Pattern 3: JSON-LD structured data (most reliable)
        const jsonLdMatch = html.match(
          /<script[^>]*type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi
        );
        if (jsonLdMatch) {
          for (const ldScript of jsonLdMatch) {
            try {
              const jsonContent = ldScript.replace(/<\/?script[^>]*>/gi, '');
              const data = JSON.parse(jsonContent);
              // Look for Person or Employee types
              const persons = Array.isArray(data) ? data : [data];
              for (const item of persons) {
                if (item['@type'] === 'Person' && item.name) {
                  const role = item.jobTitle?.toLowerCase() || 'unknown';
                  if (!result.teamMembers.some(m => m.name === item.name)) {
                    result.teamMembers.push({ name: item.name, role });
                  }
                }
                // Check for employee array
                if (item.employee && Array.isArray(item.employee)) {
                  for (const emp of item.employee) {
                    if (emp.name) {
                      const role = emp.jobTitle?.toLowerCase() || 'unknown';
                      if (!result.teamMembers.some(m => m.name === emp.name)) {
                        result.teamMembers.push({ name: emp.name, role });
                      }
                    }
                  }
                }
              }
            } catch {
              // Invalid JSON, skip
            }
          }
        }

        // If we found ownerName but no team members, add owner
        if (result.ownerName && result.teamMembers.length === 0) {
          result.teamMembers.push({ name: result.ownerName, role: 'owner' });
        }

        // Sort team members by role priority
        result.teamMembers.sort((a, b) => {
          const aIdx = priorityRoles.findIndex(r => a.role.includes(r));
          const bIdx = priorityRoles.findIndex(r => b.role.includes(r));
          return (aIdx === -1 ? 999 : aIdx) - (bIdx === -1 ? 999 : bIdx);
        });

        // Look for specialties/services lists
        const listMatches = html.match(/<li[^>]*>([^<]{5,60})<\/li>/gi);
        if (listMatches && listMatches.length >= 3) {
          const items = listMatches
            .slice(0, 10)
            .map(m => m.replace(/<[^>]+>/g, '').trim())
            .filter(item => item.length > 3 && item.length < 50)
            .filter(
              item =>
                !item.toLowerCase().includes('privacy') && !item.toLowerCase().includes('cookie')
            );
          if (items.length >= 3) {
            result.specialties = items.slice(0, 5);
          }
        }

        // === PHONE NUMBER EXTRACTION ===
        // Patterns for international phone numbers
        const phonePatterns = [
          // German: +49 30 12345678, 030-12345678, (030) 12345678
          /(?:\+49|0049|0)\s*[1-9]\d{1,4}[\s/-]?\d{3,}[\s/-]?\d{0,}/g,
          // International: +1 234 567 8901, +44 20 1234 5678
          /\+[1-9]\d{0,3}[\s.-]?\(?\d{1,4}\)?[\s.-]?\d{1,4}[\s.-]?\d{1,9}/g,
          // Generic: (123) 456-7890, 123-456-7890
          /\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}/g,
        ];
        for (const pattern of phonePatterns) {
          const matches = html.match(pattern) || [];
          for (const match of matches) {
            const cleaned = match.replace(/[\s.-]/g, '').replace(/^\+?0+/, '+');
            // Validate: 8-15 digits after normalization
            const digitsOnly = cleaned.replace(/\D/g, '');
            if (digitsOnly.length >= 8 && digitsOnly.length <= 15) {
              if (!result.phoneNumbers.includes(cleaned) && result.phoneNumbers.length < 3) {
                result.phoneNumbers.push(cleaned);
              }
            }
          }
        }

        // === WHATSAPP BUSINESS NUMBER ===
        // Pattern: wa.me/49123456789 or api.whatsapp.com/send?phone=49123456789
        const whatsappMatch = html.match(/(?:wa\.me\/|whatsapp\.com\/send\?phone=)(\d{10,15})/i);
        if (whatsappMatch && !result.whatsappNumber) {
          result.whatsappNumber = '+' + whatsappMatch[1];
        }

        // === LINKEDIN PROFILE EXTRACTION ===
        // Pattern: linkedin.com/in/username or linkedin.com/company/name
        const linkedInMatches = html.match(
          /https?:\/\/(?:www\.)?linkedin\.com\/(?:in|company)\/[a-zA-Z0-9_-]+/gi
        );
        if (linkedInMatches) {
          for (const url of linkedInMatches) {
            const normalized = url.toLowerCase().replace(/\/$/, '');
            if (!result.linkedInUrls.includes(normalized) && result.linkedInUrls.length < 5) {
              result.linkedInUrls.push(normalized);
            }
          }
        }

        // If we found good content, stop searching
        if (result.description && result.description.length > 100) {
          break;
        }

        await new Promise(r => setTimeout(r, 200));
      } catch {
        continue;
      }
    }
  } catch (e) {
    console.error('Business context scrape error:', e.message);
  }

  return result;
}

// Helper: Extract frequently mentioned items/services from positive reviews
function extractMentionedItems(reviews) {
  if (!reviews || reviews.length === 0) return [];

  // Common patterns that indicate a mentioned item
  const patterns = [
    /the ([a-z]+(?: [a-z]+)?) (?:was|is|were) (?:amazing|excellent|great|delicious|perfect|fantastic)/gi,
    /loved(?: the)? ([a-z]+(?: [a-z]+)?)/gi,
    /(?:best|amazing|excellent|great) ([a-z]+(?: [a-z]+)?)/gi,
    /try(?: the)? ([a-z]+(?: [a-z]+)?)/gi,
    /recommend(?: the)? ([a-z]+(?: [a-z]+)?)/gi,
  ];

  const mentions = {};

  for (const review of reviews) {
    if (!review.text) continue;
    const text = review.text.toLowerCase();

    for (const pattern of patterns) {
      let match;
      // Reset regex lastIndex for each review
      pattern.lastIndex = 0;
      while ((match = pattern.exec(text)) !== null) {
        const item = match[1]?.trim();
        // Filter out generic words
        const genericWords = [
          'food',
          'service',
          'staff',
          'place',
          'restaurant',
          'hotel',
          'experience',
          'it',
          'they',
          'them',
          'this',
          'that',
          'everything',
          'all',
          'we',
          'i',
        ];
        if (item && item.length > 2 && item.length < 30 && !genericWords.includes(item)) {
          mentions[item] = (mentions[item] || 0) + 1;
        }
      }
    }
  }

  // Return items mentioned 2+ times, sorted by frequency
  return Object.entries(mentions)
    .filter(([, count]) => count >= 2)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([item]) => item);
}

// Helper: Generate custom instructions from lead data
function generateAutoInstructions(lead, scrapedContext) {
  const instructions = [];

  // 1. Owner Name for sign-off
  const ownerName = scrapedContext.ownerName || lead.contact_name;
  if (ownerName) {
    instructions.push(`Sign responses as "${ownerName}" instead of the business name`);
  }

  // 2. Business Specialties (from website or reviews)
  if (scrapedContext.specialties?.length > 0) {
    instructions.push(
      `When relevant, mention these specialties: ${scrapedContext.specialties.slice(0, 3).join(', ')}`
    );
  }

  // 3. Founded Year (adds authenticity)
  if (scrapedContext.foundedYear) {
    const yearsInBusiness = new Date().getFullYear() - parseInt(scrapedContext.foundedYear);
    if (yearsInBusiness > 5) {
      instructions.push(`We've been serving customers for ${yearsInBusiness}+ years`);
    }
  }

  // 4. Pain Points (G2/Competitor leads) - avoid these topics
  if (lead.pain_points?.length > 0) {
    instructions.push(`Avoid mentioning: ${lead.pain_points.join(', ')}`);
  }

  // 5. Regional touch for certain cities
  const localCities = ['Munich', 'MÃ¼nchen', 'Berlin', 'Vienna', 'Wien', 'Zurich', 'ZÃ¼rich'];
  if (lead.city && localCities.some(c => lead.city.toLowerCase().includes(c.toLowerCase()))) {
    instructions.push(`Add subtle local ${lead.city} flair when natural`);
  }

  return instructions.length > 0 ? instructions.join('\n') : null;
}

// Helper: Generate business context from scraped data and reviews
function generateAutoContext(lead, scrapedContext, reviews) {
  const contextParts = [];

  // 1. Business Description from website
  if (scrapedContext.description) {
    contextParts.push(`About: ${scrapedContext.description.slice(0, 300)}`);
  }

  // 2. Popular items from positive reviews
  const positiveReviews = reviews?.filter(r => r.rating >= 4) || [];
  const mentionedItems = extractMentionedItems(positiveReviews);
  if (mentionedItems.length > 0) {
    contextParts.push(`Popular with customers: ${mentionedItems.join(', ')}`);
  }

  // 3. Owner/Team info
  if (scrapedContext.ownerName) {
    contextParts.push(`Owner: ${scrapedContext.ownerName}`);
  }

  // 4. Unique Selling Points from website
  if (scrapedContext.usps?.length > 0) {
    contextParts.push(`What makes us special: ${scrapedContext.usps.join(', ')}`);
  }

  // 5. Specialties from website
  if (scrapedContext.specialties?.length > 0 && contextParts.length < 3) {
    contextParts.push(`Our specialties: ${scrapedContext.specialties.join(', ')}`);
  }

  return contextParts.length > 0 ? contextParts.join('\n') : null;
}

// Helper: Combined email finder with multiple fallbacks
async function findEmailForLead(lead) {
  const domain = lead.website
    ?.replace(/^https?:\/\//, '')
    ?.replace(/^www\./, '')
    ?.split('/')[0];

  if (!domain) return null;

  let emailFound = null;
  let source = null;

  // 0. NEU: Team-Seiten scrapen fÃ¼r Personal Emails (HIGHEST PRIORITY)
  // Personal emails (max@domain.com) are much more effective than generic (info@)
  if (lead.website) {
    try {
      const businessContext = await scrapeBusinessContext(lead.website);
      if (businessContext.teamMembers && businessContext.teamMembers.length > 0) {
        console.log(
          `ðŸ‘¥ Found ${businessContext.teamMembers.length} team members:`,
          businessContext.teamMembers.slice(0, 3)
        );

        const personalResult = await generatePersonalEmails(
          lead.website,
          businessContext.teamMembers,
          lead.business_type // Business-type specific role prioritization
        );
        if (personalResult?.email) {
          // Update lead with contact info
          if (personalResult.contactName) {
            lead.contact_name = personalResult.contactName;
          }
          console.log(
            `âœ… Personal email generated: ${personalResult.email} for ${personalResult.contactName} (${personalResult.role})`
          );
          return {
            email: personalResult.email,
            source: 'personal_generated',
            contactName: personalResult.contactName,
          };
        }
      }
    } catch (e) {
      console.log('Team member extraction failed:', e.message);
    }
  }

  // 1. Enhanced email finder: Website + Impressum (DE/AT/CH) + Owner patterns
  if (lead.website) {
    try {
      const enhanced = await findEnhancedEmail(lead.website);
      if (enhanced?.email) {
        source = enhanced.source || 'website_scraper';
        console.log(
          `ðŸŒ Enhanced finder: ${enhanced.email} (source: ${source}, personal: ${enhanced.isPersonal})`
        );
        // If we found owner name via Impressum, update lead
        if (enhanced.ownerName) {
          lead.contact_name = enhanced.ownerName;
          console.log(`ðŸ“‹ Owner from Impressum: ${enhanced.ownerName}`);
        }
        return { email: enhanced.email, source, ownerName: enhanced.ownerName };
      }
    } catch (e) {
      console.log('Enhanced email finder failed:', e.message);
    }
  }

  // 2. Email pattern guesser with MX verification (FREE)
  try {
    const guessed = await guessAndVerifyEmail(domain, lead.business_name);
    if (guessed?.email) {
      emailFound = guessed.email;
      source = 'pattern_guess';
      console.log(`ðŸŽ¯ Pattern guess found: ${emailFound}`);
      return { email: emailFound, source };
    }
  } catch (e) {}

  // 3. Snov.io (50 free/month)
  try {
    emailFound = await findEmailWithSnov(domain);
    if (emailFound) {
      source = 'snov.io';
      return { email: emailFound, source };
    }
  } catch (e) {}

  // 3.5 Apollo.io (95 free credits/month) - finds decision makers
  try {
    const apolloResult = await findEmailWithApollo(domain, lead.business_name);
    if (apolloResult?.email) {
      if (apolloResult.contactName) {
        lead.contact_name = apolloResult.contactName;
      }
      return {
        email: apolloResult.email,
        source: 'apollo.io',
        contactName: apolloResult.contactName,
      };
    }
  } catch (e) {}

  // 4. Hunter.io (25 free/week) - last resort
  if (process.env.HUNTER_API_KEY) {
    try {
      const hunterUrl = `https://api.hunter.io/v2/domain-search?domain=${domain}&api_key=${process.env.HUNTER_API_KEY}`;
      const response = await fetch(hunterUrl);
      const data = await response.json();

      if (data.data?.emails && data.data.emails.length > 0) {
        let bestEmail = data.data.emails[0];

        // Try to match job title for G2 leads
        if (lead.lead_type === 'g2_competitor' && lead.contact_name) {
          const titleKeywords = lead.contact_name.toLowerCase().split(/\s+/);
          const matchingEmail = data.data.emails.find(e => {
            const position = (e.position || '').toLowerCase();
            const dept = (e.department || '').toLowerCase();
            return titleKeywords.some(kw => position.includes(kw) || dept.includes(kw));
          });
          if (matchingEmail) bestEmail = matchingEmail;
        }

        emailFound = bestEmail.value;
        source = 'hunter.io';

        // Save contact name if available
        if (bestEmail.first_name && bestEmail.last_name) {
          lead.contact_name = `${bestEmail.first_name} ${bestEmail.last_name}`;
        }

        console.log(`ðŸ” Hunter.io found: ${emailFound}`);
        return { email: emailFound, source, contactName: lead.contact_name };
      }
    } catch (e) {}
  }

  return null;
}

// Helper: Check if existing email is "low quality" and should be upgraded
function isLowQualityEmail(email) {
  if (!email) return true;

  const prefix = email.split('@')[0].toLowerCase();
  const domain = email.split('@')[1]?.toLowerCase() || '';

  // Generic prefixes = low quality (goes to receptionist, not decision maker)
  const genericPrefixes = [
    'contact', 'info', 'hello', 'support', 'team', 'sales', 'mail', 'office',
    'reservations', 'booking', 'reservierung', 'service', 'anfrage', 'kontakt',
    'admin', 'help', 'general', 'enquiry', 'enquiries', 'reception', 'front',
    'post', 'email', 'webmaster', 'web', 'marketing', 'pr', 'press', 'media',
  ];

  // Business-type prefixes = low quality (shared inbox)
  const businessTypePrefixes = [
    'restaurant', 'cafe', 'hotel', 'bar', 'pub', 'bistro', 'kitchen', 'dining',
    'flowers', 'florist', 'bakery', 'shop', 'store', 'boutique', 'salon', 'spa',
    'apotheek', 'apotheke', 'pharmacy', 'clinic', 'praxis', 'dental', 'medical',
  ];

  // Check if it's generic
  if (genericPrefixes.some(g => prefix === g || prefix.startsWith(g + '.'))) {
    return true;
  }

  // Check if it's business-type
  if (businessTypePrefixes.some(b => prefix === b || prefix.startsWith(b))) {
    return true;
  }

  return false;
}

// Helper: Check if new email is better than existing
function isEmailUpgrade(existingEmail, newEmail) {
  if (!existingEmail) return true;
  if (!newEmail) return false;

  const existingIsLow = isLowQualityEmail(existingEmail);
  const newIsLow = isLowQualityEmail(newEmail);

  // New is high quality, existing is low = upgrade
  if (existingIsLow && !newIsLow) return true;

  // Both same quality = no upgrade needed
  return false;
}

// === BOUNCE PREDICTION ===
// Detect suspicious emails BEFORE sending to reduce bounce rate
function isSuspiciousEmail(email, websiteDomain = null) {
  if (!email) return { suspicious: true, reason: 'no_email' };

  const prefix = email.split('@')[0].toLowerCase();
  const emailDomain = email.split('@')[1]?.toLowerCase() || '';

  // 1. Common typos in popular domains
  const domainTypos = {
    'gmial.com': 'gmail.com',
    'gmai.com': 'gmail.com',
    'gmail.co': 'gmail.com',
    'gamil.com': 'gmail.com',
    'gnail.com': 'gmail.com',
    'gmaill.com': 'gmail.com',
    'yahooo.com': 'yahoo.com',
    'yaho.com': 'yahoo.com',
    'hotmal.com': 'hotmail.com',
    'hotmai.com': 'hotmail.com',
    'outloo.com': 'outlook.com',
    'outlok.com': 'outlook.com',
  };
  if (domainTypos[emailDomain]) {
    return { suspicious: true, reason: 'domain_typo', suggested: email.replace(emailDomain, domainTypos[emailDomain]) };
  }

  // 2. Disposable/temporary email domains
  const disposableDomains = [
    'tempmail.com', 'temp-mail.org', 'guerrillamail.com', 'mailinator.com',
    '10minutemail.com', 'throwaway.email', 'fakeinbox.com', 'trashmail.com',
    'yopmail.com', 'tempail.com', 'getnada.com', 'maildrop.cc', 'mailnesia.com',
    'sharklasers.com', 'guerrillamail.info', 'grr.la', 'spam4.me', 'dispostable.com',
  ];
  if (disposableDomains.includes(emailDomain)) {
    return { suspicious: true, reason: 'disposable_domain' };
  }

  // 3. Free TLD domains (often spam/fake)
  const freeTLDs = ['.tk', '.ml', '.ga', '.cf', '.gq'];
  if (freeTLDs.some(tld => emailDomain.endsWith(tld))) {
    return { suspicious: true, reason: 'free_tld' };
  }

  // 4. Email domain doesn't match website domain (and not a known provider)
  const knownProviders = [
    'gmail.com', 'googlemail.com', 'outlook.com', 'hotmail.com', 'yahoo.com',
    'icloud.com', 'me.com', 'gmx.de', 'gmx.net', 'web.de', 't-online.de',
    'aol.com', 'protonmail.com', 'zoho.com', 'mail.com',
  ];
  if (websiteDomain && emailDomain !== websiteDomain && !knownProviders.includes(emailDomain)) {
    // Different domain but not a known provider - could be suspicious
    // But don't flag if email domain is a subdomain or parent of website domain
    const isRelated = emailDomain.includes(websiteDomain) || websiteDomain.includes(emailDomain);
    if (!isRelated) {
      return { suspicious: true, reason: 'domain_mismatch', websiteDomain, emailDomain };
    }
  }

  // 5. Suspicious prefix patterns
  const suspiciousPrefixes = [
    'test', 'demo', 'fake', 'spam', 'asdf', 'qwerty', 'xxxxx',
    'noreply', 'no-reply', 'donotreply', 'bounce', 'mailer-daemon',
  ];
  if (suspiciousPrefixes.some(p => prefix === p || prefix.startsWith(p + '.'))) {
    return { suspicious: true, reason: 'suspicious_prefix' };
  }

  // 6. Too short or too long prefix
  if (prefix.length < 2) {
    return { suspicious: true, reason: 'prefix_too_short' };
  }
  if (prefix.length > 64) {
    return { suspicious: true, reason: 'prefix_too_long' };
  }

  // 7. Only numbers in prefix (often auto-generated)
  if (/^\d+$/.test(prefix)) {
    return { suspicious: true, reason: 'numeric_prefix' };
  }

  // Email looks valid
  return { suspicious: false };
}

// === DOMAIN REPUTATION CHECK ===
// Check if domain is trustworthy before sending
async function checkDomainReputation(domain) {
  if (!domain) return { valid: false, reason: 'no_domain' };

  try {
    const dns = await import('dns').then(m => m.promises);

    // 1. Check MX records (can receive email)
    let hasMX = false;
    try {
      const mxRecords = await dns.resolveMx(domain);
      hasMX = mxRecords && mxRecords.length > 0;
    } catch (e) {
      // No MX records = can't receive email
    }

    if (!hasMX) {
      return { valid: false, reason: 'no_mx_records' };
    }

    // 2. Check if domain resolves at all
    let hasA = false;
    try {
      const aRecords = await dns.resolve4(domain);
      hasA = aRecords && aRecords.length > 0;
    } catch (e) {
      // Try AAAA records (IPv6)
      try {
        const aaaaRecords = await dns.resolve6(domain);
        hasA = aaaaRecords && aaaaRecords.length > 0;
      } catch (e2) {}
    }

    // Domain is valid and can receive email
    return { valid: true, hasMX, hasA };
  } catch (e) {
    return { valid: false, reason: 'dns_error', error: e.message };
  }
}

// Helper: Wrap URLs with click tracking
function wrapUrlWithTracking(url, email, campaign) {
  const baseUrl =
    process.env.NODE_ENV === 'production'
      ? 'https://review-responder.onrender.com'
      : 'http://localhost:3001';

  // Add UTM parameters to the target URL if it's our domain
  let targetUrl = url;
  if (url.includes('tryreviewresponder.com') && !url.includes('utm_')) {
    const separator = url.includes('?') ? '&' : '?';
    targetUrl = `${url}${separator}utm_source=outreach&utm_medium=email&utm_campaign=${encodeURIComponent(campaign)}`;
  }

  return `${baseUrl}/api/outreach/track-click?url=${encodeURIComponent(targetUrl)}&email=${encodeURIComponent(email)}&campaign=${encodeURIComponent(campaign)}`;
}

// Helper: Replace all URLs in text with tracked versions
function addClickTracking(text, email, campaign) {
  // Match URLs starting with http:// or https://
  const urlRegex = /(https?:\/\/[^\s<>"']+)/g;

  return text.replace(urlRegex, url => {
    // Don't track our own tracking URLs (avoid double-wrapping)
    if (url.includes('/api/outreach/track-')) {
      return url;
    }
    return wrapUrlWithTracking(url, email, campaign);
  });
}

function fillEmailTemplate(template, lead, campaign = 'main') {
  let subject = template.subject;
  let body = template.body;

  // Truncate review text to ~150 chars for email readability
  const reviewTextTruncated = lead.worst_review_text
    ? lead.worst_review_text.length > 150
      ? lead.worst_review_text.substring(0, 147) + '...'
      : lead.worst_review_text
    : '';

  // G2 competitor specific: format competitor platform name
  const competitorPlatformFormatted = lead.competitor_platform
    ? lead.competitor_platform.charAt(0).toUpperCase() + lead.competitor_platform.slice(1)
    : 'your current tool';

  // G2 competitor specific: contact name greeting (with leading space if name exists)
  const contactNameGreeting = lead.contact_name ? ` ${lead.contact_name}` : '';

  // G2 competitor specific: review quote (truncated)
  const reviewQuote = lead.review_quote
    ? lead.review_quote.length > 120
      ? lead.review_quote.substring(0, 117) + '...'
      : lead.review_quote
    : '';

  // === SUPER-PERSONALIZED SUBJECT LINES ===
  // Extract reviewer's first name (e.g., "John Smith" -> "John")
  let reviewAuthorFirst = '';
  if (lead.worst_review_author && lead.worst_review_author !== 'a customer') {
    const authorName = lead.worst_review_author.trim();
    // Handle common patterns: "John S.", "John Smith", "John"
    const firstName = authorName.split(/[\s.]/)[0];
    // Validate it's a real name (2+ chars, starts with letter)
    if (firstName && firstName.length >= 2 && /^[A-Za-zÃ€-Ã¿]/.test(firstName)) {
      reviewAuthorFirst = firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();
    }
  }

  // Extract complaint keyword from review text
  let complaintSuffix = '';
  let complaintSuffixDe = '';
  if (lead.worst_review_text && typeof extractKeyComplaint === 'function') {
    const complaint = extractKeyComplaint(lead.worst_review_text);
    if (complaint) {
      complaintSuffix = ` about '${complaint}'`;
      // German translations for common complaints
      const deTranslations = {
        'long wait': 'lange Wartezeit',
        'cold food': 'kaltes Essen',
        'rude staff': 'unfreundliches Personal',
        'slow service': 'langsamer Service',
        'dirty': 'unsauber',
        'overpriced': 'zu teuer',
        'noisy': 'laut',
        'small portions': 'kleine Portionen',
        'bad service': 'schlechter Service',
        'wrong order': 'falsche Bestellung',
        'missing items': 'fehlende Artikel',
        'parking': 'Parken',
        'reservation': 'Reservierung'
      };
      const deComplaint = deTranslations[complaint] || complaint;
      complaintSuffixDe = ` wegen '${deComplaint}'`;
    }
  }

  // Use fallback subject if personalized version can't work
  // (no reviewer name available for personalized subject)
  if (!reviewAuthorFirst && template.subjectFallback) {
    subject = template.subjectFallback;
  }

  const replacements = {
    '{business_name}': lead.business_name || 'your business',
    '{business_type}': lead.business_type || 'business',
    '{review_count}': lead.google_reviews_count || '50',
    '{email}': encodeURIComponent(lead.email || ''),
    '{city}': lead.city || '',
    '{contact_name}': lead.contact_name || 'there',
    // Review alert specific replacements
    '{review_rating}': lead.worst_review_rating || '',
    '{review_text_truncated}': reviewTextTruncated,
    '{review_author}': lead.worst_review_author || 'a customer',
    '{ai_response_draft}': lead.ai_response_draft || '',
    // Demo link for personalized demo pages
    '{demo_url}': lead.demo_url || 'https://tryreviewresponder.com?ref=alert',
    // Lead ID for context injection (Stufe 3)
    '{lead_id}': lead.id || '',
    '{landing_url}': `https://tryreviewresponder.com?lid=${lead.id || ''}&utm_source=email`,
    // G2 competitor specific replacements
    '{competitor_platform}': competitorPlatformFormatted,
    '{contact_name_greeting}': contactNameGreeting,
    '{review_quote}': reviewQuote,
    // Super-personalized subject line replacements
    '{review_author_first}': reviewAuthorFirst,
    '{complaint_suffix}': complaintSuffix,
    '{complaint_suffix_de}': complaintSuffixDe,
  };

  for (const [key, value] of Object.entries(replacements)) {
    subject = subject.replace(new RegExp(key, 'g'), value);
    body = body.replace(new RegExp(key, 'g'), value);
  }

  // Add click tracking to all URLs in body (if we have lead email)
  if (lead.email) {
    body = addClickTracking(body, lead.email, campaign);
  }

  // Note: Unsubscribe footer is added by sendOutreachEmail()
  // Note: Tracking pixel is added by sendEmail() via addTrackingPixel option

  return { subject, body };
}

// ==========================================
// LEAD SCRAPING (Google Places API)
// ==========================================

// Scrape leads from Google Places API
app.post('/api/outreach/scrape-leads', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { query = 'restaurant', city = 'New York', limit = 20 } = req.body;

  const GOOGLE_API_KEY = process.env.GOOGLE_PLACES_API_KEY;

  if (!GOOGLE_API_KEY) {
    return res.status(500).json({
      error: 'GOOGLE_PLACES_API_KEY not configured',
      setup: 'Add GOOGLE_PLACES_API_KEY to Render environment variables',
    });
  }

  try {
    const searchQuery = `${query} in ${city}`;
    const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(searchQuery)}&key=${GOOGLE_API_KEY}`;

    const response = await fetch(url);
    const data = await response.json();

    if (data.status !== 'OK') {
      return res.status(400).json({ error: 'Google Places API error', details: data.status });
    }

    const leads = [];

    for (const place of data.results.slice(0, limit)) {
      // Get detailed info for each place (including reviews for personalized outreach)
      const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${place.place_id}&fields=name,formatted_address,formatted_phone_number,website,rating,user_ratings_total,types,reviews&key=${GOOGLE_API_KEY}`;

      const detailsResponse = await fetch(detailsUrl);
      const details = await detailsResponse.json();

      if (details.status === 'OK') {
        const result = details.result;

        // Parse address
        const addressParts = (result.formatted_address || '').split(',');
        const cityState = addressParts[1]?.trim() || city;

        // Find worst review (1-2 stars) for personalized outreach
        let worstReview = null;
        if (result.reviews && result.reviews.length > 0) {
          const badReviews = result.reviews.filter(r => r.rating <= 2);
          if (badReviews.length > 0) {
            // Get the one with most text (usually more specific complaint)
            worstReview = badReviews.reduce((worst, current) =>
              (current.text?.length || 0) > (worst.text?.length || 0) ? current : worst
            );
          }
        }

        const lead = {
          business_name: result.name,
          business_type: query,
          address: result.formatted_address,
          city: city,
          phone: result.formatted_phone_number,
          website: result.website,
          google_rating: result.rating,
          google_reviews_count: result.user_ratings_total,
          source: 'google_places',
          worst_review_text: worstReview?.text || null,
          worst_review_rating: worstReview?.rating || null,
          worst_review_author: worstReview?.author_name || null,
          has_bad_review: worstReview !== null,
        };

        // Insert lead (ignore duplicates)
        try {
          await dbQuery(
            `
            INSERT INTO outreach_leads
            (business_name, business_type, address, city, phone, website, google_rating, google_reviews_count, source, worst_review_text, worst_review_rating, worst_review_author, has_bad_review)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
            ON CONFLICT (business_name, city) DO UPDATE SET
              google_rating = EXCLUDED.google_rating,
              google_reviews_count = EXCLUDED.google_reviews_count,
              website = COALESCE(EXCLUDED.website, outreach_leads.website),
              worst_review_text = COALESCE(EXCLUDED.worst_review_text, outreach_leads.worst_review_text),
              worst_review_rating = COALESCE(EXCLUDED.worst_review_rating, outreach_leads.worst_review_rating),
              worst_review_author = COALESCE(EXCLUDED.worst_review_author, outreach_leads.worst_review_author),
              has_bad_review = COALESCE(EXCLUDED.has_bad_review, outreach_leads.has_bad_review)
          `,
            [
              lead.business_name,
              lead.business_type,
              lead.address,
              lead.city,
              lead.phone,
              lead.website,
              lead.google_rating,
              lead.google_reviews_count,
              lead.source,
              lead.worst_review_text,
              lead.worst_review_rating,
              lead.worst_review_author,
              lead.has_bad_review,
            ]
          );

          leads.push(lead);
        } catch (dbError) {
          console.error('Lead insert error:', dbError.message);
        }
      }

      // Rate limiting - don't hammer Google API
      await new Promise(r => setTimeout(r, 200));
    }

    res.json({
      success: true,
      leads_found: leads.length,
      query: searchQuery,
      leads: leads,
    });
  } catch (error) {
    console.error('Lead scraping error:', error);
    res.status(500).json({ error: 'Failed to scrape leads' });
  }
});

// ==========================================
// EMAIL FINDER (Hunter.io Integration)
// ==========================================

// Find emails for leads using Hunter.io
app.post('/api/outreach/find-emails', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const HUNTER_API_KEY = process.env.HUNTER_API_KEY;

  if (!HUNTER_API_KEY) {
    return res.status(500).json({
      error: 'HUNTER_API_KEY not configured',
      setup: 'Get free API key from hunter.io and add to Render',
    });
  }

  try {
    // Get leads without emails that have websites
    const leads = await dbAll(`
      SELECT id, business_name, website
      FROM outreach_leads
      WHERE email IS NULL
        AND website IS NOT NULL
        AND website != ''
      LIMIT 25
    `);

    if (leads.length === 0) {
      return res.json({ success: true, message: 'No leads need email lookup', found: 0 });
    }

    let found = 0;

    for (const lead of leads) {
      try {
        // Extract domain from website
        let domain = lead.website;
        domain = domain
          .replace(/^https?:\/\//, '')
          .replace(/^www\./, '')
          .split('/')[0];

        // Use Hunter.io Domain Search
        const hunterUrl = `https://api.hunter.io/v2/domain-search?domain=${domain}&api_key=${HUNTER_API_KEY}`;
        const response = await fetch(hunterUrl);
        const data = await response.json();

        if (data.data?.emails?.length > 0) {
          // Get the most relevant email (usually first one with highest confidence)
          const bestEmail = data.data.emails.sort(
            (a, b) => (b.confidence || 0) - (a.confidence || 0)
          )[0];

          await dbQuery(
            `
            UPDATE outreach_leads
            SET email = $1,
                email_verified = $2,
                email_source = 'hunter.io',
                contact_name = $3
            WHERE id = $4
          `,
            [
              bestEmail.value,
              bestEmail.verification?.status === 'valid',
              `${bestEmail.first_name || ''} ${bestEmail.last_name || ''}`.trim(),
              lead.id,
            ]
          );

          found++;
          console.log(`ðŸ“§ Found email for ${lead.business_name}: ${bestEmail.value}`);
        }

        // Rate limiting for Hunter API
        await new Promise(r => setTimeout(r, 1000));
      } catch (err) {
        console.error(`Email lookup failed for ${lead.business_name}:`, err.message);
      }
    }

    res.json({
      success: true,
      leads_checked: leads.length,
      emails_found: found,
    });
  } catch (error) {
    console.error('Email finder error:', error);
    res.status(500).json({ error: 'Failed to find emails' });
  }
});

// ==========================================
// AUTOMATED EMAIL SENDING
// ==========================================

// Test email endpoint - sends a single test email
app.post('/api/outreach/test-email', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  // Check if ANY email provider is available
  if (!resend && !brevoApi) {
    return res
      .status(500)
      .json({ error: 'No email provider configured (need RESEND_API_KEY or BREVO_API_KEY)' });
  }

  const { email, business_name, city } = req.body;
  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    const testLead = {
      business_name: business_name || 'Test Business',
      business_type: 'restaurant',
      city: city || 'New York', // Default to English, use 'Berlin' for German
      email: email,
      google_reviews_count: 100,
    };

    const template = fillEmailTemplate(getTemplateForLead(1, testLead), testLead);
    const language = detectLanguage(testLead.city);

    const result = await sendOutreachEmail({
      to: email,
      subject: `[TEST] ${template.subject}`,
      html: template.body.replace(/\n/g, '<br>'),
      campaign: 'test',
    });

    res.json({
      success: true,
      message: `Test email sent to ${email} via ${result.provider}`,
      provider: result.provider,
      from: OUTREACH_FROM_EMAIL,
      language: language,
      city: testLead.city,
      message_id: result.messageId,
    });
  } catch (err) {
    console.error('Test email error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Test Review Alert Email - sends a test review alert email with personalized demo page
// Use ?with_demo=true to generate a full demo page with 3 reviews + AI responses
app.post('/api/outreach/test-review-alert', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend && !brevoApi) {
    return res.status(500).json({ error: 'No email provider configured' });
  }

  const { email, business_name, city, with_demo } = req.body;
  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    const testBusinessName = business_name || 'Augustiner-Keller';
    const testCity = city || 'Berlin';
    const lang = detectLanguage(testCity);

    // Create test lead object
    const testLead = {
      business_name: testBusinessName,
      business_type: 'restaurant',
      city: testCity,
      email: email,
    };

    let demoUrl = null;
    let aiDraftPreview = null;
    let reviewsProcessed = 0;

    // Generate full demo if requested (default: true for complete testing)
    if (with_demo !== false) {
      console.log(`ðŸ“ Generating demo for test: ${testBusinessName}...`);
      const demoResult = await generateDemoForLead(testLead);

      if (demoResult && demoResult.first_ai_response) {
        testLead.demo_url = demoResult.demo_url;
        testLead.ai_response_draft = demoResult.first_ai_response;
        testLead.has_bad_review = true;
        // Set review fields for email template
        if (demoResult.first_review) {
          testLead.worst_review_rating = demoResult.first_review.rating;
          testLead.worst_review_text = demoResult.first_review.text;
          testLead.worst_review_author = demoResult.first_review.author;
        }
        demoUrl = demoResult.demo_url;
        aiDraftPreview = demoResult.first_ai_response;
        reviewsProcessed = demoResult.reviews_processed;
        console.log(`âœ… Demo generated: ${demoUrl} (${reviewsProcessed} reviews)`);
      } else {
        console.log(`âš ï¸ Demo generation failed, using no_demo template`);
      }
    }

    // Select template based on whether demo was generated
    let templateKey;
    if (testLead.demo_url) {
      templateKey = lang === 'de' ? 'review_alert_de' : 'review_alert';
    } else {
      templateKey = lang === 'de' ? 'review_alert_no_demo_de' : 'review_alert_no_demo';
    }

    const template = fillEmailTemplate(EMAIL_TEMPLATES[templateKey], testLead);

    // Send email
    const result = await sendOutreachEmail({
      to: email,
      subject: `[TEST] ${template.subject}`,
      html: template.body.replace(/\n/g, '<br>'),
      campaign: 'test_review_alert',
    });

    res.json({
      success: true,
      message: `Review Alert test email sent to ${email}`,
      provider: result.provider,
      language: lang,
      business_name: testBusinessName,
      demo_generated: !!demoUrl,
      demo_url: demoUrl,
      reviews_processed: reviewsProcessed,
      template_used: templateKey,
      ai_draft_preview: aiDraftPreview ? aiDraftPreview.substring(0, 200) + '...' : null,
    });
  } catch (err) {
    console.error('Test review alert error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Debug email logs - see recent sent emails
app.get('/api/admin/email-logs', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const limit = parseInt(req.query.limit) || 20;
    const result = await dbQuery(
      `
      SELECT id, to_email, subject, type, campaign, provider, status, error, message_id, sent_at
      FROM email_logs
      ORDER BY sent_at DESC
      LIMIT $1
    `,
      [limit]
    );

    res.json({
      total: result.rows.length,
      emails: result.rows,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// API Costs Dashboard - Track all external API expenses
app.get('/api/admin/api-costs', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Today's costs by provider/model
    const today = await dbQuery(`
      SELECT provider, model, COUNT(*) as calls,
             COALESCE(SUM(total_tokens), 0) as tokens,
             COALESCE(SUM(estimated_cost), 0) as cost
      FROM api_call_logs
      WHERE created_at >= CURRENT_DATE
      GROUP BY provider, model
      ORDER BY cost DESC
    `);

    // This month's costs by provider/model
    const thisMonth = await dbQuery(`
      SELECT provider, model, COUNT(*) as calls,
             COALESCE(SUM(total_tokens), 0) as tokens,
             COALESCE(SUM(estimated_cost), 0) as cost
      FROM api_call_logs
      WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)
      GROUP BY provider, model
      ORDER BY cost DESC
    `);

    // Daily trend (last 30 days)
    const trend = await dbQuery(`
      SELECT DATE(created_at) as date, provider,
             COALESCE(SUM(estimated_cost), 0) as cost,
             COUNT(*) as calls
      FROM api_call_logs
      WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
      GROUP BY DATE(created_at), provider
      ORDER BY date
    `);

    // Totals summary
    const totals = await dbQuery(`
      SELECT
        COALESCE(SUM(CASE WHEN created_at >= CURRENT_DATE THEN estimated_cost ELSE 0 END), 0) as today,
        COALESCE(SUM(CASE WHEN created_at >= DATE_TRUNC('month', CURRENT_DATE) THEN estimated_cost ELSE 0 END), 0) as this_month,
        COALESCE(SUM(estimated_cost), 0) as all_time,
        COUNT(CASE WHEN created_at >= CURRENT_DATE THEN 1 END) as calls_today,
        COUNT(CASE WHEN created_at >= DATE_TRUNC('month', CURRENT_DATE) THEN 1 END) as calls_this_month,
        COUNT(*) as calls_all_time
      FROM api_call_logs
    `);

    // Recent errors (last 24h)
    const errors = await dbQuery(`
      SELECT provider, model, endpoint, error_message, created_at
      FROM api_call_logs
      WHERE status = 'error' AND created_at >= NOW() - INTERVAL '24 hours'
      ORDER BY created_at DESC
      LIMIT 10
    `);

    res.json({
      totals: totals.rows[0] || { today: 0, this_month: 0, all_time: 0 },
      today: today.rows,
      thisMonth: thisMonth.rows,
      trend: trend.rows,
      recentErrors: errors.rows,
      pricing: API_PRICING,
    });
  } catch (err) {
    console.error('[api-costs] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// API Credits Dashboard - Show remaining credits for all external APIs
app.get('/api/admin/api-credits', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const credits = [];

  // Helper to calculate status
  const getStatus = (used, limit) => {
    const percent = (used / limit) * 100;
    if (percent >= 100) return 'exhausted';
    if (percent >= 90) return 'critical';
    if (percent >= 70) return 'warning';
    return 'ok';
  };

  try {
    // 1. SerpAPI - Check via API (free call)
    if (process.env.SERPAPI_KEY) {
      try {
        const serpRes = await fetch(
          `https://serpapi.com/account.json?api_key=${process.env.SERPAPI_KEY}`
        );
        const serpData = await serpRes.json();
        const used = serpData.this_month_usage || 0;
        const limit =
          serpData.plan_searches_left !== undefined ? used + serpData.plan_searches_left : 250; // Free tier default
        credits.push({
          name: 'SerpAPI',
          used,
          limit,
          period: 'month',
          percent: Math.round((used / limit) * 100),
          status: getStatus(used, limit),
        });
      } catch (e) {
        credits.push({ name: 'SerpAPI', error: e.message });
      }
    } else {
      credits.push({ name: 'SerpAPI', error: 'Not configured' });
    }

    // 2. Hunter.io - Check via API (free call)
    if (process.env.HUNTER_API_KEY) {
      try {
        const hunterRes = await fetch(
          `https://api.hunter.io/v2/account?api_key=${process.env.HUNTER_API_KEY}`
        );
        const hunterData = await hunterRes.json();
        const requests = hunterData.data?.requests;
        if (requests?.credits) {
          const used = requests.credits.used || 0;
          const limit = (requests.credits.available || 0) + used;
          credits.push({
            name: 'Hunter.io',
            used,
            limit: limit || 25, // Free tier default
            period: 'month',
            percent: limit > 0 ? Math.round((used / limit) * 100) : 0,
            status: getStatus(used, limit || 25),
          });
        } else {
          credits.push({ name: 'Hunter.io', error: 'Invalid response' });
        }
      } catch (e) {
        credits.push({ name: 'Hunter.io', error: e.message });
      }
    } else {
      credits.push({ name: 'Hunter.io', error: 'Not configured' });
    }

    // 3. Snov.io - Check via API with OAuth (free call)
    if (process.env.SNOV_CLIENT_ID && process.env.SNOV_CLIENT_SECRET) {
      try {
        const tokenRes = await fetch('https://api.snov.io/v1/oauth/access_token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'client_credentials',
            client_id: process.env.SNOV_CLIENT_ID,
            client_secret: process.env.SNOV_CLIENT_SECRET,
          }),
        });
        const tokenData = await tokenRes.json();

        if (tokenData.access_token) {
          const balanceRes = await fetch('https://api.snov.io/v1/get-balance', {
            headers: { Authorization: `Bearer ${tokenData.access_token}` },
          });
          const balanceData = await balanceRes.json();

          if (balanceData.success && balanceData.data) {
            const balance = parseFloat(balanceData.data.balance) || 0;
            // Snov.io shows available credits, not used
            // Free tier is 50 credits/month, so we estimate used = 50 - balance
            const limit = 50;
            const used = Math.max(0, limit - balance);
            credits.push({
              name: 'Snov.io',
              used: Math.round(used),
              limit,
              period: 'month',
              percent: Math.round((used / limit) * 100),
              status: getStatus(used, limit),
            });
          } else {
            credits.push({ name: 'Snov.io', error: 'Balance check failed' });
          }
        } else {
          credits.push({ name: 'Snov.io', error: 'Token error' });
        }
      } catch (e) {
        credits.push({ name: 'Snov.io', error: e.message });
      }
    } else {
      credits.push({ name: 'Snov.io', error: 'Not configured' });
    }

    // 4. Outscraper - No API, count from api_call_logs
    try {
      const outscraperResult = await dbQuery(`
        SELECT COUNT(*) as used
        FROM api_call_logs
        WHERE provider = 'outscraper'
        AND created_at >= DATE_TRUNC('month', CURRENT_DATE)
      `);
      const used = parseInt(outscraperResult.rows[0]?.used) || 0;
      const limit = 500; // Free tier
      credits.push({
        name: 'Outscraper',
        used,
        limit,
        period: 'month',
        percent: Math.round((used / limit) * 100),
        status: getStatus(used, limit),
      });
    } catch (e) {
      credits.push({ name: 'Outscraper', error: e.message });
    }

    // 5. Brevo - Count from email_logs (today)
    try {
      const brevoResult = await dbQuery(`
        SELECT COUNT(*) as used
        FROM email_logs
        WHERE provider = 'brevo'
        AND sent_at >= CURRENT_DATE
      `);
      const used = parseInt(brevoResult.rows[0]?.used) || 0;
      const limit = 300; // Free tier daily limit
      credits.push({
        name: 'Brevo',
        used,
        limit,
        period: 'day',
        percent: Math.round((used / limit) * 100),
        status: getStatus(used, limit),
      });
    } catch (e) {
      credits.push({ name: 'Brevo', error: e.message });
    }

    // 6. Resend - Count from email_logs (today)
    try {
      const resendResult = await dbQuery(`
        SELECT COUNT(*) as used
        FROM email_logs
        WHERE provider = 'resend'
        AND sent_at >= CURRENT_DATE
      `);
      const used = parseInt(resendResult.rows[0]?.used) || 0;
      const limit = 100; // Free tier daily limit
      credits.push({
        name: 'Resend',
        used,
        limit,
        period: 'day',
        percent: Math.round((used / limit) * 100),
        status: getStatus(used, limit),
      });
    } catch (e) {
      credits.push({ name: 'Resend', error: e.message });
    }

    res.json({
      credits,
      lastUpdated: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[api-credits] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Claude CLI Account Usage - Sync from local scripts
// POST endpoint receives usage data from Sync-AccountUsage.ps1
app.post('/api/admin/sync-account-usage', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { accounts } = req.body;

  if (!accounts || !Array.isArray(accounts)) {
    return res.status(400).json({ error: 'accounts array required' });
  }

  try {
    const results = [];
    const today = new Date().toISOString().split('T')[0];

    for (const acc of accounts) {
      // Calculate week tokens (sum of last 7 days)
      const tokensWeek = acc.tokens_week || acc.tokens_today || 0;

      // Upsert for today
      await dbQuery(
        `INSERT INTO claude_account_usage (account_name, email, date, tokens_today, tokens_week, messages_today, sessions_today, synced_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
         ON CONFLICT (account_name, date)
         DO UPDATE SET tokens_today = $4, tokens_week = $5, messages_today = $6, sessions_today = $7, synced_at = NOW()`,
        [
          acc.account_name,
          acc.email,
          today,
          acc.tokens_today || 0,
          tokensWeek,
          acc.messages_today || 0,
          acc.sessions_today || 0,
        ]
      );

      results.push({
        account: acc.account_name,
        tokens_today: acc.tokens_today || 0,
        status: 'synced',
      });
    }

    res.json({
      success: true,
      synced: results.length,
      accounts: results,
      synced_at: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[sync-account-usage] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Claude CLI Account Usage - Get current usage for Admin Panel
app.get('/api/admin/account-usage', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  // Configurable limits (Claude Pro ~45M tokens/month, ~11M/week, ~1.5M/day)
  const DAILY_LIMIT = parseInt(process.env.CLAUDE_DAILY_TOKEN_LIMIT) || 1500000;
  const WEEKLY_LIMIT = parseInt(process.env.CLAUDE_WEEKLY_TOKEN_LIMIT) || 11000000;

  try {
    const today = new Date().toISOString().split('T')[0];

    // Get latest data for each account
    const result = await dbQuery(`
      SELECT DISTINCT ON (account_name)
        account_name, email, date, tokens_today, tokens_week, messages_today, sessions_today, synced_at
      FROM claude_account_usage
      ORDER BY account_name, date DESC
    `);

    const accounts = result.rows.map((row) => {
      const dailyPercent = Math.round((row.tokens_today / DAILY_LIMIT) * 100);
      const weeklyPercent = Math.round((row.tokens_week / WEEKLY_LIMIT) * 100);

      return {
        account_name: row.account_name,
        email: row.email,
        date: row.date,
        tokens_today: parseInt(row.tokens_today) || 0,
        tokens_week: parseInt(row.tokens_week) || 0,
        messages_today: row.messages_today || 0,
        sessions_today: row.sessions_today || 0,
        daily_percent: dailyPercent,
        weekly_percent: weeklyPercent,
        daily_status: dailyPercent >= 90 ? 'critical' : dailyPercent >= 70 ? 'warning' : 'ok',
        weekly_status: weeklyPercent >= 90 ? 'critical' : weeklyPercent >= 70 ? 'warning' : 'ok',
        synced_at: row.synced_at,
      };
    });

    // Calculate totals across all accounts
    const totals = {
      tokens_today: accounts.reduce((sum, a) => sum + a.tokens_today, 0),
      tokens_week: accounts.reduce((sum, a) => sum + a.tokens_week, 0),
      messages_today: accounts.reduce((sum, a) => sum + a.messages_today, 0),
      sessions_today: accounts.reduce((sum, a) => sum + a.sessions_today, 0),
    };

    res.json({
      accounts,
      totals,
      limits: {
        daily: DAILY_LIMIT,
        weekly: WEEKLY_LIMIT,
      },
      last_sync: accounts.length > 0 ? accounts[0].synced_at : null,
    });
  } catch (err) {
    console.error('[account-usage] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Pipeline Health - Comprehensive health check for sales automation
// Used by /sales-doctor command to diagnose system health
app.get('/api/admin/pipeline-health', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // 1. Lead Pipeline Stats
    // Note: outreach_leads uses status column ('new', 'contacted', etc.) not boolean 'contacted'
    const leadsResult = await dbQuery(`
      SELECT
        COUNT(*) as total,
        COUNT(*) FILTER (WHERE email IS NOT NULL) as with_email,
        COUNT(*) FILTER (WHERE status != 'contacted' AND email IS NOT NULL) as in_queue,
        COUNT(*) FILTER (WHERE status = 'contacted') as contacted,
        COUNT(*) FILTER (WHERE demo_url IS NULL AND email IS NOT NULL) as needs_demo
      FROM outreach_leads
    `);
    const leads = leadsResult.rows[0] || {};

    // 2. Demo Generation Stats
    const demosResult = await dbQuery(`
      SELECT
        COUNT(*) as total,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as today,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as week,
        MAX(created_at) as last_created
      FROM demo_pages
    `);
    const demos = demosResult.rows[0] || {};

    // 3. Email Stats
    const emailsResult = await dbQuery(`
      SELECT
        COUNT(*) FILTER (WHERE sent_at >= CURRENT_DATE) as today,
        COUNT(*) FILTER (WHERE sent_at >= CURRENT_DATE - INTERVAL '7 days') as week,
        MAX(sent_at) as last_sent,
        COUNT(*) FILTER (WHERE campaign LIKE '%drip%' AND sent_at >= CURRENT_DATE) as drip_today,
        COUNT(*) FILTER (WHERE campaign LIKE '%followup%' AND sent_at >= CURRENT_DATE) as followup_today
      FROM email_logs
    `);
    const emails = emailsResult.rows[0] || {};

    // 4. Conversion Funnel
    const funnelResult = await dbQuery(`
      SELECT
        (SELECT COUNT(*) FROM outreach_leads) as leads_total,
        (SELECT COUNT(*) FROM outreach_leads WHERE email IS NOT NULL) as leads_with_email,
        (SELECT COUNT(*) FROM outreach_leads WHERE status = 'contacted') as leads_contacted,
        (SELECT COUNT(*) FROM email_clicks) as clicks,
        (SELECT COUNT(*) FROM users WHERE source = 'outreach') as signups_from_outreach,
        (SELECT COUNT(*) FROM users WHERE subscription_plan != 'free' AND source = 'outreach') as paid_from_outreach
    `);
    const funnel = funnelResult.rows[0] || {};

    // 5. Calculate health status
    const getStatus = (value, warningThreshold, criticalThreshold, higherIsBetter = true) => {
      if (higherIsBetter) {
        if (value < criticalThreshold) return 'critical';
        if (value < warningThreshold) return 'warning';
        return 'ok';
      } else {
        if (value > criticalThreshold) return 'critical';
        if (value > warningThreshold) return 'warning';
        return 'ok';
      }
    };

    const leadQueueStatus = getStatus(parseInt(leads.in_queue) || 0, 100, 20);
    const leadEmailStatus = getStatus(parseInt(leads.with_email) || 0, 100, 50);

    // Demo health: Check if demos were created recently
    const lastDemoAge = demos.last_created
      ? Math.floor((Date.now() - new Date(demos.last_created).getTime()) / (1000 * 60 * 60))
      : 999;
    const demoStatus = lastDemoAge > 48 ? 'critical' : lastDemoAge > 24 ? 'warning' : 'ok';

    // Email health: Check if emails were sent recently
    const lastEmailAge = emails.last_sent
      ? Math.floor((Date.now() - new Date(emails.last_sent).getTime()) / (1000 * 60 * 60))
      : 999;
    const emailStatus = lastEmailAge > 48 ? 'critical' : lastEmailAge > 24 ? 'warning' : 'ok';

    // Overall health
    const statuses = [leadQueueStatus, leadEmailStatus, demoStatus, emailStatus];
    const overallHealth = statuses.includes('critical')
      ? 'critical'
      : statuses.includes('warning')
        ? 'warning'
        : 'ok';

    res.json({
      leads: {
        total: parseInt(leads.total) || 0,
        withEmail: parseInt(leads.with_email) || 0,
        inQueue: parseInt(leads.in_queue) || 0,
        contacted: parseInt(leads.contacted) || 0,
        needsDemo: parseInt(leads.needs_demo) || 0,
        queueStatus: leadQueueStatus,
        emailStatus: leadEmailStatus,
      },
      demos: {
        total: parseInt(demos.total) || 0,
        today: parseInt(demos.today) || 0,
        week: parseInt(demos.week) || 0,
        lastCreated: demos.last_created,
        lastCreatedHoursAgo: lastDemoAge,
        status: demoStatus,
      },
      emails: {
        today: parseInt(emails.today) || 0,
        week: parseInt(emails.week) || 0,
        lastSent: emails.last_sent,
        lastSentHoursAgo: lastEmailAge,
        dripToday: parseInt(emails.drip_today) || 0,
        followupToday: parseInt(emails.followup_today) || 0,
        status: emailStatus,
      },
      funnel: {
        leadsTotal: parseInt(funnel.leads_total) || 0,
        leadsWithEmail: parseInt(funnel.leads_with_email) || 0,
        leadsContacted: parseInt(funnel.leads_contacted) || 0,
        clicks: parseInt(funnel.clicks) || 0,
        signups: parseInt(funnel.signups_from_outreach) || 0,
        paid: parseInt(funnel.paid_from_outreach) || 0,
        // Conversion rates
        emailFindRate:
          funnel.leads_total > 0
            ? Math.round((funnel.leads_with_email / funnel.leads_total) * 100)
            : 0,
        contactRate:
          funnel.leads_with_email > 0
            ? Math.round((funnel.leads_contacted / funnel.leads_with_email) * 100)
            : 0,
        clickRate:
          funnel.leads_contacted > 0
            ? Math.round((funnel.clicks / funnel.leads_contacted) * 100)
            : 0,
        signupRate:
          funnel.clicks > 0 ? Math.round((funnel.signups_from_outreach / funnel.clicks) * 100) : 0,
        paidRate:
          funnel.signups_from_outreach > 0
            ? Math.round((funnel.paid_from_outreach / funnel.signups_from_outreach) * 100)
            : 0,
      },
      health: {
        overall: overallHealth,
        leadQueue: leadQueueStatus,
        leadEmails: leadEmailStatus,
        demoGeneration: demoStatus,
        emailDelivery: emailStatus,
      },
      lastUpdated: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[pipeline-health] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// AI Health - Check if AI response generation is working
// Used by /sales-doctor to verify product functionality
app.get('/api/admin/ai-health', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // 1. Recent AI generations
    const generationsResult = await dbQuery(`
      SELECT
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as today,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as week,
        MAX(created_at) as last_generation
      FROM responses
    `);
    const generations = generationsResult.rows[0] || {};

    // 2. AI API call stats from logs
    // Note: Table uses error_message (not error) and has no completed_at column
    const apiStatsResult = await dbQuery(`
      SELECT
        provider,
        COUNT(*) as calls,
        COUNT(*) FILTER (WHERE error_message IS NOT NULL OR status = 'error') as errors
      FROM api_call_logs
      WHERE created_at >= CURRENT_DATE - INTERVAL '24 hours'
      GROUP BY provider
    `);
    const apiStats = apiStatsResult.rows || [];

    // 3. Calculate error rates
    const totalCalls = apiStats.reduce((sum, s) => sum + parseInt(s.calls || 0), 0);
    const totalErrors = apiStats.reduce((sum, s) => sum + parseInt(s.errors || 0), 0);
    const errorRate = totalCalls > 0 ? Math.round((totalErrors / totalCalls) * 100) : 0;

    // 4. Last generation age
    const lastGenAge = generations.last_generation
      ? Math.floor(
          (Date.now() - new Date(generations.last_generation).getTime()) / (1000 * 60 * 60)
        )
      : 999;

    // 5. Health status
    const genStatus = lastGenAge > 48 ? 'critical' : lastGenAge > 24 ? 'warning' : 'ok';
    const errorStatus = errorRate > 20 ? 'critical' : errorRate > 10 ? 'warning' : 'ok';
    const overallHealth =
      genStatus === 'critical' || errorStatus === 'critical'
        ? 'critical'
        : genStatus === 'warning' || errorStatus === 'warning'
          ? 'warning'
          : 'ok';

    res.json({
      generations: {
        today: parseInt(generations.today) || 0,
        week: parseInt(generations.week) || 0,
        lastGeneration: generations.last_generation,
        lastGenerationHoursAgo: lastGenAge,
        status: genStatus,
      },
      apiCalls: {
        last24h: totalCalls,
        errors: totalErrors,
        errorRate,
        byProvider: apiStats.map(s => ({
          provider: s.provider,
          calls: parseInt(s.calls) || 0,
          errors: parseInt(s.errors) || 0,
        })),
        status: errorStatus,
      },
      health: {
        overall: overallHealth,
        generation: genStatus,
        errorRate: errorStatus,
      },
      lastUpdated: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[ai-health] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Payment Health - Check if Stripe/payments are working
// Used by /sales-doctor to verify checkout functionality
app.get('/api/admin/payment-health', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // 1. Subscription stats
    const subsResult = await dbQuery(`
      SELECT
        COUNT(*) FILTER (WHERE subscription_plan != 'free') as paying_users,
        COUNT(*) FILTER (WHERE subscription_plan = 'starter') as starter,
        COUNT(*) FILTER (WHERE subscription_plan = 'professional') as professional,
        COUNT(*) FILTER (WHERE subscription_plan = 'unlimited') as unlimited,
        MAX(CASE WHEN subscription_plan != 'free' THEN created_at END) as last_paid_signup
      FROM users
    `);
    const subs = subsResult.rows[0] || {};

    // 2. Recent payment events (if we have a payments table)
    let payments = { total: 0, successful: 0, failed: 0 };
    try {
      const paymentsResult = await dbQuery(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE status = 'succeeded') as successful,
          COUNT(*) FILTER (WHERE status = 'failed') as failed,
          MAX(created_at) as last_payment
        FROM stripe_events
        WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
        AND event_type LIKE 'payment%'
      `);
      payments = paymentsResult.rows[0] || payments;
    } catch (e) {
      // stripe_events table might not exist
    }

    // 3. Stripe config check
    const stripeConfigured = !!(process.env.STRIPE_SECRET_KEY && process.env.STRIPE_WEBHOOK_SECRET);

    // 4. Calculate health
    const lastPaidAge = subs.last_paid_signup
      ? Math.floor((Date.now() - new Date(subs.last_paid_signup).getTime()) / (1000 * 60 * 60 * 24))
      : 999;

    const paymentStatus = !stripeConfigured
      ? 'critical'
      : parseInt(payments.failed) > parseInt(payments.successful)
        ? 'warning'
        : 'ok';

    res.json({
      subscriptions: {
        total: parseInt(subs.paying_users) || 0,
        starter: parseInt(subs.starter) || 0,
        professional: parseInt(subs.professional) || 0,
        unlimited: parseInt(subs.unlimited) || 0,
        lastPaidSignup: subs.last_paid_signup,
        daysSinceLastPaid: lastPaidAge,
      },
      payments: {
        last30Days: parseInt(payments.total) || 0,
        successful: parseInt(payments.successful) || 0,
        failed: parseInt(payments.failed) || 0,
        lastPayment: payments.last_payment,
      },
      config: {
        stripeConfigured,
        webhookConfigured: !!process.env.STRIPE_WEBHOOK_SECRET,
      },
      health: {
        overall: paymentStatus,
        stripe: stripeConfigured ? 'ok' : 'critical',
        payments: paymentStatus,
      },
      lastUpdated: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[payment-health] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Paying Users - List all paying customers for Sales Doctor
app.get('/api/admin/paying-users', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const result = await dbQuery(`
      SELECT
        id,
        email,
        name,
        subscription_plan,
        subscription_status,
        responses_used,
        source,
        created_at
      FROM users
      WHERE subscription_plan != 'free'
      ORDER BY created_at DESC
    `);

    res.json({
      paying_users: result.rows,
      count: result.rows.length,
      lastUpdated: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[paying-users] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// User Activity - Check if users are actually using the product
// Used by /sales-doctor to verify product engagement
app.get('/api/admin/user-activity', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Use central test email filter
    const excludeEmails = getTestEmailExcludeClause('email');

    // 1. Active users (by response generation)
    const activityResult = await dbQuery(`
      SELECT
        COUNT(DISTINCT user_id) FILTER (WHERE created_at >= CURRENT_DATE) as dau,
        COUNT(DISTINCT user_id) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as wau,
        COUNT(DISTINCT user_id) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '30 days') as mau
      FROM responses
      WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
    `);
    const activity = activityResult.rows[0] || {};

    // 2. Response generation stats
    const responsesResult = await dbQuery(`
      SELECT
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as today,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as week,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '30 days') as month,
        ROUND(AVG(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 ELSE NULL END)::numeric * COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') / 7, 1) as avg_per_day
      FROM responses
    `);
    const responses = responsesResult.rows[0] || {};

    // 3. Users hitting limit (potential conversion targets)
    const limitResult = await dbQuery(`
      SELECT
        COUNT(*) as users_at_limit,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as recent_at_limit
      FROM users
      WHERE subscription_plan = 'free'
      AND responses_used >= 20
      ${excludeEmails}
    `);
    const limits = limitResult.rows[0] || {};

    // 4. New vs returning users
    // Note: No last_login column in users table, so we estimate returning users
    // by checking if they have responses in the last 7 days but account is older
    const retentionResult = await dbQuery(`
      SELECT
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as new_users_week,
        (SELECT COUNT(DISTINCT user_id) FROM responses
         WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
         AND user_id IN (SELECT id FROM users WHERE created_at < CURRENT_DATE - INTERVAL '7 days' ${excludeEmails})
        ) as returning_users_week
      FROM users
      WHERE 1=1 ${excludeEmails}
    `);
    const retention = retentionResult.rows[0] || {};

    // 5. Calculate health
    const dauStatus =
      parseInt(activity.dau) > 5 ? 'ok' : parseInt(activity.dau) > 0 ? 'warning' : 'critical';
    const responsesStatus =
      parseInt(responses.today) > 10
        ? 'ok'
        : parseInt(responses.today) > 0
          ? 'warning'
          : 'critical';

    res.json({
      activeUsers: {
        dau: parseInt(activity.dau) || 0,
        wau: parseInt(activity.wau) || 0,
        mau: parseInt(activity.mau) || 0,
        status: dauStatus,
      },
      responses: {
        today: parseInt(responses.today) || 0,
        week: parseInt(responses.week) || 0,
        month: parseInt(responses.month) || 0,
        avgPerDay: parseFloat(responses.avg_per_day) || 0,
        status: responsesStatus,
      },
      conversion: {
        usersAtLimit: parseInt(limits.users_at_limit) || 0,
        recentAtLimit: parseInt(limits.recent_at_limit) || 0,
      },
      retention: {
        newUsersWeek: parseInt(retention.new_users_week) || 0,
        returningUsersWeek: parseInt(retention.returning_users_week) || 0,
      },
      health: {
        overall:
          dauStatus === 'critical' || responsesStatus === 'critical'
            ? 'critical'
            : dauStatus === 'warning' || responsesStatus === 'warning'
              ? 'warning'
              : 'ok',
        activeUsers: dauStatus,
        responses: responsesStatus,
      },
      lastUpdated: new Date().toISOString(),
    });
  } catch (err) {
    console.error('[user-activity] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Usage Analytics - Understand Free User behavior for conversion optimization
// WICHTIG: Filtert Test-Accounts und Freunde aus fÃ¼r saubere Metriken!
app.get('/api/admin/usage-analytics', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Build SQL exclusion list from TEST_EMAILS + patterns
    const testEmailList = TEST_EMAILS.map(e => `'${e}'`).join(', ');
    const excludeClause = `
      LOWER(email) NOT IN (${testEmailList})
      AND email NOT LIKE '%@web.de'
      AND email NOT LIKE 'test%'
      AND email NOT LIKE '%@test.%'
      AND email NOT LIKE '%@example.%'
    `;

    // Usage distribution for Free users (OHNE Test-Accounts)
    const distribution = await dbQuery(`
      SELECT
        CASE
          WHEN responses_used = 0 THEN '0 responses'
          WHEN responses_used < 5 THEN '1-4 responses'
          WHEN responses_used < 10 THEN '5-9 responses'
          WHEN responses_used < 15 THEN '10-14 responses'
          WHEN responses_used < 20 THEN '15-19 responses'
          ELSE '20+ (limit hit)'
        END as usage_bucket,
        COUNT(*) as user_count,
        ROUND(100.0 * COUNT(*) / NULLIF(SUM(COUNT(*)) OVER (), 0), 1) as percentage
      FROM users
      WHERE subscription_plan = 'free'
        AND ${excludeClause}
      GROUP BY 1
      ORDER BY MIN(responses_used)
    `);

    // Aggregate stats (OHNE Test-Accounts)
    const stats = await dbQuery(`
      SELECT
        COUNT(*) as total_free_users,
        ROUND(AVG(responses_used), 1) as avg_responses,
        MAX(responses_used) as max_responses,
        COUNT(*) FILTER (WHERE responses_used >= 20) as limit_reached_count,
        ROUND(100.0 * COUNT(*) FILTER (WHERE responses_used >= 20) / NULLIF(COUNT(*), 0), 1) as limit_reached_pct,
        COUNT(*) FILTER (WHERE responses_used > 0) as activated_users,
        ROUND(100.0 * COUNT(*) FILTER (WHERE responses_used > 0) / NULLIF(COUNT(*), 0), 1) as activation_rate
      FROM users
      WHERE subscription_plan = 'free'
        AND ${excludeClause}
    `);

    // Exit survey results with percentage
    const exitSurveys = await dbQuery(`
      SELECT reason, COUNT(*) as count,
             ROUND(100.0 * COUNT(*) / NULLIF(SUM(COUNT(*)) OVER (), 0), 1) as percentage
      FROM exit_surveys
      GROUP BY reason
      ORDER BY count DESC
    `);

    // Recent limit-hit users (OHNE Test-Accounts)
    const limitHitUsers = await dbQuery(`
      SELECT email, business_name, responses_used as total_responses, created_at
      FROM users
      WHERE subscription_plan = 'free'
        AND responses_used >= 20
        AND ${excludeClause}
      ORDER BY created_at DESC
      LIMIT 10
    `);

    res.json({
      note: 'Filtered: Test-Accounts und Freunde ausgeschlossen',
      distribution: distribution.rows,
      stats: stats.rows[0] || {},
      exitSurveys: exitSurveys.rows,
      limitHitUsers: limitHitUsers.rows,
    });
  } catch (err) {
    console.error('[usage-analytics] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Exit Survey Tracking - Understand why users don't upgrade
app.post('/api/analytics/exit-survey', async (req, res) => {
  const { reason, context, user_id } = req.body;

  if (!reason) {
    return res.status(400).json({ error: 'Reason is required' });
  }

  try {
    await dbQuery(
      'INSERT INTO exit_surveys (user_id, reason, context, created_at) VALUES ($1, $2, $3, NOW())',
      [user_id || null, reason, context || null]
    );
    res.json({ ok: true });
  } catch (err) {
    console.error('[exit-survey] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Test Usage Alert Email
app.post('/api/admin/test-usage-alert', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Resend not configured' });
  }

  const { email } = req.body;
  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    const testUser = {
      email: email,
      business_name: 'Test Business',
      subscription_plan: 'starter',
      email_usage_alerts: true,
    };

    const sent = await sendUsageAlertEmail(testUser);
    if (sent) {
      res.json({ success: true, message: `Usage alert test email sent to ${email}` });
    } else {
      res.status(500).json({ error: 'Failed to send email' });
    }
  } catch (err) {
    console.error('Test usage alert error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Test Plan Renewal Email
app.post('/api/admin/test-plan-renewal', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Resend not configured' });
  }

  const { email } = req.body;
  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    const testUser = {
      email: email,
      business_name: 'Test Business',
      subscription_plan: 'professional',
      email_billing_updates: true,
    };

    const sent = await sendPlanRenewalEmail(testUser);
    if (sent) {
      res.json({ success: true, message: `Plan renewal test email sent to ${email}` });
    } else {
      res.status(500).json({ error: 'Failed to send email' });
    }
  } catch (err) {
    console.error('Test plan renewal error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Test Affiliate Status Email (Approved/Rejected)
app.post('/api/admin/test-affiliate-email', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!process.env.ADMIN_SECRET || !safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Resend not configured' });
  }

  const { email, status = 'approved', note } = req.body;
  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }
  if (!['approved', 'rejected'].includes(status)) {
    return res.status(400).json({ error: 'Status must be approved or rejected' });
  }

  try {
    const testUser = {
      email: email,
      business_name: 'Test Affiliate',
    };
    const testAffiliate = {
      affiliate_code: 'TEST123',
      commission_rate: 20,
    };

    let subject, html;

    if (status === 'approved') {
      subject = '[TEST] Your Affiliate Application is Approved!';
      html = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #10B981;">Congratulations! You're Now a ReviewResponder Affiliate</h1>
          <p>Hi ${testUser.business_name},</p>
          <p>Great news! Your affiliate application has been approved.</p>
          <p><strong>Your Affiliate Code:</strong> ${testAffiliate.affiliate_code}</p>
          <p><strong>Commission Rate:</strong> ${testAffiliate.commission_rate}% recurring</p>
          <p>You can now start earning by sharing your unique affiliate link:</p>
          <p style="background: #F3F4F6; padding: 15px; border-radius: 8px; font-family: monospace;">
            https://tryreviewresponder.com/?aff=${testAffiliate.affiliate_code}
          </p>
          <p>Visit your <a href="https://tryreviewresponder.com/affiliate/dashboard">Affiliate Dashboard</a> to track your earnings and get marketing materials.</p>
          <p>Best,<br>The ReviewResponder Team</p>
        </div>
      `;
    } else {
      subject = '[TEST] Update on Your Affiliate Application';
      html = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #6B7280;">Affiliate Application Update</h1>
          <p>Hi ${testUser.business_name},</p>
          <p>Thank you for your interest in the ReviewResponder affiliate program.</p>
          <p>After reviewing your application, we've decided not to move forward at this time.</p>
          ${note ? `<p><strong>Note:</strong> ${note}</p>` : ''}
          <p>You're welcome to reapply in the future if your circumstances change.</p>
          <p>Best,<br>The ReviewResponder Team</p>
        </div>
      `;
    }

    await resend.emails.send({
      from: FROM_EMAIL,
      to: email,
      subject,
      html,
    });

    res.json({ success: true, message: `Affiliate ${status} test email sent to ${email}` });
  } catch (err) {
    console.error('Test affiliate email error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Send cold emails to leads
app.post('/api/outreach/send-emails', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({
      error: 'RESEND_API_KEY not configured',
      setup: 'Add RESEND_API_KEY to Render environment variables',
    });
  }

  const { limit = 20, campaign = 'main' } = req.body;

  try {
    // Check daily limit
    const campaignConfig = await dbGet('SELECT * FROM outreach_campaigns WHERE name = $1', [
      campaign,
    ]);

    if (!campaignConfig) {
      return res.status(400).json({ error: 'Campaign not found' });
    }

    // Reset daily counter if new day
    const lastReset = new Date(campaignConfig.last_reset);
    const now = new Date();
    if (lastReset.toDateString() !== now.toDateString()) {
      await dbQuery(
        'UPDATE outreach_campaigns SET sent_today = 0, last_reset = NOW() WHERE name = $1',
        [campaign]
      );
      campaignConfig.sent_today = 0;
    }

    const remainingToday = campaignConfig.daily_limit - campaignConfig.sent_today;
    const toSend = Math.min(limit, remainingToday);

    if (toSend <= 0) {
      return res.json({
        success: true,
        message: 'Daily limit reached',
        sent: 0,
        daily_limit: campaignConfig.daily_limit,
      });
    }

    // Get leads ready for first email (have email, no emails sent yet)
    const newLeads = await dbAll(
      `
      SELECT l.* FROM outreach_leads l
      LEFT JOIN outreach_emails e ON l.id = e.lead_id
      WHERE l.email IS NOT NULL
        AND l.status = 'new'
        AND e.id IS NULL
      ORDER BY l.google_reviews_count DESC NULLS LAST
      LIMIT $1
    `,
      [toSend]
    );

    let sent = 0;

    for (const lead of newLeads) {
      try {
        // Use A/B tested subject for sequence 1
        const templateWithAB = await getTemplateForLeadWithABTest(1, lead);
        const template = fillEmailTemplate(templateWithAB, lead);

        // Send email with tracking pixel
        const result = await sendOutreachEmail({
          to: lead.email,
          subject: template.subject,
          html: template.body.replace(/\n/g, '<br>'),
          campaign,
          tags: [{ name: 'sequence', value: '1' }],
        });

        // Log the email with A/B variant
        await dbQuery(
          `
          INSERT INTO outreach_emails
          (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, ab_variant, provider)
          VALUES ($1, $2, 1, $3, $4, 'sent', NOW(), $5, $6, $7)
        `,
          [
            lead.id,
            lead.email,
            template.subject,
            template.body,
            campaign,
            templateWithAB.abVariant,
            result.provider || 'resend',
          ]
        );

        // Update lead status
        await dbQuery('UPDATE outreach_leads SET status = $1 WHERE id = $2', [
          'contacted',
          lead.id,
        ]);

        sent++;
        console.log(`âœ‰ï¸ Sent to ${lead.email} (${lead.business_name})`);

        // Small delay between sends
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Failed to send to ${lead.email}:`, err.message);

        // Mark as bounced if email error
        if (err.message?.includes('bounce') || err.message?.includes('invalid')) {
          await dbQuery('UPDATE outreach_leads SET status = $1 WHERE id = $2', [
            'bounced',
            lead.id,
          ]);
        }
      }
    }

    // Update daily counter
    await dbQuery('UPDATE outreach_campaigns SET sent_today = sent_today + $1 WHERE name = $2', [
      sent,
      campaign,
    ]);

    res.json({
      success: true,
      sent: sent,
      remaining_today: remainingToday - sent,
      daily_limit: campaignConfig.daily_limit,
    });
  } catch (error) {
    console.error('Send emails error:', error);
    res.status(500).json({ error: 'Failed to send emails' });
  }
});

// POST /api/admin/reset-campaign-limit - Reset or increase campaign daily limit
app.post('/api/admin/reset-campaign-limit', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { campaign = 'main', new_limit, reset_counter } = req.body;

  try {
    const updates = [];
    const params = [];
    let paramIndex = 1;

    if (new_limit !== undefined) {
      updates.push(`daily_limit = $${paramIndex++}`);
      params.push(new_limit);
    }

    if (reset_counter) {
      updates.push(`sent_today = 0`);
      updates.push(`last_reset = NOW()`);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'Provide new_limit or reset_counter: true' });
    }

    params.push(campaign);
    await dbQuery(
      `UPDATE outreach_campaigns SET ${updates.join(', ')} WHERE name = $${paramIndex}`,
      params
    );

    const updated = await dbGet('SELECT * FROM outreach_campaigns WHERE name = $1', [campaign]);

    console.log(`ðŸ“§ Campaign ${campaign} updated: limit=${updated.daily_limit}, sent_today=${updated.sent_today}`);

    res.json({
      success: true,
      campaign: updated.name,
      daily_limit: updated.daily_limit,
      sent_today: updated.sent_today,
      remaining: updated.daily_limit - updated.sent_today
    });
  } catch (error) {
    console.error('Reset campaign limit error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==========================================
// ADD LEADS FROM TRIPADVISOR (Claude in Chrome)
// ==========================================
app.post('/api/outreach/add-tripadvisor-leads', async (req, res) => {
  // Auth via header or query param (for Claude in Chrome)
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { leads, send_emails = false, campaign = 'tripadvisor' } = req.body;

  if (!leads || !Array.isArray(leads) || leads.length === 0) {
    return res.status(400).json({ error: 'leads array is required' });
  }

  try {
    const results = {
      added: 0,
      skipped: 0,
      emails_sent: 0,
      errors: [],
    };

    for (const lead of leads) {
      try {
        // Skip if no email
        if (!lead.email) {
          results.skipped++;
          continue;
        }

        // Check if lead has a bad review (for Review Alert emails)
        const hasBadReview =
          lead.worst_review_text && lead.worst_review_rating && lead.worst_review_rating <= 2;

        // Insert or update lead (including review alert fields)
        await dbQuery(
          `
          INSERT INTO outreach_leads
            (business_name, business_type, address, city, country, phone, website,
             google_rating, google_reviews_count, email, source, status,
             worst_review_text, worst_review_rating, worst_review_author, has_bad_review)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
          ON CONFLICT (business_name, city)
          DO UPDATE SET
            email = COALESCE(EXCLUDED.email, outreach_leads.email),
            phone = COALESCE(EXCLUDED.phone, outreach_leads.phone),
            website = COALESCE(EXCLUDED.website, outreach_leads.website),
            google_rating = COALESCE(EXCLUDED.google_rating, outreach_leads.google_rating),
            google_reviews_count = COALESCE(EXCLUDED.google_reviews_count, outreach_leads.google_reviews_count),
            worst_review_text = COALESCE(EXCLUDED.worst_review_text, outreach_leads.worst_review_text),
            worst_review_rating = COALESCE(EXCLUDED.worst_review_rating, outreach_leads.worst_review_rating),
            worst_review_author = COALESCE(EXCLUDED.worst_review_author, outreach_leads.worst_review_author),
            has_bad_review = COALESCE(EXCLUDED.has_bad_review, outreach_leads.has_bad_review)
        `,
          [
            lead.name || lead.business_name,
            lead.type || lead.business_type || 'restaurant',
            lead.address,
            lead.city,
            lead.country || 'US',
            lead.phone,
            lead.website || lead.tripadvisor_url,
            lead.rating || lead.google_rating,
            lead.reviews || lead.google_reviews_count,
            lead.email,
            'tripadvisor',
            'new',
            lead.worst_review_text || null,
            lead.worst_review_rating || null,
            lead.worst_review_author || null,
            hasBadReview,
          ]
        );

        results.added++;

        // Send email immediately if requested
        if (send_emails && resend && lead.email) {
          // Generate AI draft for leads with bad reviews
          let aiDraft = lead.ai_response_draft || null;
          if (hasBadReview && lead.worst_review_text && !aiDraft) {
            console.log(
              `ðŸ“ Generating AI draft for TripAdvisor lead: ${lead.name || lead.business_name}...`
            );
            aiDraft = await generateReviewAlertDraft(
              lead.name || lead.business_name,
              lead.type || lead.business_type || 'restaurant',
              lead.worst_review_text,
              lead.worst_review_rating,
              lead.worst_review_author,
              lead.city || null,
              lead.rating || lead.google_rating || null,
              lead.reviews || lead.google_reviews_count || null
            );
          }

          // Prepare lead data with all review alert fields
          const leadData = {
            ...lead,
            business_name: lead.name || lead.business_name,
            business_type: lead.type || lead.business_type || 'restaurant',
            google_reviews_count: lead.reviews || lead.google_reviews_count,
            has_bad_review: hasBadReview,
            worst_review_text: lead.worst_review_text,
            worst_review_rating: lead.worst_review_rating,
            worst_review_author: lead.worst_review_author,
            ai_response_draft: aiDraft,
          };

          const template = fillEmailTemplate(getTemplateForLead(1, leadData), leadData);
          const emailCampaign = hasBadReview && aiDraft ? 'tripadvisor-review-alert' : campaign;

          try {
            const emailResult = await sendOutreachEmail({
              to: lead.email,
              subject: template.subject,
              html: template.body.replace(/\n/g, '<br>'),
              campaign: emailCampaign,
              tags: [
                { name: 'source', value: 'tripadvisor' },
                { name: 'sequence', value: '1' },
              ],
            });
            results.emails_sent++;

            // Log the sent email and save AI draft
            const insertedLead = await dbGet(
              'SELECT id FROM outreach_leads WHERE business_name = $1 AND city = $2',
              [lead.name || lead.business_name, lead.city]
            );
            if (insertedLead) {
              // Save AI draft if generated
              if (aiDraft) {
                await dbQuery('UPDATE outreach_leads SET ai_response_draft = $1 WHERE id = $2', [
                  aiDraft,
                  insertedLead.id,
                ]);
              }

              await dbQuery(
                `
                INSERT INTO outreach_emails
                  (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, provider)
                VALUES ($1, $2, 1, $3, $4, 'sent', NOW(), $5, $6)
              `,
                [
                  insertedLead.id,
                  lead.email,
                  template.subject,
                  template.body,
                  emailCampaign,
                  emailResult.provider || 'resend',
                ]
              );

              await dbQuery('UPDATE outreach_leads SET status = $1 WHERE id = $2', [
                'contacted',
                insertedLead.id,
              ]);
            }
          } catch (emailError) {
            results.errors.push(`Email failed for ${lead.name}: ${emailError.message}`);
          }
        }
      } catch (leadError) {
        results.errors.push(`Failed to add ${lead.name}: ${leadError.message}`);
      }
    }

    console.log(
      `TripAdvisor leads processed: ${results.added} added, ${results.skipped} skipped, ${results.emails_sent} emails sent`
    );

    res.json({
      success: true,
      ...results,
    });
  } catch (error) {
    console.error('Add TripAdvisor leads error:', error);
    res.status(500).json({ error: 'Failed to add leads' });
  }
});

// ==========================================
// CRON: Send emails to new TripAdvisor leads
// Called daily by cron-job.org to send cold emails
// ==========================================
app.get('/api/cron/send-tripadvisor-emails', async (req, res) => {
  const cronSecret = req.query.secret || req.query.key;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'Email service not configured' });
  }

  try {
    // Get all new leads from TripAdvisor that haven't been contacted
    const newLeads = await dbAll(`
      SELECT * FROM outreach_leads
      WHERE source = 'tripadvisor'
      AND status = 'new'
      AND email IS NOT NULL
      ORDER BY created_at ASC
      LIMIT 50
    `);

    if (newLeads.length === 0) {
      return res.json({ ok: true, sent: 0, msg: 'no leads' });
    }

    const results = {
      total: newLeads.length,
      emails_sent: 0,
      errors: [],
    };

    for (const lead of newLeads) {
      try {
        // Demo-Generation fÃ¼r TripAdvisor (wie Daily Outreach)
        if (!lead.demo_url && lead.has_bad_review) {
          console.log(`ðŸ“ Generating demo for TripAdvisor lead: ${lead.business_name}...`);

          try {
            const demoResult = await generateDemoForLead(lead);

            if (demoResult && demoResult.first_ai_response) {
              // Demo erfolgreich - Update Lead
              await pool.query(
                `UPDATE outreach_leads SET
                  demo_url = $1, demo_token = $2, ai_response_draft = $3,
                  worst_review_rating = $4, worst_review_text = $5,
                  worst_review_author = $6, has_bad_review = TRUE
                WHERE id = $7`,
                [
                  demoResult.demo_url,
                  demoResult.demo_token,
                  demoResult.first_ai_response,
                  demoResult.first_review?.rating,
                  demoResult.first_review?.text,
                  demoResult.first_review?.author,
                  lead.id,
                ]
              );

              // Update lokales lead Objekt fÃ¼r Template-Selection
              lead.demo_url = demoResult.demo_url;
              lead.demo_token = demoResult.demo_token;
              lead.ai_response_draft = demoResult.first_ai_response;
              lead.worst_review_rating = demoResult.first_review?.rating;
              lead.worst_review_text = demoResult.first_review?.text;
              lead.worst_review_author = demoResult.first_review?.author;
              console.log(`âœ… Demo generated for ${lead.business_name}: ${demoResult.demo_url}`);
            }
          } catch (err) {
            console.error(`Demo generation failed for ${lead.business_name}:`, err.message);
          }

          // Fallback: wenn Demo fehlgeschlagen und kein ai_response_draft
          if (!lead.ai_response_draft && lead.worst_review_text) {
            console.log(`ðŸ“ Fallback: Generating AI draft for ${lead.business_name}...`);
            const aiDraft = await generateReviewAlertDraft(
              lead.business_name,
              lead.business_type,
              lead.worst_review_text,
              lead.worst_review_rating,
              lead.worst_review_author,
              lead.city || null,
              lead.google_rating || null,
              lead.google_reviews_count || null
            );
            if (aiDraft) {
              lead.ai_response_draft = aiDraft;
              await dbQuery('UPDATE outreach_leads SET ai_response_draft = $1 WHERE id = $2', [
                aiDraft,
                lead.id,
              ]);
            }
          }
        }

        // Get template for first email (uses review alert template if has_bad_review)
        const template = fillEmailTemplate(getTemplateForLead(1, lead), lead);
        const emailCampaign =
          lead.has_bad_review && lead.ai_response_draft
            ? 'tripadvisor-review-alert'
            : 'tripadvisor-auto';

        // Send email with tracking pixel
        const emailResult = await sendOutreachEmail({
          to: lead.email,
          subject: template.subject,
          html: template.body.replace(/\n/g, '<br>'),
          campaign: emailCampaign,
          tags: [
            { name: 'source', value: 'tripadvisor' },
            { name: 'sequence', value: '1' },
          ],
        });

        // Update lead status
        await dbQuery(
          `
          UPDATE outreach_leads
          SET status = 'contacted'
          WHERE id = $1
        `,
          [lead.id]
        );

        // Log the email
        await dbQuery(
          `
          INSERT INTO outreach_emails (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, provider)
          VALUES ($1, $2, 1, $3, $4, 'sent', NOW(), $5, $6)
        `,
          [
            lead.id,
            lead.email,
            template.subject,
            template.body,
            emailCampaign,
            emailResult.provider || 'resend',
          ]
        );

        results.emails_sent++;
        console.log(`ðŸ“§ TripAdvisor email sent to: ${lead.email} (${lead.business_name})`);

        // Small delay between emails
        await new Promise(resolve => setTimeout(resolve, 500));
      } catch (emailError) {
        results.errors.push(`Failed to email ${lead.business_name}: ${emailError.message}`);
        console.error(`Email error for ${lead.email}:`, emailError.message);
      }
    }

    console.log(
      `âœ… TripAdvisor first emails complete: ${results.emails_sent}/${results.total} emails sent`
    );

    // ==========================================
    // FOLLOW-UP EMAILS (4 days after first email)
    // ==========================================
    const followupResults = { sent: 0, errors: [] };

    // Find leads that:
    // 1. Got first email (sequence_number = 1) more than 4 days ago
    // 2. Haven't received follow-up yet (no sequence_number = 2)
    // 3. Haven't replied/clicked (status still 'contacted')
    const followupLeads = await dbAll(`
      SELECT DISTINCT ol.*, oe.sent_at as first_email_sent
      FROM outreach_leads ol
      JOIN outreach_emails oe ON oe.lead_id = ol.id
      WHERE ol.source = 'tripadvisor'
        AND ol.status = 'contacted'
        AND oe.sequence_number = 1
        AND oe.sent_at < NOW() - INTERVAL '4 days'
        AND NOT EXISTS (
          SELECT 1 FROM outreach_emails oe2
          WHERE oe2.lead_id = ol.id AND oe2.sequence_number = 2
        )
      ORDER BY oe.sent_at ASC
      LIMIT 20
    `);

    if (followupLeads.length > 0) {
      console.log(`ðŸ“§ Sending ${followupLeads.length} TripAdvisor follow-up emails...`);

      for (const lead of followupLeads) {
        try {
          // Get owner name or business name
          const ownerName = getOwnerName(lead.business_name);
          const firstName = ownerName.split(' ')[0] || 'there';

          const subject = `Re: ${lead.business_name} - quick question`;
          const followupBody = `Hey ${firstName},

Quick follow-up on my last email - did you get a chance to check out the AI review response tool?

I noticed ${lead.business_name} has ${lead.google_reviews_count || 'several'} reviews on Google. With our tool, you could respond to all of them in minutes instead of hours.

Here's a personalized demo showing how it works for ${lead.business_name}:
${lead.demo_url || 'https://tryreviewresponder.com?ref=tripadvisor-followup'}

20 free responses, no credit card needed. Takes 30 seconds to try.

Let me know if you have any questions!

Berend`;

          await sendOutreachEmail({
            to: lead.email,
            subject,
            html: followupBody.replace(/\n/g, '<br>'),
            campaign: 'tripadvisor-followup',
            tags: [
              { name: 'source', value: 'tripadvisor' },
              { name: 'sequence', value: '2' },
            ],
          });

          // Log the follow-up email
          await dbQuery(
            `
            INSERT INTO outreach_emails (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, provider)
            VALUES ($1, $2, 2, $3, $4, 'sent', NOW(), 'tripadvisor-followup', 'resend')
          `,
            [lead.id, lead.email, subject, followupBody]
          );

          followupResults.sent++;
          console.log(`ðŸ“§ TripAdvisor follow-up sent to: ${lead.email} (${lead.business_name})`);

          // Delay between emails
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (followupError) {
          followupResults.errors.push(
            `Followup failed for ${lead.business_name}: ${followupError.message}`
          );
          console.error(`Follow-up error for ${lead.email}:`, followupError.message);
        }
      }
    }

    console.log(
      `âœ… TripAdvisor cron complete: ${results.emails_sent} first, ${followupResults.sent} followups`
    );

    // Minimal response for cron-job.org (has size limit)
    res.json({
      ok: true,
      first: results.emails_sent,
      followup: followupResults.sent,
      err: results.errors.length + followupResults.errors.length,
    });
  } catch (error) {
    console.error('TripAdvisor cron error:', error);
    res.status(500).json({ ok: false, err: error.message?.slice(0, 100) });
  }
});

// ==========================================
// IMPORT SCRAPED LEADS (from Memory MCP or manual scraping)
// ==========================================
app.post('/api/outreach/import-scraped-leads', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { leads } = req.body;

  if (!leads || !Array.isArray(leads) || leads.length === 0) {
    return res.status(400).json({ error: 'leads array is required' });
  }

  try {
    const results = {
      imported: 0,
      skipped: 0,
      needs_enrichment: 0,
      errors: [],
    };

    for (const lead of leads) {
      try {
        // Parse Memory MCP format or direct format
        const businessName =
          lead.business_name ||
          lead.name ||
          lead.observations?.find(o => o.startsWith('business_name:'))?.split(': ')[1];
        const city =
          lead.city ||
          lead.observations?.find(o => o.startsWith('city:'))?.split(': ')[1] ||
          'Unknown';
        const source =
          lead.source ||
          lead.observations?.find(o => o.startsWith('source:'))?.split(': ')[1] ||
          'scraped';
        const email =
          lead.email || lead.observations?.find(o => o.startsWith('email:'))?.split(': ')[1];
        const phone =
          lead.phone || lead.observations?.find(o => o.startsWith('phone:'))?.split(': ')[1];
        const address =
          lead.address || lead.observations?.find(o => o.startsWith('address:'))?.split(': ')[1];
        const businessType =
          lead.business_type ||
          lead.observations?.find(o => o.startsWith('business_type:'))?.split(': ')[1] ||
          'business';
        const rating =
          lead.rating ||
          parseFloat(lead.observations?.find(o => o.startsWith('rating:'))?.split(': ')[1]) ||
          null;
        const reviewerName =
          lead.reviewer || lead.observations?.find(o => o.startsWith('reviewer:'))?.split(': ')[1];
        const painPoints =
          lead.pain_points ||
          lead.pain_point ||
          lead.observations
            ?.filter(o => o.startsWith('pain_point'))
            ?.map(o => o.split(': ')[1])
            ?.join('; ');
        const competitor =
          lead.competitor ||
          lead.observations?.find(o => o.startsWith('competitor:'))?.split(': ')[1];

        if (!businessName && !reviewerName) {
          results.skipped++;
          results.errors.push(`Skipped lead: no business_name or reviewer`);
          continue;
        }

        // For G2/competitor leads (reviewer names without business), mark for LinkedIn enrichment
        if (reviewerName && !email && !businessName) {
          await dbQuery(
            `
            INSERT INTO outreach_leads
              (business_name, contact_name, source, status, business_type, city)
            VALUES ($1, $2, $3, 'needs_enrichment', $4, $5)
            ON CONFLICT (business_name, city) DO NOTHING
          `,
            [
              `${competitor || 'Unknown'} - ${reviewerName}`,
              reviewerName,
              source,
              `competitor_${competitor || 'unknown'}`,
              city,
            ]
          );
          results.needs_enrichment++;
          continue;
        }

        // Insert or update lead
        await dbQuery(
          `
          INSERT INTO outreach_leads
            (business_name, business_type, address, city, phone, website,
             google_rating, email, source, status, contact_name)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
          ON CONFLICT (business_name, city)
          DO UPDATE SET
            email = COALESCE(EXCLUDED.email, outreach_leads.email),
            phone = COALESCE(EXCLUDED.phone, outreach_leads.phone),
            contact_name = COALESCE(EXCLUDED.contact_name, outreach_leads.contact_name),
            google_rating = COALESCE(EXCLUDED.google_rating, outreach_leads.google_rating)
        `,
          [
            businessName || `${competitor} Lead - ${reviewerName}`,
            businessType,
            address,
            city,
            phone,
            lead.website,
            rating,
            email,
            source,
            email ? 'new' : 'needs_enrichment',
            reviewerName,
          ]
        );

        if (email) {
          results.imported++;
        } else {
          results.needs_enrichment++;
        }
      } catch (err) {
        results.errors.push(`Error: ${err.message}`);
      }
    }

    res.json({
      success: true,
      message: `Imported ${results.imported} leads, ${results.needs_enrichment} need LinkedIn enrichment`,
      ...results,
    });
  } catch (error) {
    console.error('Import scraped leads error:', error);
    res.status(500).json({ error: 'Import failed', message: error.message });
  }
});

// ==========================================
// LINKEDIN ENRICHMENT - Find contact info for leads
// ==========================================
app.post('/api/outreach/linkedin-enrich', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Get leads that need enrichment
    const leadsToEnrich = await dbAll(`
      SELECT id, business_name, contact_name, business_type, city
      FROM outreach_leads
      WHERE status = 'needs_enrichment'
        AND contact_name IS NOT NULL
        AND email IS NULL
      ORDER BY created_at DESC
      LIMIT 50
    `);

    if (leadsToEnrich.length === 0) {
      return res.json({
        success: true,
        message: 'No leads need enrichment',
        leads: [],
      });
    }

    // Return leads formatted for LinkedIn search
    // Claude with Chrome MCP can use these to search LinkedIn
    const searchQueries = leadsToEnrich.map(lead => ({
      id: lead.id,
      name: lead.contact_name,
      business_type: lead.business_type,
      city: lead.city,
      linkedin_search_url: `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(lead.contact_name)}&origin=GLOBAL_SEARCH_HEADER`,
    }));

    res.json({
      success: true,
      message: `${leadsToEnrich.length} leads need LinkedIn enrichment`,
      leads: searchQueries,
    });
  } catch (error) {
    console.error('LinkedIn enrich error:', error);
    res.status(500).json({ error: 'Enrichment failed', message: error.message });
  }
});

// Update lead with LinkedIn data
app.post('/api/outreach/linkedin-update', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { lead_id, email, linkedin_url, company, title } = req.body;

  if (!lead_id) {
    return res.status(400).json({ error: 'lead_id is required' });
  }

  try {
    await dbQuery(
      `
      UPDATE outreach_leads
      SET email = COALESCE($1, email),
          website = COALESCE($2, website),
          business_name = COALESCE($3, business_name),
          status = CASE WHEN $1 IS NOT NULL THEN 'new' ELSE status END
      WHERE id = $4
    `,
      [email, linkedin_url, company, lead_id]
    );

    res.json({
      success: true,
      message: email ? 'Lead updated with email - ready for outreach' : 'Lead updated',
    });
  } catch (error) {
    console.error('LinkedIn update error:', error);
    res.status(500).json({ error: 'Update failed', message: error.message });
  }
});

// Send follow-up emails (sequence 2 and 3)
app.post('/api/outreach/send-followups', async (req, res) => {
  const adminKey = req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend) {
    return res.status(500).json({ error: 'RESEND_API_KEY not configured' });
  }

  try {
    // Find leads needing follow-up 2 (3 days after sequence 1, no open)
    const needsFollowup2 = await dbAll(`
      SELECT l.*, e.sent_at as last_email_sent
      FROM outreach_leads l
      JOIN outreach_emails e ON l.id = e.lead_id
      WHERE e.sequence_number = 1
        AND e.sent_at < NOW() - INTERVAL '3 days'
        AND e.opened_at IS NULL
        AND l.status = 'contacted'
        AND NOT EXISTS (
          SELECT 1 FROM outreach_emails e2
          WHERE e2.lead_id = l.id AND e2.sequence_number = 2
        )
      LIMIT 20
    `);

    // Find leads needing follow-up 3 (7 days after sequence 2, no reply)
    const needsFollowup3 = await dbAll(`
      SELECT l.*, e.sent_at as last_email_sent
      FROM outreach_leads l
      JOIN outreach_emails e ON l.id = e.lead_id
      WHERE e.sequence_number = 2
        AND e.sent_at < NOW() - INTERVAL '4 days'
        AND e.replied_at IS NULL
        AND l.status = 'contacted'
        AND NOT EXISTS (
          SELECT 1 FROM outreach_emails e2
          WHERE e2.lead_id = l.id AND e2.sequence_number = 3
        )
      LIMIT 20
    `);

    let sent2 = 0,
      sent3 = 0;

    // Send sequence 2
    for (const lead of needsFollowup2) {
      try {
        const template = fillEmailTemplate(getTemplateForLead(2, lead), lead);

        const emailResult = await sendOutreachEmail({
          to: lead.email,
          subject: template.subject,
          html: template.body.replace(/\n/g, '<br>'),
          campaign: 'main',
          tags: [{ name: 'sequence', value: '2' }],
        });

        await dbQuery(
          `
          INSERT INTO outreach_emails
          (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, provider)
          VALUES ($1, $2, 2, $3, $4, 'sent', NOW(), 'main', $5)
        `,
          [lead.id, lead.email, template.subject, template.body, emailResult.provider || 'resend']
        );

        sent2++;
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Follow-up 2 failed for ${lead.email}:`, err.message);
      }
    }

    // Send sequence 3
    for (const lead of needsFollowup3) {
      try {
        const template = fillEmailTemplate(getTemplateForLead(3, lead), lead);

        const emailResult = await sendOutreachEmail({
          to: lead.email,
          subject: template.subject,
          html: template.body.replace(/\n/g, '<br>'),
          campaign: 'main',
          tags: [{ name: 'sequence', value: '3' }],
        });

        await dbQuery(
          `
          INSERT INTO outreach_emails
          (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, provider)
          VALUES ($1, $2, 3, $3, $4, 'sent', NOW(), 'main', $5)
        `,
          [lead.id, lead.email, template.subject, template.body, emailResult.provider || 'resend']
        );

        // Mark as completed sequence
        await dbQuery('UPDATE outreach_leads SET status = $1 WHERE id = $2', [
          'sequence_completed',
          lead.id,
        ]);

        sent3++;
        await new Promise(r => setTimeout(r, 500));
      } catch (err) {
        console.error(`Follow-up 3 failed for ${lead.email}:`, err.message);
      }
    }

    res.json({
      success: true,
      followup2_sent: sent2,
      followup3_sent: sent3,
      total_sent: sent2 + sent3,
    });
  } catch (error) {
    console.error('Follow-up error:', error);
    res.status(500).json({ error: 'Failed to send follow-ups' });
  }
});

// ==========================================
// CRON ENDPOINTS (For Render Scheduled Jobs)
// ==========================================

// ============== AUTO BLOG GENERATION WITH GEMINI ==============

// Blog topics organized by category (for SEO Auto-Pilot)
const AUTO_BLOG_TOPICS = [
  {
    category: 'Review Response',
    topics: [
      'How to Respond to a 1-Star Review Without Losing Customers',
      'The Psychology Behind Negative Reviews: What Customers Really Want',
      '7 Response Templates That Turn Angry Reviewers Into Loyal Customers',
      'How Fast Should You Respond to Reviews? The Data Says...',
      'The Art of Apologizing in Business Reviews',
    ],
  },
  {
    category: 'Reputation Management',
    topics: [
      'Building a 5-Star Reputation from Scratch',
      'How Negative Reviews Actually Help Your Business When Handled Right',
      'The Hidden Cost of Ignoring Online Reviews',
      'Local SEO: Why Reviews Are Your Secret Weapon',
      'Managing Reviews Across Multiple Platforms',
    ],
  },
  {
    category: 'Industry Guides',
    topics: [
      'Restaurant Review Management: A Complete Guide',
      'Hotel Review Response Strategies That Work',
      'Retail Store Reviews: Best Practices for 2025',
      'Medical Practice Reviews: HIPAA-Compliant Response Guide',
      'Automotive Dealer Review Management',
    ],
  },
  {
    category: 'AI and Automation',
    topics: [
      'How AI is Transforming Customer Review Management',
      'The Ethics of AI-Generated Review Responses',
      'When to Use AI vs Human Review Responses',
      'Personalizing AI Responses: Best Practices',
      'The Future of Automated Reputation Management',
    ],
  },
  {
    category: 'Customer Psychology',
    topics: [
      'Why Customers Leave Reviews And Why Most Dont',
      'The Emotional Journey of Writing a Negative Review',
      'How to Encourage More Positive Reviews Ethically',
      'Understanding Review Fatigue and How to Combat It',
      'The Role of Social Proof in Modern Business',
    ],
  },
];

// GET /api/cron/generate-blog-article - Auto-generate SEO blog article
// Call via cron-job.org: Mon/Wed/Fri at 6:00 UTC
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/generate-blog-article', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!gemini) {
    return res.status(500).json({ error: 'Gemini API not configured. Set GEMINI_API_KEY.' });
  }

  console.log('Starting auto blog generation with Gemini 2.5 Pro...');

  try {
    // Get count of auto-generated articles to rotate through topics
    const countResult = await dbGet(
      'SELECT COUNT(*) as count FROM blog_articles WHERE is_auto_generated = TRUE'
    );
    const articleCount = parseInt(countResult.count) || 0;

    // Flatten topics with categories
    const allTopics = AUTO_BLOG_TOPICS.flatMap(cat =>
      cat.topics.map(t => ({ topic: t, category: cat.category }))
    );

    // Rotate through topics
    const topicIndex = articleCount % allTopics.length;
    const { topic, category } = allTopics[topicIndex];

    // Check if we already have this exact topic
    const existing = await dbGet('SELECT id FROM blog_articles WHERE title ILIKE $1', [
      `%${topic.substring(0, 30)}%`,
    ]);

    if (existing) {
      console.log(`Topic already exists, skipping: ${topic}`);
      return res.json({
        skipped: true,
        message: 'Topic already exists',
        topic,
      });
    }

    // Generate article using Gemini 3 Pro with Google Search grounding
    const model = gemini.getGenerativeModel({
      model: 'gemini-3-pro-preview',
      tools: [{ googleSearch: {} }],
    });

    const prompt = `You are an expert SEO content writer for ReviewResponder, a SaaS tool that helps businesses respond to customer reviews using AI.

Write a comprehensive, SEO-optimized blog article about: "${topic}"

IMPORTANT: Use Google Search to find current statistics, trends, and data to make the article authoritative and up-to-date.

Requirements:
- Length: Approximately 1200-1500 words
- Tone: Professional yet approachable, helpful and actionable
- Include relevant keywords naturally
- Structure with:
  - An engaging introduction that gets straight to the point
  - Clear headings (use ## for main sections, ### for subsections)
  - Bullet points or numbered lists where appropriate
  - Practical, actionable tips businesses can implement today
  - A conclusion with a call-to-action mentioning ReviewResponder
- Include 1-2 natural mentions of ReviewResponder as a solution (not salesy)
- Include statistics or data points where relevant
- IMPORTANT: For every statistic, link directly to the source using markdown: [Study Name](URL) or "According to [BrightLocal](https://url)..."
- At the end of the article, include a "## Sources" section listing all referenced URLs
- Make it valuable for small to medium business owners

IMPORTANT: Include a subtle CTA like:
- "Tools like ReviewResponder can help automate this process..."
- "With AI-powered solutions like ReviewResponder, responding to reviews takes seconds..."
- "ReviewResponder's Chrome extension makes this even easier by..."

WRITING STYLE - AVOID AI SLOP:
Never use these phrases: "Here's the thing", "The uncomfortable truth is", "It turns out", "Let me be clear", "Full stop", "Period", "Let that sink in", "This matters because", "Make no mistake", "Here's why that matters", "Navigate", "Unpack", "Lean into", "Landscape", "Game-changer", "Double down", "Deep dive", "At its core", "In today's world", "It's worth noting", "Interestingly", "Importantly", "At the end of the day", "In a world where".

Avoid these structures:
- "Not because X. Because Y." binary contrasts
- "[X] isn't the problem. [Y] is." framing
- Opening with "What if [reframe]?"
- Closing paragraphs with punchy one-liners
- Three consecutive sentences of matching length
- Em-dashes before reveals
- Immediate question-answers
- Starting sentences with "Look," or "So,"
- DO NOT start with horizontal rules (*** or ---)

Write directly, trust the reader, avoid explaining obvious things.

Output Format:
Line 1: The article title (without any prefix like "Title:")
Line 2: A compelling meta description (150-160 characters, without prefix)
Line 3: Empty line
Lines 4+: The full article content in Markdown format (start directly with content, no horizontal rules).`;

    const result = await model.generateContent(prompt);
    const fullResponse = result.response.text();

    // Log API call for cost tracking (Gemini doesn't provide exact token counts in response)
    logApiCall({
      provider: 'google',
      model: 'gemini-3-pro-preview',
      endpoint: '/api/cron/generate-blog-article',
      metadata: { topic, promptLength: prompt.length, responseLength: fullResponse.length },
    });

    // Parse the response
    const lines = fullResponse.split('\n');
    const title = lines[0]
      .replace(/^#\s*/, '')
      .replace(/^\*\*/, '')
      .replace(/\*\*$/, '')
      .replace(/^Title:\s*/i, '')
      .trim();
    const metaDescription = lines[1]
      .replace(/^Meta Description:\s*/i, '')
      .replace(/^Description:\s*/i, '')
      .trim();
    const rawContent = lines.slice(3).join('\n').trim();

    // Apply AI slop filter to clean up typical AI phrases
    const content = cleanAISlop(rawContent);

    const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
    const readTimeMinutes = Math.ceil(wordCount / 200);
    const slug = generateSlug(title);

    // Add internal linking to related articles (SEO boost)
    let contentWithLinks = content;
    try {
      const relatedArticles = await dbAll(
        `
        SELECT title, slug FROM blog_articles
        WHERE is_published = TRUE
          AND category = $1
          AND slug IS NOT NULL
        ORDER BY published_at DESC
        LIMIT 3
      `,
        [category]
      );

      if (relatedArticles.length > 0) {
        const relatedSection = `\n\n---\n\n## Related Articles\n\n${relatedArticles
          .map(a => `- [${a.title}](/blog/${a.slug})`)
          .join('\n')}\n`;
        contentWithLinks = content + relatedSection;
      }
    } catch (linkError) {
      console.log('Internal linking skipped:', linkError.message);
    }

    // Save to database (auto-published)
    const insertResult = await dbQuery(
      `INSERT INTO blog_articles
       (user_id, title, content, meta_description, keywords, topic, tone,
        word_count, slug, is_published, published_at, category,
        read_time_minutes, is_auto_generated, author_name)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
       RETURNING id, slug`,
      [
        1, // System user ID
        title,
        contentWithLinks,
        metaDescription,
        topic.toLowerCase().replace(/[^a-z0-9]+/g, ', '),
        topic,
        'informative',
        wordCount,
        slug,
        true, // Auto-publish
        new Date(),
        category,
        readTimeMinutes,
        true,
        'ReviewResponder Team',
      ]
    );

    console.log(`Blog auto-generated: "${title}" (${slug})`);

    // Ping Google to re-crawl sitemap (fire and forget)
    try {
      fetch(
        'https://www.google.com/ping?sitemap=https://tryreviewresponder.com/sitemap-blog.xml'
      ).catch(() => {});
      console.log('Pinged Google about sitemap update');
    } catch (e) {
      // Ignore ping errors
    }

    res.json({
      success: true,
      article: {
        id: insertResult.rows[0].id,
        slug: insertResult.rows[0].slug,
        title,
        category,
        wordCount,
        readTimeMinutes,
      },
    });
  } catch (error) {
    console.error('Auto-generate blog error:', error);
    res.status(500).json({ error: 'Failed to generate article', details: error.message });
  }
});

// Daily automation: scrape + find emails + send
// Set up as Render Cron Job: 0 9 * * * (9 AM UTC daily)
app.get('/api/cron/daily-outreach', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  console.log('ðŸš€ Starting daily outreach automation...');

  // Optional query params to override city/industry (for manual triggering)
  const overrideCity = req.query.city;
  const overrideIndustry = req.query.industry;

  const results = {
    scraping: null,
    email_finding: null,
    sending: null,
    followups: null,
  };

  try {
    // Step 1: Scrape new leads from multiple cities/industries
    const cities = [
      // US Cities (20)
      'New York',
      'Los Angeles',
      'Chicago',
      'Houston',
      'Miami',
      'Phoenix',
      'Philadelphia',
      'San Antonio',
      'San Diego',
      'Dallas',
      'San Jose',
      'Austin',
      'Jacksonville',
      'San Francisco',
      'Seattle',
      'Denver',
      'Boston',
      'Las Vegas',
      'Portland',
      'Atlanta',
      // UK & Ireland (2)
      'London',
      'Dublin',
      // DACH Region (22)
      'Berlin',
      'MÃ¼nchen',
      'Hamburg',
      'Frankfurt',
      'KÃ¶ln',
      'Stuttgart',
      'DÃ¼sseldorf',
      'Wien',
      'ZÃ¼rich',
      'Genf',
      'Leipzig',
      'Dresden',
      'Hannover',
      'NÃ¼rnberg',
      'Bremen',
      'Essen',
      'Salzburg',
      'Graz',
      'Linz',
      'Innsbruck',
      'Basel',
      'Bern',
      // Benelux (2)
      'Amsterdam',
      'BrÃ¼ssel',
    ];
    const industries = [
      'restaurant',
      'hotel',
      'dental office',
      'law firm',
      'auto repair shop',
      'hair salon',
      'gym',
      'real estate agency',
      'medical clinic',
      'retail store',
      // Added 13.01.2026
      'spa',
      'veterinary clinic',
      'physiotherapy',
      'accounting firm',
      // Added 14.01.2026
      'bakery',
      'coffee shop',
      'car dealership',
      'optician',
      'pharmacy',
      'florist',
    ];

    let totalScraped = 0;

    // Pick city and industry based on date (better rotation across all cities)
    // Using day of year for city, day of month for industry
    // Can be overridden via query params: ?city=MÃ¼nchen&industry=restaurant
    const dayOfYear = Math.floor(
      (new Date() - new Date(new Date().getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)
    );
    const todayCity = overrideCity || cities[dayOfYear % cities.length];
    const todayIndustry = overrideIndustry || industries[new Date().getDate() % industries.length];

    if (process.env.GOOGLE_PLACES_API_KEY) {
      const scrapeUrl = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(todayIndustry + ' in ' + todayCity)}&key=${process.env.GOOGLE_PLACES_API_KEY}`;

      try {
        const response = await fetch(scrapeUrl);
        const data = await response.json();

        // Log Google Places API call (text search)
        logApiCall({
          provider: 'google_places',
          endpoint: '/api/cron/daily-outreach',
          metadata: {
            type: 'textsearch',
            city: todayCity,
            industry: todayIndustry,
            resultsCount: data.results?.length || 0,
          },
        });

        if (data.results) {
          for (const place of data.results.slice(0, 30)) {
            // Reduced to 30 to save API costs
            try {
              // Fetch Place Details including reviews for personalized outreach
              const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${place.place_id}&fields=name,formatted_address,formatted_phone_number,website,rating,user_ratings_total,reviews&key=${process.env.GOOGLE_PLACES_API_KEY}`;
              const detailsResponse = await fetch(detailsUrl);
              const details = await detailsResponse.json();

              if (details.status === 'OK') {
                const result = details.result;

                // Find worst review (1-2 stars) for personalized outreach
                let worstReview = null;
                if (result.reviews && result.reviews.length > 0) {
                  const badReviews = result.reviews.filter(r => r.rating <= 2);
                  if (badReviews.length > 0) {
                    worstReview = badReviews.reduce((worst, current) =>
                      (current.text?.length || 0) > (worst.text?.length || 0) ? current : worst
                    );
                  }
                }

                await dbQuery(
                  `
                  INSERT INTO outreach_leads (business_name, business_type, city, address, phone, website, google_rating, google_reviews_count, source, worst_review_text, worst_review_rating, worst_review_author, has_bad_review)
                  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'google_places', $9, $10, $11, $12)
                  ON CONFLICT (business_name, city) DO UPDATE SET
                    website = COALESCE(EXCLUDED.website, outreach_leads.website),
                    phone = COALESCE(EXCLUDED.phone, outreach_leads.phone),
                    google_rating = COALESCE(EXCLUDED.google_rating, outreach_leads.google_rating),
                    google_reviews_count = COALESCE(EXCLUDED.google_reviews_count, outreach_leads.google_reviews_count),
                    worst_review_text = COALESCE(EXCLUDED.worst_review_text, outreach_leads.worst_review_text),
                    worst_review_rating = COALESCE(EXCLUDED.worst_review_rating, outreach_leads.worst_review_rating),
                    worst_review_author = COALESCE(EXCLUDED.worst_review_author, outreach_leads.worst_review_author),
                    has_bad_review = COALESCE(EXCLUDED.has_bad_review, outreach_leads.has_bad_review)
                `,
                  [
                    result.name,
                    todayIndustry,
                    todayCity,
                    result.formatted_address || null,
                    result.formatted_phone_number || null,
                    result.website || null,
                    result.rating || null,
                    result.user_ratings_total || null,
                    worstReview?.text || null,
                    worstReview?.rating || null,
                    worstReview?.author_name || null,
                    worstReview !== null,
                  ]
                );
                totalScraped++;
              }

              // Rate limiting
              await new Promise(r => setTimeout(r, 200));
            } catch (e) {
              console.error('Place details error:', e.message);
            }
          }
        }
      } catch (e) {
        console.error('Scrape error:', e.message);
      }
    }

    results.scraping = { leads_added: totalScraped, city: todayCity, industry: todayIndustry };

    // Step 1.5: Find website/domain for G2 leads without website (Clearbit Autocomplete - FREE)
    const leadsNeedingDomain = await dbAll(`
      SELECT id, business_name FROM outreach_leads
      WHERE website IS NULL AND lead_type = 'g2_competitor'
      LIMIT 10
    `);

    let domainsFound = 0;

    for (const lead of leadsNeedingDomain) {
      try {
        // Clearbit Autocomplete API - FREE, no API key needed
        const clearbitUrl = `https://autocomplete.clearbit.com/v1/companies/suggest?query=${encodeURIComponent(lead.business_name)}`;
        const response = await fetch(clearbitUrl);
        const companies = await response.json();

        if (companies && companies.length > 0 && companies[0].domain) {
          const domain = companies[0].domain;
          const website = `https://${domain}`;
          await dbQuery('UPDATE outreach_leads SET website = $1 WHERE id = $2', [website, lead.id]);
          console.log(`ðŸ” Found domain for ${lead.business_name}: ${domain}`);
          domainsFound++;
        }

        await new Promise(r => setTimeout(r, 300)); // Rate limiting
      } catch (e) {
        console.error(`Domain lookup error for ${lead.business_name}:`, e.message);
      }
    }

    results.domain_finding = { checked: leadsNeedingDomain.length, found: domainsFound };

    // Step 2: Find emails for leads without them (multi-fallback: Scraper â†’ Pattern Guess â†’ Snov.io â†’ Hunter.io)
    const leadsNeedingEmail = await dbAll(`
      SELECT id, business_name, website, lead_type, contact_name FROM outreach_leads
      WHERE email IS NULL AND website IS NOT NULL
      LIMIT 30
    `);

    const emailStats = {
      personal_generated: 0, // NEU: Personal emails from team member names
      website_scraper: 0,
      pattern_guess: 0,
      'snov.io': 0,
      'hunter.io': 0,
    };

    for (const lead of leadsNeedingEmail) {
      try {
        // Use combined email finder with all fallbacks
        const result = await findEmailForLead(lead);

        if (result?.email) {
          // Update lead with found email
          const updateFields = ['email = $1', 'email_source = $2'];
          const updateValues = [result.email, result.source, lead.id];

          // If Hunter found contact name, save it too
          if (result.contactName) {
            updateFields.push('contact_name = COALESCE(contact_name, $4)');
            updateValues.splice(3, 0, result.contactName);
          }

          await dbQuery(
            `UPDATE outreach_leads SET ${updateFields.join(', ')} WHERE id = $3`,
            updateValues
          );

          // Track source stats
          emailStats[result.source] = (emailStats[result.source] || 0) + 1;
          console.log(
            `âœ… Found email for ${lead.business_name}: ${result.email} (${result.source})`
          );
        }

        // Rate limiting between leads
        await new Promise(r => setTimeout(r, 300));
      } catch (e) {
        console.error(`Email finding error for ${lead.business_name}:`, e.message);
      }
    }

    const totalFound = Object.values(emailStats).reduce((a, b) => a + b, 0);
    results.email_finding = {
      checked: leadsNeedingEmail.length,
      total_found: totalFound,
      by_source: emailStats,
      success_rate:
        leadsNeedingEmail.length > 0
          ? Math.round((totalFound / leadsNeedingEmail.length) * 100) + '%'
          : '0%',
    };

    // Step 3: Send new cold emails (with AI-generated drafts for bad reviews)
    if (resend) {
      const newLeads = await dbAll(`
        SELECT l.* FROM outreach_leads l
        LEFT JOIN outreach_emails e ON l.id = e.lead_id
        WHERE l.email IS NOT NULL AND l.status = 'new' AND e.id IS NULL
        LIMIT 200
      `);

      let sent = 0;
      let reviewAlertsSent = 0;
      let skippedDueToDupe = 0;

      for (const lead of newLeads) {
        try {
          // PARALLEL-SAFE: Check if this lead is already being processed by another session
          const lockAcquired = await acquireLock('lead', `${lead.id}`, 180); // 3 min lock
          if (!lockAcquired) {
            console.log(`â­ï¸ Skipping lead ${lead.id} (${lead.business_name}) - locked by another session`);
            skippedDueToDupe++;
            continue;
          }

          // PARALLEL-SAFE: Check if email was recently sent to this address
          const recentlySent = await wasEmailRecentlySent(lead.email, 'outreach', 60);
          if (recentlySent) {
            console.log(`â­ï¸ Skipping ${lead.email} - email recently sent`);
            await releaseLock('lead', `${lead.id}`);
            skippedDueToDupe++;
            continue;
          }

          // Generate personalized demo for ALL new leads (not just those with bad reviews)
          // This creates a custom landing page with 3 of their reviews + AI responses
          if (!lead.demo_url) {
            console.log(`ðŸ“ Generating demo for ${lead.business_name}...`);

            const demoResult = await generateDemoForLead(lead);

            if (demoResult && demoResult.first_ai_response) {
              // Use first AI response as preview in email
              lead.ai_response_draft = demoResult.first_ai_response;
              lead.demo_url = demoResult.demo_url;
              lead.demo_token = demoResult.demo_token;
              lead.has_bad_review = true; // Mark as having demo content for template selection

              // Set review fields for email template
              if (demoResult.first_review) {
                lead.worst_review_rating = demoResult.first_review.rating;
                lead.worst_review_text = demoResult.first_review.text;
                lead.worst_review_author = demoResult.first_review.author;
              }

              // Save to database (including review fields for email template)
              await dbQuery(
                `UPDATE outreach_leads SET
                  ai_response_draft = $1, demo_url = $2, demo_token = $3, has_bad_review = TRUE,
                  worst_review_rating = $4, worst_review_text = $5, worst_review_author = $6
                WHERE id = $7`,
                [
                  demoResult.first_ai_response,
                  demoResult.demo_url,
                  demoResult.demo_token,
                  demoResult.first_review?.rating || null,
                  demoResult.first_review?.text || null,
                  demoResult.first_review?.author || null,
                  lead.id,
                ]
              );

              console.log(
                `âœ… Demo generated: ${demoResult.demo_url} (${demoResult.reviews_processed} reviews)`
              );
            } else {
              // Fallback: Generate single AI draft if demo generation fails (e.g., no reviews found)
              console.log(`âš ï¸ Demo failed for ${lead.business_name}, trying single AI draft...`);

              // Try to get a review to generate draft from
              if (lead.worst_review_text) {
                const aiDraft = await generateReviewAlertDraft(
                  lead.business_name,
                  lead.business_type,
                  lead.worst_review_text,
                  lead.worst_review_rating,
                  lead.worst_review_author,
                  lead.city || null,
                  lead.google_rating || null,
                  lead.google_reviews_count || null
                );

                if (aiDraft) {
                  lead.ai_response_draft = aiDraft;
                  lead.has_bad_review = true;
                  await dbQuery(
                    'UPDATE outreach_leads SET ai_response_draft = $1, has_bad_review = TRUE WHERE id = $2',
                    [aiDraft, lead.id]
                  );
                }
              }
            }
          }

          // Use A/B tested subject for sequence 1
          const templateWithAB = await getTemplateForLeadWithABTest(1, lead);
          const template = fillEmailTemplate(templateWithAB, lead);

          // Track email campaign type
          let campaign = 'main';
          if (lead.lead_type === 'g2_competitor') {
            campaign = 'g2_competitor';
          } else if (lead.has_bad_review && lead.ai_response_draft) {
            campaign = 'review_alert';
            reviewAlertsSent++;
          }

          const emailResult = await sendOutreachEmail({
            to: lead.email,
            subject: template.subject,
            html: template.body.replace(/\n/g, '<br>'),
            campaign,
            tags: [{ name: 'sequence', value: '1' }],
          });

          await dbQuery(
            `
            INSERT INTO outreach_emails (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, ab_variant, provider)
            VALUES ($1, $2, 1, $3, $4, 'sent', NOW(), $5, $6, $7)
          `,
            [
              lead.id,
              lead.email,
              template.subject,
              template.body,
              campaign,
              templateWithAB.abVariant,
              emailResult.provider || 'resend',
            ]
          );

          await dbQuery('UPDATE outreach_leads SET status = $1 WHERE id = $2', [
            'contacted',
            lead.id,
          ]);

          // Mark email channel as contacted in omnichannel tracking
          await dbQuery(
            `UPDATE outreach_leads
             SET channels_contacted = COALESCE(channels_contacted, '{}'::jsonb) || $1::jsonb
             WHERE id = $2`,
            [JSON.stringify({ email: { sent_at: new Date().toISOString(), success: true, sequence: 1 } }), lead.id]
          );

          // Track email sent for demo conversion metrics
          if (lead.demo_token) {
            await dbQuery(
              'UPDATE demo_generations SET email_sent_at = NOW() WHERE demo_token = $1',
              [lead.demo_token]
            );
          }

          // PARALLEL-SAFE: Record email in history for deduplication
          await recordEmailSend(lead.email, 'outreach', 1, `outreach:${lead.id}:${Date.now()}`);

          sent++;

          await new Promise(r => setTimeout(r, 500));
        } catch (e) {
          console.error('Send error:', e.message);
        } finally {
          // PARALLEL-SAFE: Always release the lock
          await releaseLock('lead', `${lead.id}`);
        }
      }

      results.sending = { sent: sent, review_alerts: reviewAlertsSent, skipped_parallel_safe: skippedDueToDupe };

      // Step 4: Send follow-ups
      const needsFollowup = await dbAll(`
        SELECT l.*, MAX(e.sequence_number) as last_sequence
        FROM outreach_leads l
        JOIN outreach_emails e ON l.id = e.lead_id
        WHERE l.status = 'contacted'
          AND e.sent_at < NOW() - INTERVAL '3 days'
          AND e.replied_at IS NULL
        GROUP BY l.id
        HAVING MAX(e.sequence_number) < 3
        LIMIT 100
      `);

      let followupsSent = 0;
      let followupsSkipped = 0;

      for (const lead of needsFollowup) {
        const nextSequence = (lead.last_sequence || 1) + 1;

        // G2 competitor leads only have 2 sequences, others have 3
        const maxSequence = lead.lead_type === 'g2_competitor' ? 2 : 3;

        if (nextSequence <= maxSequence) {
          try {
            // PARALLEL-SAFE: Check if follow-up was recently sent
            const recentlySent = await wasEmailRecentlySent(lead.email, `followup_${nextSequence}`, 60);
            if (recentlySent) {
              console.log(`â­ï¸ Skipping followup ${nextSequence} for ${lead.email} - recently sent`);
              followupsSkipped++;
              continue;
            }

            const template = fillEmailTemplate(getTemplateForLead(nextSequence, lead), lead);

            // Determine campaign type for follow-up
            const followupCampaign = lead.lead_type === 'g2_competitor' ? 'g2_competitor' : 'main';

            const emailResult = await sendOutreachEmail({
              to: lead.email,
              subject: template.subject,
              html: template.body.replace(/\n/g, '<br>'),
              campaign: followupCampaign,
              tags: [{ name: 'sequence', value: String(nextSequence) }],
            });

            await dbQuery(
              `
              INSERT INTO outreach_emails (lead_id, email, sequence_number, subject, body, status, sent_at, campaign, provider)
              VALUES ($1, $2, $3, $4, $5, 'sent', NOW(), $6, $7)
            `,
              [
                lead.id,
                lead.email,
                nextSequence,
                template.subject,
                template.body,
                followupCampaign,
                emailResult.provider || 'resend',
              ]
            );

            if (nextSequence === maxSequence) {
              await dbQuery('UPDATE outreach_leads SET status = $1 WHERE id = $2', [
                'sequence_completed',
                lead.id,
              ]);
            }

            // PARALLEL-SAFE: Record follow-up in history
            await recordEmailSend(lead.email, `followup_${nextSequence}`, nextSequence, `followup:${lead.id}:${nextSequence}:${Date.now()}`);

            // Update omnichannel email tracking with sequence info
            await dbQuery(
              `UPDATE outreach_leads
               SET channels_contacted = COALESCE(channels_contacted, '{}'::jsonb) || $1::jsonb
               WHERE id = $2`,
              [JSON.stringify({ email: { sent_at: new Date().toISOString(), success: true, sequence: nextSequence } }), lead.id]
            );

            followupsSent++;
            await new Promise(r => setTimeout(r, 500));
          } catch (e) {}
        }
      }

      results.followups = { sent: followupsSent, skipped_parallel_safe: followupsSkipped };
    }

    console.log('âœ… Daily outreach completed:', results);

    // Log sales actions for state tracking
    if (results.scraping?.leads_added > 0) {
      await logSalesAction('scrape_leads', 'outreach', {
        count: results.scraping.leads_added,
        city: results.scraping.city,
        industry: results.scraping.industry,
      });
    }
    if (results.sending?.sent > 0) {
      await logSalesAction('send_emails', 'outreach', {
        count: results.sending.sent,
        campaign: 'daily_outreach',
      });
    }

    // Step 5: Send Review Alerts to existing users (PUSH model for retention)
    // This is the ROOT CAUSE fix for $0 MRR - remind users about new reviews
    let reviewAlertsResults = { alerts_sent: 0 };
    try {
      const baseUrl = process.env.BACKEND_URL || 'https://review-responder.onrender.com';
      const alertsResponse = await fetch(
        `${baseUrl}/api/cron/review-alerts?secret=${process.env.CRON_SECRET}`
      );
      reviewAlertsResults = await alertsResponse.json();
      console.log(`ðŸ”” Review Alerts: ${reviewAlertsResults.alerts_sent || 0} sent to ${reviewAlertsResults.users_checked || 0} users`);
    } catch (e) {
      console.error('Review alerts call failed:', e.message);
      reviewAlertsResults = { error: e.message };
    }

    results.review_alerts = reviewAlertsResults;

    // Minimal response for cron-job.org (has size limit)
    res.json({
      ok: true,
      scraped: results.scraping?.leads_added || 0,
      emails: results.email_finding?.total_found || 0,
      sent: results.sending?.sent || 0,
      followups: results.followups?.sent || 0,
      review_alerts: reviewAlertsResults.alerts_sent || 0,
    });
  } catch (error) {
    console.error('Daily outreach error:', error);
    // Minimal error response for cron-job.org
    res.status(500).json({ ok: false, err: error.message?.slice(0, 100) });
  }
});

// Get outreach dashboard stats
app.get('/api/outreach/dashboard', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Use central test email filter for accurate stats
    const TEST_EMAIL_FILTER = getTestEmailExcludeClause('email');

    const totalLeads = await dbGet('SELECT COUNT(*) as count FROM outreach_leads');
    const leadsWithEmail = await dbGet(
      'SELECT COUNT(*) as count FROM outreach_leads WHERE email IS NOT NULL'
    );
    const emailsSent = await dbGet(
      `SELECT COUNT(*) as count FROM outreach_emails WHERE status = $1 ${TEST_EMAIL_FILTER}`,
      ['sent']
    );
    const emailsOpened = await dbGet(
      `SELECT COUNT(*) as count FROM outreach_emails WHERE opened_at IS NOT NULL ${TEST_EMAIL_FILTER}`
    );

    // Click tracking stats (also filter test emails)
    let emailsClicked = { count: 0 };
    try {
      emailsClicked = (await dbGet(
        `SELECT COUNT(DISTINCT email) as count FROM outreach_clicks WHERE 1=1 ${TEST_EMAIL_FILTER}`
      )) || { count: 0 };
    } catch (e) {
      // Table might not exist yet
    }

    // HOT LEADS: Get clickers with business details (the REAL interested leads!)
    let hotLeads = [];
    try {
      const CLICKS_EMAIL_FILTER = getTestEmailExcludeClause('c.email');
      hotLeads =
        (await dbAll(`
        SELECT DISTINCT ON (c.email)
          c.email,
          c.clicked_at,
          l.business_name,
          l.city,
          l.phone,
          l.website,
          l.google_reviews_count
        FROM outreach_clicks c
        LEFT JOIN outreach_leads l ON LOWER(c.email) = LOWER(l.email)
        WHERE 1=1 ${CLICKS_EMAIL_FILTER}
          AND c.email NOT LIKE '%vimeo%'
        ORDER BY c.email, c.clicked_at DESC
      `)) || [];
    } catch (e) {
      // Hot leads query failed
    }

    const byStatus = await dbAll(`
      SELECT status, COUNT(*) as count
      FROM outreach_leads
      GROUP BY status
    `);

    const recentLeads = await dbAll(`
      SELECT business_name, business_type, city, email, status, google_reviews_count
      FROM outreach_leads
      ORDER BY created_at DESC
      LIMIT 10
    `);

    const recentEmails = await dbAll(`
      SELECT e.email, e.sequence_number, e.sent_at, e.opened_at, l.business_name
      FROM outreach_emails e
      JOIN outreach_leads l ON e.lead_id = l.id
      ORDER BY e.sent_at DESC
      LIMIT 10
    `);

    const campaign = await dbGet('SELECT * FROM outreach_campaigns WHERE name = $1', ['main']);

    // Magic Link & Re-Engagement Stats
    let magicLinkStats = { sent: 0, clicked: 0, converted: 0 };
    try {
      const mlSent = await dbGet('SELECT COUNT(*) as count FROM reengagement_emails');
      const mlClicked = await dbGet(
        'SELECT COUNT(*) as count FROM reengagement_emails WHERE clicked_at IS NOT NULL'
      );
      const mlConverted = await dbGet(
        'SELECT COUNT(*) as count FROM reengagement_emails WHERE registered_at IS NOT NULL'
      );
      magicLinkStats = {
        sent: parseInt(mlSent?.count || 0),
        clicked: parseInt(mlClicked?.count || 0),
        converted: parseInt(mlConverted?.count || 0),
      };
    } catch (e) {
      // Tables might not exist yet
    }

    // Demo Expiration Stats
    let demoExpirationStats = { total: 0, expired: 0, day3_sent: 0, day5_sent: 0 };
    try {
      const totalDemos = await dbGet(
        'SELECT COUNT(*) as count FROM demo_generations WHERE lead_id IS NOT NULL'
      );
      const expiredDemos = await dbGet(
        'SELECT COUNT(*) as count FROM demo_generations WHERE expired = true'
      );
      const day3Sent = await dbGet(
        'SELECT COUNT(*) as count FROM demo_generations WHERE expiration_email_day3 = true'
      );
      const day5Sent = await dbGet(
        'SELECT COUNT(*) as count FROM demo_generations WHERE expiration_email_day5 = true'
      );
      demoExpirationStats = {
        total: parseInt(totalDemos?.count || 0),
        expired: parseInt(expiredDemos?.count || 0),
        day3_sent: parseInt(day3Sent?.count || 0),
        day5_sent: parseInt(day5Sent?.count || 0),
      };
    } catch (e) {
      // Columns might not exist yet
    }

    res.json({
      stats: {
        total_leads: parseInt(totalLeads?.count || 0),
        leads_with_email: parseInt(leadsWithEmail?.count || 0),
        emails_sent: parseInt(emailsSent?.count || 0),
        clicks: parseInt(emailsClicked?.count || 0),
        click_rate:
          emailsSent?.count > 0
            ? ((emailsClicked?.count / emailsSent?.count) * 100).toFixed(1) + '%'
            : '0%',
        // Note: open_rate removed - unreliable due to bot scans
      },
      hot_leads: hotLeads,
      hot_leads_count: hotLeads.length,
      magic_links: magicLinkStats,
      demo_expiration: demoExpirationStats,
      by_status: byStatus,
      recent_leads: recentLeads,
      recent_emails: recentEmails,
      campaign: campaign,
      _note:
        'Open rate removed - most "opens" are bot scans. Click rate is the real metric. hot_leads = businesses that clicked!',
    });
  } catch (error) {
    console.error('Dashboard error:', error);
    res.status(500).json({ error: 'Failed to get dashboard' });
  }
});

// GET /api/outreach/funnel - Comprehensive sales funnel dashboard
app.get('/api/outreach/funnel', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // ========== FUNNEL METRICS ==========
    const funnel = {};

    // Use central test email filter
    const TEST_EMAIL_FILTER = getTestEmailExcludeClause('email');

    // Stage 1: Leads
    const totalLeads = await dbGet('SELECT COUNT(*) as count FROM outreach_leads');
    const leadsWithEmail = await dbGet(
      'SELECT COUNT(*) as count FROM outreach_leads WHERE email IS NOT NULL'
    );
    funnel.leads = {
      total: parseInt(totalLeads?.count || 0),
      with_email: parseInt(leadsWithEmail?.count || 0),
      email_rate:
        totalLeads?.count > 0
          ? ((leadsWithEmail?.count / totalLeads?.count) * 100).toFixed(1) + '%'
          : '0%',
    };

    // Stage 2: Emails Sent (excluding test emails)
    const emailsSent = await dbGet(
      `SELECT COUNT(*) as count FROM outreach_emails WHERE status = $1 ${TEST_EMAIL_FILTER}`,
      ['sent']
    );
    funnel.emails_sent = parseInt(emailsSent?.count || 0);

    // Stage 3: Opens (excluding test emails)
    const emailsOpened = await dbGet(
      `SELECT COUNT(*) as count FROM outreach_emails WHERE opened_at IS NOT NULL ${TEST_EMAIL_FILTER}`
    );
    funnel.opens = {
      count: parseInt(emailsOpened?.count || 0),
      rate:
        funnel.emails_sent > 0
          ? ((emailsOpened?.count / funnel.emails_sent) * 100).toFixed(1) + '%'
          : '0%',
    };

    // Stage 4: Clicks (excluding test emails)
    let clicksData = { count: 0, unique: 0 };
    try {
      const totalClicks = await dbGet(
        `SELECT COUNT(*) as count FROM outreach_clicks WHERE 1=1 ${TEST_EMAIL_FILTER}`
      );
      const uniqueClicks = await dbGet(
        `SELECT COUNT(DISTINCT email) as count FROM outreach_clicks WHERE 1=1 ${TEST_EMAIL_FILTER}`
      );
      clicksData = {
        count: parseInt(totalClicks?.count || 0),
        unique: parseInt(uniqueClicks?.count || 0),
      };
    } catch (e) {}
    funnel.clicks = {
      total: clicksData.count,
      unique: clicksData.unique,
      rate:
        funnel.emails_sent > 0
          ? ((clicksData.unique / funnel.emails_sent) * 100).toFixed(1) + '%'
          : '0%',
    };

    // Stage 5: Signups (users who came from outreach)
    let signups = { count: 0 };
    try {
      signups = (await dbGet(`
        SELECT COUNT(*) as count FROM users
        WHERE referral_source LIKE '%outreach%'
           OR referral_source LIKE '%alert%'
           OR email IN (SELECT DISTINCT email FROM outreach_clicks)
      `)) || { count: 0 };
    } catch (e) {}
    funnel.signups = {
      count: parseInt(signups?.count || 0),
      rate:
        clicksData.unique > 0
          ? ((signups?.count / clicksData.unique) * 100).toFixed(1) + '%'
          : '0%',
    };

    // Stage 6: Paid Conversions
    let paidUsers = { count: 0, revenue: 0 };
    try {
      paidUsers = (await dbGet(`
        SELECT COUNT(*) as count, COALESCE(SUM(
          CASE subscription_plan
            WHEN 'starter' THEN 29
            WHEN 'pro' THEN 49
            WHEN 'unlimited' THEN 99
            ELSE 0
          END
        ), 0) as revenue
        FROM users
        WHERE subscription_plan != 'free'
          AND (referral_source LIKE '%outreach%'
               OR referral_source LIKE '%alert%'
               OR email IN (SELECT DISTINCT email FROM outreach_clicks))
      `)) || { count: 0, revenue: 0 };
    } catch (e) {}
    funnel.paid = {
      count: parseInt(paidUsers?.count || 0),
      monthly_revenue: parseInt(paidUsers?.revenue || 0),
      conversion_rate:
        funnel.signups.count > 0
          ? ((paidUsers?.count / funnel.signups.count) * 100).toFixed(1) + '%'
          : '0%',
    };

    // ========== PROVIDER BREAKDOWN (Brevo vs Resend) ==========
    let providers = { brevo: { sent: 0, opens: 0 }, resend: { sent: 0, opens: 0 } };
    try {
      const providerStats = await dbAll(`
        SELECT
          COALESCE(provider, 'resend') as provider,
          COUNT(*) as sent,
          COUNT(*) FILTER (WHERE opened_at IS NOT NULL) as opens
        FROM outreach_emails
        WHERE status = 'sent'
        GROUP BY COALESCE(provider, 'resend')
      `);
      for (const p of providerStats) {
        if (p.provider === 'brevo' || p.provider === 'resend') {
          providers[p.provider] = {
            sent: parseInt(p.sent || 0),
            opens: parseInt(p.opens || 0),
            open_rate: p.sent > 0 ? ((p.opens / p.sent) * 100).toFixed(1) + '%' : '0%',
          };
        }
      }
    } catch (e) {}

    // ========== A/B TEST SUMMARY ==========
    let abTest = null;
    try {
      const test = await dbGet(
        'SELECT * FROM outreach_ab_tests WHERE test_name = $1 AND is_active = TRUE',
        ['sequence1_subject']
      );
      if (test) {
        const variants = [];
        ['a', 'b', 'c', 'd'].forEach(v => {
          const subjectKey = `variant_${v}_subject`;
          const sentKey = `variant_${v}_sent`;
          const opensKey = `variant_${v}_opens`;
          if (test[subjectKey]) {
            const sent = parseInt(test[sentKey] || 0);
            const opens = parseInt(test[opensKey] || 0);
            variants.push({
              variant: v.toUpperCase(),
              subject: test[subjectKey],
              sent,
              opens,
              open_rate: sent > 0 ? ((opens / sent) * 100).toFixed(1) + '%' : '0%',
            });
          }
        });
        abTest = {
          test_name: test.test_name,
          variants,
          winner: test.winner,
          total_sent: variants.reduce((sum, v) => sum + v.sent, 0),
          needs_data: variants.reduce((sum, v) => sum + v.sent, 0) < 120,
        };
      }
    } catch (e) {}

    // ========== CAMPAIGN BREAKDOWN ==========
    let campaigns = [];
    try {
      campaigns = await dbAll(`
        SELECT
          COALESCE(campaign, 'main') as campaign,
          COUNT(*) as sent,
          COUNT(*) FILTER (WHERE opened_at IS NOT NULL) as opens,
          COUNT(DISTINCT lead_id) as unique_leads
        FROM outreach_emails
        WHERE status = 'sent'
        GROUP BY COALESCE(campaign, 'main')
        ORDER BY sent DESC
      `);
      campaigns = campaigns.map(c => ({
        ...c,
        sent: parseInt(c.sent || 0),
        opens: parseInt(c.opens || 0),
        open_rate: c.sent > 0 ? ((c.opens / c.sent) * 100).toFixed(1) + '%' : '0%',
      }));
    } catch (e) {}

    // ========== DAILY TRENDS (Last 14 days) ==========
    let dailyTrends = [];
    try {
      dailyTrends = await dbAll(`
        SELECT
          DATE(sent_at) as date,
          COUNT(*) as sent,
          COUNT(*) FILTER (WHERE opened_at IS NOT NULL) as opens
        FROM outreach_emails
        WHERE sent_at > NOW() - INTERVAL '14 days'
        GROUP BY DATE(sent_at)
        ORDER BY date DESC
      `);
      dailyTrends = dailyTrends.map(d => ({
        date: d.date,
        sent: parseInt(d.sent || 0),
        opens: parseInt(d.opens || 0),
        open_rate: d.sent > 0 ? ((d.opens / d.sent) * 100).toFixed(1) + '%' : '0%',
      }));
    } catch (e) {}

    // ========== TOP PERFORMING EMAILS ==========
    let topEmails = [];
    try {
      topEmails = await dbAll(`
        SELECT
          e.subject,
          COUNT(*) as sent,
          COUNT(*) FILTER (WHERE e.opened_at IS NOT NULL) as opens,
          ROUND(COUNT(*) FILTER (WHERE e.opened_at IS NOT NULL)::numeric / NULLIF(COUNT(*), 0) * 100, 1) as open_rate
        FROM outreach_emails e
        WHERE e.status = 'sent' AND e.subject IS NOT NULL
        GROUP BY e.subject
        HAVING COUNT(*) >= 5
        ORDER BY open_rate DESC NULLS LAST
        LIMIT 5
      `);
    } catch (e) {}

    // ========== BREVO STATUS ==========
    const brevoStatus = {
      configured: !!process.env.BREVO_API_KEY,
      api_key_set: !!process.env.BREVO_API_KEY,
      active: !!brevoApi,
    };

    res.json({
      success: true,
      generated_at: new Date().toISOString(),
      funnel: {
        stages: [
          {
            name: 'Leads',
            value: funnel.leads.total,
            sub: `${funnel.leads.with_email} with email (${funnel.leads.email_rate})`,
          },
          { name: 'Emails Sent', value: funnel.emails_sent },
          { name: 'Opens', value: funnel.opens.count, rate: funnel.opens.rate },
          { name: 'Clicks', value: funnel.clicks.unique, rate: funnel.clicks.rate },
          { name: 'Signups', value: funnel.signups.count, rate: funnel.signups.rate },
          {
            name: 'Paid',
            value: funnel.paid.count,
            rate: funnel.paid.conversion_rate,
            revenue: `$${funnel.paid.monthly_revenue}/mo`,
          },
        ],
        conversion_rates: {
          lead_to_email: funnel.leads.email_rate,
          email_to_open: funnel.opens.rate,
          open_to_click:
            funnel.opens.count > 0
              ? ((funnel.clicks.unique / funnel.opens.count) * 100).toFixed(1) + '%'
              : '0%',
          click_to_signup: funnel.signups.rate,
          signup_to_paid: funnel.paid.conversion_rate,
          overall:
            funnel.leads.total > 0
              ? ((funnel.paid.count / funnel.leads.total) * 100).toFixed(2) + '%'
              : '0%',
        },
      },
      providers: {
        brevo: providers.brevo,
        resend: providers.resend,
        brevo_status: brevoStatus,
      },
      ab_test: abTest,
      campaigns,
      daily_trends: dailyTrends,
      top_emails: topEmails,
    });
  } catch (error) {
    console.error('Funnel dashboard error:', error);
    res.status(500).json({ error: 'Failed to get funnel dashboard' });
  }
});

// POST /api/admin/test-email - Send a test email via specific provider
app.post('/api/admin/test-email', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { to, provider = 'brevo' } = req.body;

  if (!to) {
    return res.status(400).json({ error: 'Missing "to" email address' });
  }

  try {
    const subject = `[Test] Brevo Email Test - ${new Date().toISOString()}`;
    const html = `
      <h2>Brevo Test Email</h2>
      <p>This is a test email sent via <strong>${provider}</strong>.</p>
      <p>If you received this, Brevo is working correctly!</p>
      <p>Sent at: ${new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' })}</p>
      <hr>
      <p><a href="https://tryreviewresponder.com">ReviewResponder</a></p>
    `;

    if (provider === 'brevo' && brevoApi) {
      const sendSmtpEmail = new SibApiV3Sdk.SendSmtpEmail();
      sendSmtpEmail.subject = subject;
      sendSmtpEmail.htmlContent = html;
      sendSmtpEmail.sender = {
        name: 'Berend from ReviewResponder',
        email: 'outreach@tryreviewresponder.com',
      };
      sendSmtpEmail.to = [{ email: to }];
      sendSmtpEmail.tags = ['test', 'brevo-test'];

      const result = await brevoApi.sendTransacEmail(sendSmtpEmail);
      console.log('[Test Email] Brevo test email sent to:', to, 'messageId:', result.messageId);

      return res.json({
        success: true,
        provider: 'brevo',
        to,
        messageId: result.messageId || result.body?.messageId,
        message: 'Test email sent via Brevo. Check your inbox and spam folder!',
      });
    } else if (resend) {
      const result = await resend.emails.send({
        from: FROM_EMAIL,
        to,
        subject,
        html,
      });

      return res.json({
        success: true,
        provider: 'resend',
        to,
        messageId: result.id,
        message: 'Test email sent via Resend',
      });
    } else {
      return res.status(500).json({ error: 'No email provider available' });
    }
  } catch (error) {
    console.error('[Test Email] Error:', error);
    return res.status(500).json({
      error: 'Failed to send test email',
      details: error.message,
    });
  }
});

// ==========================================
// REDDIT AUTO-RESPONDER
// ==========================================

// Reddit API helper function
async function getRedditAccessToken() {
  const clientId = process.env.REDDIT_CLIENT_ID;
  const clientSecret = process.env.REDDIT_CLIENT_SECRET;
  const username = process.env.REDDIT_USERNAME;
  const password = process.env.REDDIT_PASSWORD;

  if (!clientId || !clientSecret || !username || !password) {
    return null;
  }

  const auth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');

  const response = await fetch('https://www.reddit.com/api/v1/access_token', {
    method: 'POST',
    headers: {
      Authorization: `Basic ${auth}`,
      'Content-Type': 'application/x-www-form-urlencoded',
      'User-Agent': 'ReviewResponder/1.0',
    },
    body: `grant_type=password&username=${username}&password=${password}`,
  });

  const data = await response.json();
  return data.access_token;
}

// Search Reddit for relevant posts
async function searchRedditPosts(accessToken, query, subreddit = null) {
  const baseUrl = subreddit
    ? `https://oauth.reddit.com/r/${subreddit}/search`
    : 'https://oauth.reddit.com/search';

  const params = new URLSearchParams({
    q: query,
    sort: 'new',
    t: 'day', // Last 24 hours
    limit: '10',
    type: 'link',
  });

  if (subreddit) {
    params.append('restrict_sr', 'true');
  }

  const response = await fetch(`${baseUrl}?${params}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'User-Agent': 'ReviewResponder/1.0',
    },
  });

  const data = await response.json();
  return data.data?.children?.map(c => c.data) || [];
}

// Generate helpful Reddit comment using AI
// ========== ANTHROPIC BEST PRACTICES 2025: Full XML Structure ==========
async function generateRedditComment(post, topic) {
  const systemPrompt = `<persona>
You are a helpful small business expert participating in Reddit discussions.
You provide genuine value first, promotional mentions second (if at all).
</persona>

<goal>
Write a genuinely helpful comment that solves the user's problem.
If about reviews: mention ReviewResponder as ONE option among others.
If NOT about reviews: pure helpful advice, no promotion.
</goal>

<voice>
- Conversational and friendly (Reddit-style)
- Expert but not condescending
- Direct and practical
- No marketing speak
</voice>

<style_rules>
- Length: 100-200 words maximum
- Match Reddit's casual tone
- Use "I" when sharing experience
- No bullet points in comments (they look weird on Reddit)
</style_rules>

<avoid_patterns>
<forbidden_phrases>
- "I work for..."
- "Check out our tool..."
- "We offer..."
- "Our product..."
- "I recommend ReviewResponder" (too salesy)
${AI_SLOP_PHRASES.slice(0, 5)
  .map(p => `- "${p}"`)
  .join('\n')}
</forbidden_phrases>

<forbidden_words>
${AI_SLOP_WORDS.slice(0, 12).join(', ')}
</forbidden_words>
</avoid_patterns>

<output_format>
Write the comment directly.
No quotes. No "Comment:" prefix.
Just the Reddit comment text.
</output_format>`;

  const userPrompt = `<reddit_post subreddit="r/${post.subreddit}" topic="${topic}">
<title>${post.title}</title>
<content>${post.selftext?.substring(0, 500) || '(no content)'}</content>
</reddit_post>

Write a helpful, genuine Reddit comment:`;

  try {
    // Use Claude Opus 4.5 for highest quality (important marketing touchpoints)
    if (anthropic) {
      const response = await anthropic.messages.create({
        model: 'claude-opus-4-20250514',
        max_tokens: 500,
        system: systemPrompt,
        messages: [{ role: 'user', content: userPrompt }],
      });
      return response.content[0].text;
    }

    // Fallback to OpenAI
    if (openai) {
      const response = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        max_tokens: 500,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
      });
      return response.choices[0].message.content;
    }

    return null;
  } catch (error) {
    console.error('AI generation error:', error.message);
    return null;
  }
}

// Post comment to Reddit
async function postRedditComment(accessToken, postId, comment) {
  const response = await fetch('https://oauth.reddit.com/api/comment', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/x-www-form-urlencoded',
      'User-Agent': 'ReviewResponder/1.0',
    },
    body: `thing_id=t3_${postId}&text=${encodeURIComponent(comment)}`,
  });

  return response.json();
}

// Reddit monitor cron endpoint
app.get('/api/cron/reddit-monitor', async (req, res) => {
  const secret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(secret, process.env.CRON_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const dryRun = req.query.dry_run === 'true';

  // Check Reddit credentials
  if (!process.env.REDDIT_CLIENT_ID) {
    return res.status(500).json({
      error: 'Reddit API not configured',
      setup:
        'Add REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET, REDDIT_USERNAME, REDDIT_PASSWORD to Render',
    });
  }

  const results = {
    posts_found: 0,
    comments_generated: 0,
    comments_posted: 0,
    skipped: 0,
    errors: [],
  };

  try {
    // Initialize Reddit responses table if not exists
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS reddit_responses (
        id SERIAL PRIMARY KEY,
        post_id VARCHAR(50) UNIQUE NOT NULL,
        subreddit VARCHAR(100),
        post_title TEXT,
        post_url TEXT,
        our_comment TEXT,
        topic VARCHAR(100),
        posted_at TIMESTAMP DEFAULT NOW(),
        karma INTEGER DEFAULT 0
      )
    `);

    // Check daily limit (max 5 comments per day)
    const todayCount = await dbGet(`
      SELECT COUNT(*) as count FROM reddit_responses
      WHERE posted_at > NOW() - INTERVAL '24 hours'
    `);

    const dailyLimit = 5;
    const remaining = dailyLimit - parseInt(todayCount?.count || 0);

    if (remaining <= 0 && !dryRun) {
      return res.json({
        message: 'Daily limit reached (5 comments/day)',
        results: results,
      });
    }

    // Get Reddit access token
    const accessToken = await getRedditAccessToken();
    if (!accessToken) {
      return res.status(500).json({ error: 'Failed to authenticate with Reddit' });
    }

    // Subreddits to monitor
    const subreddits = [
      'smallbusiness',
      'Entrepreneur',
      'restaurateur',
      'hoteliers',
      'marketing',
      'AskMarketing',
      'ecommerce',
      'startups',
    ];

    // Keywords to search for
    const keywords = [
      'negative review',
      'bad review response',
      'how to respond review',
      'online reputation',
      'review management',
      'customer review help',
      'yelp review',
      'google review response',
    ];

    const allPosts = [];

    // Search each subreddit with each keyword
    for (const subreddit of subreddits) {
      for (const keyword of keywords) {
        try {
          const posts = await searchRedditPosts(accessToken, keyword, subreddit);
          allPosts.push(...posts.map(p => ({ ...p, searchKeyword: keyword })));
          await new Promise(r => setTimeout(r, 1000)); // Rate limit
        } catch (e) {
          results.errors.push(`Search error: ${subreddit}/${keyword}`);
        }
      }
    }

    // Deduplicate by post ID
    const uniquePosts = [...new Map(allPosts.map(p => [p.id, p])).values()];
    results.posts_found = uniquePosts.length;

    // Filter out posts we've already responded to
    const respondedPosts = await dbAll('SELECT post_id FROM reddit_responses');
    const respondedIds = new Set(respondedPosts.map(r => r.post_id));

    const newPosts = uniquePosts.filter(
      p =>
        !respondedIds.has(p.id) &&
        p.num_comments < 50 && // Not too popular (our comment won't be seen)
        p.num_comments > 0 && // Has some engagement
        !p.locked &&
        !p.archived
    );

    // Process posts (up to remaining daily limit)
    for (const post of newPosts.slice(0, remaining)) {
      try {
        // Generate helpful comment
        const comment = await generateRedditComment(post, post.searchKeyword);

        if (!comment) {
          results.skipped++;
          continue;
        }

        results.comments_generated++;

        if (dryRun) {
          console.log(`[DRY RUN] Would post to r/${post.subreddit}: "${post.title}"`);
          console.log(`Comment: ${comment.substring(0, 100)}...`);
          continue;
        }

        // Post the comment
        const postResult = await postRedditComment(accessToken, post.id, comment);

        if (postResult.success !== false) {
          // Save to database
          await dbQuery(
            `
            INSERT INTO reddit_responses (post_id, subreddit, post_title, post_url, our_comment, topic)
            VALUES ($1, $2, $3, $4, $5, $6)
            ON CONFLICT (post_id) DO NOTHING
          `,
            [
              post.id,
              post.subreddit,
              post.title,
              `https://reddit.com${post.permalink}`,
              comment,
              post.searchKeyword,
            ]
          );

          results.comments_posted++;
          console.log(`Posted comment to r/${post.subreddit}: "${post.title}"`);
        }

        // Rate limit between posts
        await new Promise(r => setTimeout(r, 2000));
      } catch (e) {
        results.errors.push(`Post error: ${post.id} - ${e.message}`);
      }
    }

    res.json({
      success: true,
      dry_run: dryRun,
      daily_limit: dailyLimit,
      remaining_today: remaining - results.comments_posted,
      results: results,
    });
  } catch (error) {
    console.error('Reddit monitor error:', error);
    res.status(500).json({ error: 'Reddit monitor failed', details: error.message });
  }
});

// Get Reddit response history
app.get('/api/admin/reddit-responses', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const responses = await dbAll(`
      SELECT * FROM reddit_responses
      ORDER BY posted_at DESC
      LIMIT 50
    `);

    const stats = await dbGet(`
      SELECT
        COUNT(*) as total_responses,
        COUNT(CASE WHEN posted_at > NOW() - INTERVAL '24 hours' THEN 1 END) as today,
        COUNT(CASE WHEN posted_at > NOW() - INTERVAL '7 days' THEN 1 END) as this_week
      FROM reddit_responses
    `);

    res.json({
      stats: stats,
      responses: responses,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get Reddit responses' });
  }
});

// ==========================================
// TWITTER/X ENGAGEMENT (Auto-Posting via @ExecPsychology)
// ==========================================

// Search Twitter for relevant tweets using OAuth 1.0a client
async function searchTwitter(query) {
  if (!twitterClient) return [];

  try {
    const result = await twitterClient.v2.search(query, {
      'tweet.fields': ['author_id', 'created_at', 'public_metrics', 'conversation_id'],
      'user.fields': ['username', 'name'],
      expansions: ['author_id'],
      max_results: 10,
    });

    return result.data?.data || [];
  } catch (error) {
    console.error('[Twitter] Search error:', error.message);
    return [];
  }
}

// Post a reply to a tweet
async function postTwitterReply(tweetId, replyText) {
  if (!twitterClient) {
    return { success: false, error: 'Twitter client not configured' };
  }

  try {
    const result = await twitterClient.v2.reply(replyText, tweetId);
    return {
      success: true,
      tweetId: result.data.id,
      text: result.data.text,
    };
  } catch (error) {
    console.error('[Twitter] Reply error:', error.message);
    return { success: false, error: error.message };
  }
}

// Twitter monitor cron endpoint - Auto-posts replies via @ExecPsychology
app.get('/api/cron/twitter-monitor', async (req, res) => {
  const secret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(secret, process.env.CRON_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const dryRun = req.query.dry_run === 'true';

  if (!twitterClient) {
    return res.status(500).json({
      error: 'Twitter API not configured',
      setup:
        'Add TWITTER_API_KEY, TWITTER_API_SECRET, TWITTER_ACCESS_TOKEN, TWITTER_ACCESS_TOKEN_SECRET to Render',
    });
  }

  const results = {
    tweets_found: 0,
    replies_generated: 0,
    replies_posted: 0,
    errors: [],
  };

  try {
    // Initialize Twitter responses table with posted status
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS twitter_responses (
        id SERIAL PRIMARY KEY,
        tweet_id VARCHAR(50) UNIQUE NOT NULL,
        tweet_text TEXT,
        tweet_author VARCHAR(100),
        our_reply TEXT,
        our_reply_id VARCHAR(50),
        topic VARCHAR(100),
        posted BOOLEAN DEFAULT FALSE,
        posted_at TIMESTAMP DEFAULT NOW()
      )
    `);

    // Add posted column if not exists (migration for existing tables)
    await dbQuery(`
      ALTER TABLE twitter_responses ADD COLUMN IF NOT EXISTS posted BOOLEAN DEFAULT FALSE
    `).catch(() => {});
    await dbQuery(`
      ALTER TABLE twitter_responses ADD COLUMN IF NOT EXISTS our_reply_id VARCHAR(50)
    `).catch(() => {});

    // Check daily limit (max 10 replies per day to stay safe)
    const todayCount = await dbGet(`
      SELECT COUNT(*) as count FROM twitter_responses
      WHERE posted = TRUE AND posted_at > NOW() - INTERVAL '24 hours'
    `);

    const dailyLimit = 10;
    const remaining = dailyLimit - parseInt(todayCount?.count || 0);

    if (remaining <= 0) {
      return res.json({
        message: 'Daily limit reached (10 auto-replies/day)',
        results: results,
      });
    }

    // Keywords to search (English + German)
    const keywords = [
      '"negative review" help -is:retweet',
      '"bad review" business -is:retweet',
      'how to respond review -is:retweet',
      '"online reputation" help -is:retweet',
      '"google review" response -is:retweet',
      '"schlechte Bewertung" -is:retweet',
      '"negative Bewertung" hilfe -is:retweet',
    ];

    const allTweets = [];

    for (const keyword of keywords) {
      try {
        const tweets = await searchTwitter(keyword);
        allTweets.push(...tweets.map(t => ({ ...t, searchKeyword: keyword })));
        // Rate limit: wait 2 seconds between searches
        await new Promise(r => setTimeout(r, 2000));
      } catch (e) {
        results.errors.push(`Search error: ${keyword}`);
      }
    }

    // Deduplicate
    const uniqueTweets = [...new Map(allTweets.map(t => [t.id, t])).values()];
    results.tweets_found = uniqueTweets.length;

    // Filter already responded
    const respondedTweets = await dbAll('SELECT tweet_id FROM twitter_responses');
    const respondedIds = new Set(respondedTweets.map(r => r.tweet_id));

    const newTweets = uniqueTweets.filter(t => !respondedIds.has(t.id));

    // Process tweets and auto-post replies
    for (const tweet of newTweets.slice(0, remaining)) {
      try {
        // ========== ANTHROPIC BEST PRACTICES 2025: Full XML Structure ==========
        const systemPrompt = `<persona>
You are @ExecPsychology - a business psychology expert on Twitter/X.
You help business owners with empathy and practical advice.
</persona>

<goal>
Write a helpful reply that addresses the user's problem.
Only mention ReviewResponder if specifically about review response tools.
</goal>

<voice>
- Casual Twitter tone
- Friendly and genuine (NOT salesy)
- Empathetic to their problem
- One emoji max, only if it adds value
</voice>

<style_rules>
- Maximum 250 characters
- Direct and actionable
- No hashtags
</style_rules>

<avoid_patterns>
<forbidden_words>
${AI_SLOP_WORDS.slice(0, 10).join(', ')}
</forbidden_words>
<forbidden_starts>
Never start with: "Here's", "Let me", "Great question"
</forbidden_starts>
</avoid_patterns>

<output_format>
Write the reply directly. No quotes. Just the tweet text.
</output_format>`;

        const userPrompt = `<tweet>${tweet.text}</tweet>

Write a helpful reply (max 250 chars):`;

        const reply = anthropic
          ? await anthropic.messages
              .create({
                model: 'claude-sonnet-4-20250514',
                max_tokens: 100,
                system: systemPrompt,
                messages: [{ role: 'user', content: userPrompt }],
              })
              .then(r => r.content[0].text.trim())
          : null;

        if (reply && reply.length <= 280) {
          results.replies_generated++;

          if (!dryRun) {
            // Actually post the reply!
            const postResult = await postTwitterReply(tweet.id, reply);

            if (postResult.success) {
              results.replies_posted++;
              console.log(`[Twitter] Posted reply to tweet ${tweet.id}`);

              // Save successful post to DB
              await dbQuery(
                `
                INSERT INTO twitter_responses (tweet_id, tweet_text, tweet_author, our_reply, our_reply_id, topic, posted)
                VALUES ($1, $2, $3, $4, $5, $6, TRUE)
                ON CONFLICT (tweet_id) DO UPDATE SET posted = TRUE, our_reply_id = $5
              `,
                [
                  tweet.id,
                  tweet.text,
                  tweet.author_id,
                  reply,
                  postResult.tweetId,
                  tweet.searchKeyword,
                ]
              );

              // Rate limit: wait 30 seconds between posts (stay well under limits)
              await new Promise(r => setTimeout(r, 30000));
            } else {
              results.errors.push(`Post failed for ${tweet.id}: ${postResult.error}`);

              // Save failed attempt for review
              await dbQuery(
                `
                INSERT INTO twitter_responses (tweet_id, tweet_text, tweet_author, our_reply, topic, posted)
                VALUES ($1, $2, $3, $4, $5, FALSE)
                ON CONFLICT (tweet_id) DO NOTHING
              `,
                [tweet.id, tweet.text, tweet.author_id, reply, tweet.searchKeyword]
              );
            }
          } else {
            // Dry run - just log
            console.log(`[Twitter DRY RUN] Would reply to: "${tweet.text.substring(0, 50)}..."`);
            console.log(`Reply: ${reply}`);
          }
        }
      } catch (e) {
        results.errors.push(`Tweet processing error: ${tweet.id} - ${e.message}`);
      }
    }

    res.json({
      success: true,
      dry_run: dryRun,
      message: dryRun
        ? 'Dry run complete - no tweets posted'
        : `Auto-posted ${results.replies_posted} replies via @ExecPsychology`,
      daily_limit: dailyLimit,
      remaining_today: remaining - results.replies_posted,
      results: results,
    });
  } catch (error) {
    console.error('Twitter monitor error:', error);
    res.status(500).json({ error: 'Twitter monitor failed', details: error.message });
  }
});

// Get Twitter engagement history
app.get('/api/admin/twitter-opportunities', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const responses = await dbAll(`
      SELECT * FROM twitter_responses
      ORDER BY posted_at DESC
      LIMIT 50
    `);

    const posted = responses.filter(r => r.posted);
    const pending = responses.filter(r => !r.posted);

    res.json({
      account: '@ExecPsychology',
      auto_posting: !!twitterClient,
      stats: {
        total: responses.length,
        posted: posted.length,
        pending: pending.length,
      },
      posted: posted,
      pending: pending,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get Twitter responses' });
  }
});

// ============================================
// TWITTER AUTO-TWEET SCHEDULER (@ExecPsychology)
// ============================================

// Tweet content categories and prompts - Review Psychology Focus (Updated 15.01.2026)
const TWEET_CATEGORIES = [
  {
    name: 'review_psychology',
    weight: 35,
    prompt: `Share a surprising psychological fact about why people write reviews, what triggers negative feedback, or how public responses affect perception. Be specific - cite a study or counterintuitive insight. No hashtags.`,
  },
  {
    name: 'customer_behavior',
    weight: 25,
    prompt: `Share an insight about customer behavior, loyalty psychology, or why people trust (or distrust) businesses based on how they handle feedback. Focus on the "why" behind customer actions. No hashtags.`,
  },
  {
    name: 'response_tactics',
    weight: 20,
    prompt: `Give a specific, actionable tip for responding to reviews. Be concrete, not generic. Example topics: what NOT to say, timing psychology, how to turn critics into advocates. Avoid "Thank you for your feedback" type advice. No hashtags.`,
  },
  {
    name: 'business_insight',
    weight: 15,
    prompt: `Share a counterintuitive business insight related to reputation, trust, or customer relationships. Make it memorable and thought-provoking. No hashtags.`,
  },
  {
    name: 'soft_promo',
    weight: 5,
    prompt: `Mention a common review-response problem (writing time, tone consistency, language barriers), then naturally reference tryreviewresponder.com as a solution. Problem-first, never feature-first. Be subtle. No hashtags.`,
  },
];

// Select category based on weights
function selectTweetCategory() {
  const totalWeight = TWEET_CATEGORIES.reduce((sum, cat) => sum + cat.weight, 0);
  let random = Math.random() * totalWeight;

  for (const category of TWEET_CATEGORIES) {
    random -= category.weight;
    if (random <= 0) return category;
  }
  return TWEET_CATEGORIES[0];
}

// AI Slop filter - removes typical AI-generated phrases
function cleanAISlop(text) {
  if (!text) return text;

  // Patterns to remove (case-insensitive)
  const slopPatterns = [
    /^(here'?s?|here is) (a |the |my |an )?/i,
    /^(let me |allow me to |i'd like to )/i,
    /^in today'?s? (world|age|era|landscape|market)/i,
    /^(the truth is|truth be told|honestly|to be honest),? /i,
    /^(did you know|fun fact|here'?s? the thing):? /i,
    /^(as (a |an )?(business owner|entrepreneur|leader)),? /i,
    /^(what if i told you|imagine (this|if)):? /i,
    /\b(game[- ]?changer|revolutionary|transform(ative)?|unlock(ing)?|leverage|skyrocket|supercharge)\b/gi,
    /\b(in (this|today's) (fast[- ]?paced|ever[- ]?changing|dynamic))\b/gi,
    /\b(at the end of the day|when all is said and done)\b/gi,
    /\b(it'?s? (important|crucial|essential|vital) to (note|remember|understand))\b/gi,
    /#\w+/g, // Remove any hashtags that slipped through
  ];

  let cleaned = text;
  for (const pattern of slopPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }

  // Clean up extra spaces and capitalize first letter
  cleaned = cleaned.replace(/\s+/g, ' ').trim();
  if (cleaned.length > 0) {
    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
  }

  return cleaned;
}

// Generate tweet content using Claude
// ========== ANTHROPIC BEST PRACTICES 2025: Full XML Structure ==========
async function generateTweetContent(category) {
  if (!anthropic) return null;

  // ========== SYSTEM PROMPT: First-Principles Optimized (15.01.2026) ==========
  // Based on: https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/claude-4-best-practices
  // Key insights: Be explicit, add context/motivation, use few-shot examples, tell what TO DO not what NOT to do
  const systemPrompt = `<context>
You write tweets for @ExecPsychology, a Twitter account about the psychology behind customer reviews.
The account has 346 followers interested in business psychology. Viral posts got 6-12K views.
Your tweets appear alongside real human content - they must be indistinguishable from a human expert.
</context>

<persona>
You are the person behind @ExecPsychology - someone who:
- Ran restaurants for 10 years and learned customer psychology the hard way
- Now helps other business owners understand WHY customers behave certain ways
- Gets genuinely frustrated when people give generic advice like "respond to all reviews"
- Has strong opinions backed by experience, not just studies
- Talks like a smart friend at a bar, not a LinkedIn thought leader
</persona>

<voice_examples>
These tweets capture your voice perfectly. Study the rhythm, specificity, and attitude:

GOOD: "Your 5-star customers rarely leave reviews. Your 1-star ones always do. That's not a bug - it's human psychology. Negative emotions demand expression."

GOOD: "Stop saying 'We apologize for any inconvenience caused.' Nobody talks like that. Say 'That sucks, we messed up.' People forgive humans, not corporations."

GOOD: "The customer who complains publicly is doing you a favor. The dangerous ones leave silently and tell 10 friends."

GOOD: "Responding to a review in under 2 hours shows you care. Responding in under 2 minutes shows you're desperate. Psychology is weird."

BAD: "Customer feedback is essential for business growth! Here's why reviews matter..." (generic, corporate, boring)

BAD: "Did you know that 93% of customers read reviews? That's why responding is crucial!" (stat-dump, no insight)

BAD: "Here are 5 tips for responding to negative reviews: 1. Stay calm 2. Be professional..." (listicle format, zero personality)
</voice_examples>

<what_makes_tweets_viral>
Pattern-interrupt: Say something unexpected that makes people stop scrolling.
Specificity: "15 minutes for coffee" beats "long wait times."
Opinion: Take a stance. Lukewarm takes get lukewarm engagement.
Tension: Set up a contradiction or counterintuitive truth.
Brevity: If you can cut a word, cut it. Punch lands harder.
</what_makes_tweets_viral>

<format_rules>
CRITICAL: Maximum 220 characters total. Count carefully - this is a hard limit.
Shorter is better. Aim for 150-200 characters. Cut ruthlessly.
No hashtags. One emoji max, mid-sentence only. Start with the hook.
</format_rules>

<output>
Output ONLY the tweet text. No quotes, no explanation, no meta-commentary.
</output>`;

  try {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 100,
      system: systemPrompt,
      messages: [
        { role: 'user', content: `<category>${category.name}</category>\n\n${category.prompt}` },
      ],
    });

    const rawTweet = response.content[0].text.trim();
    const cleanedTweet = cleanAISlop(rawTweet);

    console.log(
      `[Twitter] Raw: "${rawTweet.substring(0, 50)}..." -> Clean: "${cleanedTweet.substring(0, 50)}..."`
    );

    return cleanedTweet;
  } catch (error) {
    console.error('[Twitter] Tweet generation error:', error.message);
    return null;
  }
}

// Post a new tweet
async function postTweet(text) {
  if (!twitterClient) {
    return { success: false, error: 'Twitter client not configured' };
  }

  try {
    const result = await twitterClient.v2.tweet(text);
    return {
      success: true,
      tweetId: result.data.id,
      text: result.data.text,
    };
  } catch (error) {
    console.error('[Twitter] Post error:', error.message);
    return { success: false, error: error.message };
  }
}

// Auto-Tweet cron endpoint
app.get('/api/cron/twitter-post', async (req, res) => {
  const secret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(secret, process.env.CRON_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const dryRun = req.query.dry_run === 'true';

  if (!twitterClient) {
    return res.status(500).json({
      error: 'Twitter API not configured',
      setup:
        'Add TWITTER_API_KEY, TWITTER_API_SECRET, TWITTER_ACCESS_TOKEN, TWITTER_ACCESS_TOKEN_SECRET',
    });
  }

  try {
    // Initialize scheduled tweets table
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS twitter_scheduled_posts (
        id SERIAL PRIMARY KEY,
        tweet_text TEXT NOT NULL,
        tweet_id VARCHAR(50),
        category VARCHAR(50),
        posted BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT NOW(),
        posted_at TIMESTAMP
      )
    `);

    // Check daily limit (max 2 tweets per day)
    const todayCount = await dbGet(`
      SELECT COUNT(*) as count FROM twitter_scheduled_posts
      WHERE posted = TRUE AND posted_at > NOW() - INTERVAL '24 hours'
    `);

    const dailyLimit = 2;
    const postedToday = parseInt(todayCount?.count || 0);

    if (postedToday >= dailyLimit) {
      return res.json({
        success: true,
        message: `Daily limit reached (${dailyLimit} tweets/day)`,
        posted_today: postedToday,
        next_slot: 'Tomorrow',
      });
    }

    // Select category and generate tweet
    const category = selectTweetCategory();
    const tweetText = await generateTweetContent(category);

    if (!tweetText) {
      return res.status(500).json({ error: 'Failed to generate tweet content' });
    }

    // Validate length
    if (tweetText.length > 280) {
      return res.status(500).json({
        error: 'Generated tweet too long',
        length: tweetText.length,
        text: tweetText,
      });
    }

    const result = {
      category: category.name,
      tweet: tweetText,
      length: tweetText.length,
      posted: false,
      tweet_id: null,
    };

    if (!dryRun) {
      // Post the tweet
      const postResult = await postTweet(tweetText);

      if (postResult.success) {
        result.posted = true;
        result.tweet_id = postResult.tweetId;

        // Save to database
        await dbQuery(
          `
          INSERT INTO twitter_scheduled_posts (tweet_text, tweet_id, category, posted, posted_at)
          VALUES ($1, $2, $3, TRUE, NOW())
        `,
          [tweetText, postResult.tweetId, category.name]
        );

        // Log for sales state tracking
        await logSalesAction('twitter_post', 'social', {
          count: 1,
          category: category.name,
          tweet_id: postResult.tweetId,
        });

        console.log(`[Twitter] Posted tweet: "${tweetText.substring(0, 50)}..."`);
      } else {
        result.error = postResult.error;

        // Save failed attempt
        await dbQuery(
          `
          INSERT INTO twitter_scheduled_posts (tweet_text, category, posted)
          VALUES ($1, $2, FALSE)
        `,
          [tweetText, category.name]
        );
      }
    } else {
      console.log(`[Twitter DRY RUN] Would post: "${tweetText}"`);
    }

    res.json({
      success: true,
      dry_run: dryRun,
      account: '@ExecPsychology',
      daily_limit: dailyLimit,
      posted_today: postedToday + (result.posted ? 1 : 0),
      result: result,
    });
  } catch (error) {
    console.error('Twitter post error:', error);
    res.status(500).json({ error: 'Twitter post failed', details: error.message });
  }
});

// Get scheduled tweet history
app.get('/api/admin/twitter-posts', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const posts = await dbAll(`
      SELECT * FROM twitter_scheduled_posts
      ORDER BY created_at DESC
      LIMIT 50
    `);

    // Stats by category
    const categoryStats = await dbAll(`
      SELECT category, COUNT(*) as count, SUM(CASE WHEN posted THEN 1 ELSE 0 END) as posted_count
      FROM twitter_scheduled_posts
      GROUP BY category
    `);

    res.json({
      account: '@ExecPsychology',
      auto_posting: !!twitterClient,
      total_posts: posts.length,
      category_stats: categoryStats,
      recent_posts: posts,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get tweet history' });
  }
});

// ============================================
// AMAZON SELLER EMAIL SYSTEM
// ============================================

// Initialize amazon_seller_leads table
async function initAmazonSellerLeadsTable() {
  try {
    await dbQuery(`
      CREATE TABLE IF NOT EXISTS amazon_seller_leads (
        id SERIAL PRIMARY KEY,
        seller_name VARCHAR(255) NOT NULL,
        seller_id VARCHAR(100),
        store_url TEXT,
        email VARCHAR(255),
        contact_name VARCHAR(255),
        status VARCHAR(50) DEFAULT 'new',
        email_sent_at TIMESTAMP,
        clicked_at TIMESTAMP,
        demo_token VARCHAR(100),
        product_category VARCHAR(255),
        review_count INTEGER,
        avg_rating DECIMAL(2,1),
        source VARCHAR(100) DEFAULT 'manual',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);

    // Add index for faster lookups
    await dbQuery(`CREATE INDEX IF NOT EXISTS idx_amazon_seller_status ON amazon_seller_leads(status)`);
    await dbQuery(`CREATE INDEX IF NOT EXISTS idx_amazon_seller_email ON amazon_seller_leads(email)`);

    console.log('âœ… Amazon seller leads table initialized');
  } catch (error) {
    console.error('Error initializing amazon_seller_leads table:', error.message);
  }
}
initAmazonSellerLeadsTable();

// Amazon Seller Email Template
const AMAZON_SELLER_EMAIL_TEMPLATE = {
  subject: 'Quick question about your Amazon reviews, {seller_name}',
  body: `Hey {contact_name},

I noticed your Amazon store has {review_count} reviews with an average of {avg_rating} stars.

Quick question: How long does it take you to respond to each review?

Most sellers spend 10-15 minutes per review. With ReviewResponder, you can generate professional, personalized responses in seconds.

I put together a quick demo showing how it works with your actual reviews:
{demo_link}

Takes 30 seconds to see it in action.

Cheers,
Berend

P.S. If you're not the right person for this, no worries - just hit unsubscribe below.

---
ReviewResponder | AI-powered review responses
Unsubscribe: {unsubscribe_link}`
};

// GET /api/admin/amazon-dashboard - Amazon Seller Stats & Metrics
app.get('/api/admin/amazon-dashboard', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Get overall stats
    const stats = await dbGet(`
      SELECT
        COUNT(*) as total_leads,
        COUNT(*) FILTER (WHERE status = 'new') as new_leads,
        COUNT(*) FILTER (WHERE status = 'contacted') as contacted,
        COUNT(*) FILTER (WHERE status = 'clicked') as clicked,
        COUNT(*) FILTER (WHERE status = 'converted') as converted,
        COUNT(*) FILTER (WHERE status = 'unsubscribed') as unsubscribed,
        COUNT(*) FILTER (WHERE email_sent_at IS NOT NULL) as emails_sent,
        COUNT(*) FILTER (WHERE clicked_at IS NOT NULL) as total_clicks
      FROM amazon_seller_leads
    `);

    // Calculate CTR
    const emailsSent = parseInt(stats?.emails_sent || 0);
    const clicks = parseInt(stats?.total_clicks || 0);
    const ctr = emailsSent > 0 ? ((clicks / emailsSent) * 100).toFixed(1) : 0;

    // Get recent activity (last 7 days)
    const recentActivity = await dbAll(`
      SELECT
        DATE(created_at) as date,
        COUNT(*) FILTER (WHERE email_sent_at::date = DATE(created_at)) as emails_sent,
        COUNT(*) FILTER (WHERE clicked_at::date = DATE(created_at)) as clicks
      FROM amazon_seller_leads
      WHERE created_at >= NOW() - INTERVAL '7 days'
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `);

    // Get category breakdown
    const categoryStats = await dbAll(`
      SELECT
        COALESCE(product_category, 'Unknown') as category,
        COUNT(*) as count,
        COUNT(*) FILTER (WHERE status = 'clicked') as clicks,
        COUNT(*) FILTER (WHERE status = 'converted') as converted
      FROM amazon_seller_leads
      GROUP BY product_category
      ORDER BY count DESC
      LIMIT 10
    `);

    res.json({
      total_leads: parseInt(stats?.total_leads || 0),
      new_leads: parseInt(stats?.new_leads || 0),
      contacted: parseInt(stats?.contacted || 0),
      clicked: parseInt(stats?.clicked || 0),
      converted: parseInt(stats?.converted || 0),
      unsubscribed: parseInt(stats?.unsubscribed || 0),
      emails_sent: emailsSent,
      total_clicks: clicks,
      ctr: `${ctr}%`,
      recent_activity: recentActivity || [],
      category_breakdown: categoryStats || []
    });
  } catch (error) {
    console.error('Amazon dashboard error:', error.message);
    res.status(500).json({ error: 'Failed to get Amazon dashboard data' });
  }
});

// GET /api/admin/amazon-leads - List Amazon Seller Leads with pagination
app.get('/api/admin/amazon-leads', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { status, limit = 50, offset = 0, search } = req.query;

    let whereClause = 'WHERE 1=1';
    const params = [];
    let paramIndex = 1;

    if (status && status !== 'all') {
      whereClause += ` AND status = $${paramIndex++}`;
      params.push(status);
    }

    if (search) {
      whereClause += ` AND (seller_name ILIKE $${paramIndex} OR email ILIKE $${paramIndex} OR seller_id ILIKE $${paramIndex})`;
      params.push(`%${search}%`);
      paramIndex++;
    }

    const leads = await dbAll(`
      SELECT * FROM amazon_seller_leads
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex}
    `, [...params, parseInt(limit), parseInt(offset)]);

    const countResult = await dbGet(`
      SELECT COUNT(*) as total FROM amazon_seller_leads ${whereClause}
    `, params);

    res.json({
      leads: leads || [],
      total: parseInt(countResult?.total || 0),
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Amazon leads list error:', error.message);
    res.status(500).json({ error: 'Failed to get Amazon leads' });
  }
});

// POST /api/admin/amazon-leads - Add Amazon Seller Lead manually
app.post('/api/admin/amazon-leads', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { seller_name, seller_id, store_url, email, contact_name, product_category, review_count, avg_rating, source = 'manual' } = req.body;

    if (!seller_name) {
      return res.status(400).json({ error: 'seller_name is required' });
    }

    // Generate demo token for tracking
    const demoToken = `amz_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;

    const result = await dbGet(`
      INSERT INTO amazon_seller_leads (
        seller_name, seller_id, store_url, email, contact_name,
        product_category, review_count, avg_rating, source, demo_token
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `, [seller_name, seller_id, store_url, email, contact_name, product_category, review_count, avg_rating, source, demoToken]);

    res.json({ success: true, lead: result });
  } catch (error) {
    console.error('Add Amazon lead error:', error.message);
    res.status(500).json({ error: 'Failed to add Amazon lead' });
  }
});

// POST /api/admin/amazon-leads/bulk - Bulk import Amazon Seller Leads
app.post('/api/admin/amazon-leads/bulk', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { leads } = req.body;

    if (!leads || !Array.isArray(leads) || leads.length === 0) {
      return res.status(400).json({ error: 'leads array is required' });
    }

    let added = 0;
    let skipped = 0;

    for (const lead of leads) {
      try {
        // Check if already exists (by email or seller_id)
        if (lead.email) {
          const existing = await dbGet(`SELECT id FROM amazon_seller_leads WHERE email = $1`, [lead.email]);
          if (existing) {
            skipped++;
            continue;
          }
        }

        const demoToken = `amz_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;

        await dbQuery(`
          INSERT INTO amazon_seller_leads (
            seller_name, seller_id, store_url, email, contact_name,
            product_category, review_count, avg_rating, source, demo_token
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        `, [
          lead.seller_name,
          lead.seller_id,
          lead.store_url,
          lead.email,
          lead.contact_name,
          lead.product_category,
          lead.review_count,
          lead.avg_rating,
          lead.source || 'import',
          demoToken
        ]);

        added++;
      } catch (e) {
        skipped++;
      }
    }

    res.json({ success: true, added, skipped, total: leads.length });
  } catch (error) {
    console.error('Bulk import Amazon leads error:', error.message);
    res.status(500).json({ error: 'Failed to bulk import Amazon leads' });
  }
});

// DELETE /api/admin/amazon-leads/:id - Delete Amazon Seller Lead
app.delete('/api/admin/amazon-leads/:id', async (req, res) => {
  const adminKey = req.query.key || req.headers['x-admin-key'];
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { id } = req.params;

    await dbQuery('DELETE FROM amazon_seller_leads WHERE id = $1', [id]);

    res.json({ success: true, deleted: id });
  } catch (error) {
    console.error('Delete Amazon lead error:', error.message);
    res.status(500).json({ error: 'Failed to delete Amazon lead' });
  }
});

// GET /api/amazon-demo/:token - Demo link with click tracking
app.get('/api/amazon-demo/:token', async (req, res) => {
  try {
    const { token } = req.params;

    // Update click tracking
    await dbQuery(`
      UPDATE amazon_seller_leads
      SET status = 'clicked', clicked_at = NOW(), updated_at = NOW()
      WHERE demo_token = $1 AND status != 'converted'
    `, [token]);

    console.log(`ðŸ–±ï¸ Amazon demo clicked: ${token}`);

    // Redirect to main demo or signup page
    res.redirect('https://tryreviewresponder.com/demo?source=amazon&token=' + token);
  } catch (error) {
    console.error('Amazon demo click error:', error.message);
    res.redirect('https://tryreviewresponder.com');
  }
});

// GET /api/cron/send-amazon-emails - Cron job to send Amazon seller emails
app.get('/api/cron/send-amazon-emails', async (req, res) => {
  const cronSecret = req.query.secret;
  if (!safeCompare(cronSecret, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const limit = parseInt(req.query.limit) || 10;
    const dryRun = req.query.dry_run === 'true';

    // Get leads with status='new' and email
    const leads = await dbAll(`
      SELECT * FROM amazon_seller_leads
      WHERE status = 'new' AND email IS NOT NULL
      ORDER BY created_at ASC
      LIMIT $1
    `, [limit]);

    if (!leads || leads.length === 0) {
      return res.json({ success: true, message: 'No new Amazon leads to email', sent: 0 });
    }

    let sent = 0;
    let errors = [];

    for (const lead of leads) {
      try {
        // Check if email was recently sent (parallel-safe)
        const recentlySent = await wasEmailRecentlySent(lead.email, 'amazon_outreach', 24);
        if (recentlySent) {
          console.log(`â­ï¸ Skipping ${lead.email} - recently contacted`);
          continue;
        }

        // Check unsubscribe list
        const unsubscribed = await dbGet(`SELECT id FROM unsubscribes WHERE LOWER(email) = LOWER($1)`, [lead.email]);
        if (unsubscribed) {
          await dbQuery(`UPDATE amazon_seller_leads SET status = 'unsubscribed' WHERE id = $1`, [lead.id]);
          continue;
        }

        // Generate personalized demo link
        const demoLink = `https://review-responder.onrender.com/api/amazon-demo/${lead.demo_token}`;
        const unsubscribeLink = `https://review-responder.onrender.com/api/outreach/unsubscribe?email=${encodeURIComponent(lead.email)}`;

        // Build email content
        const subject = AMAZON_SELLER_EMAIL_TEMPLATE.subject
          .replace('{seller_name}', lead.seller_name);

        const body = AMAZON_SELLER_EMAIL_TEMPLATE.body
          .replace('{contact_name}', lead.contact_name || 'there')
          .replace('{review_count}', lead.review_count || 'several')
          .replace('{avg_rating}', lead.avg_rating || '4+')
          .replace('{demo_link}', demoLink)
          .replace('{unsubscribe_link}', unsubscribeLink);

        if (dryRun) {
          console.log(`[DRY RUN] Would send to ${lead.email}: ${subject}`);
          sent++;
          continue;
        }

        // Send email via Resend
        if (resend) {
          await resend.emails.send({
            from: 'Berend from ReviewResponder <berend@tryreviewresponder.com>',
            to: lead.email,
            subject: subject,
            text: body,
            headers: {
              'List-Unsubscribe': `<${unsubscribeLink}>`,
              'List-Unsubscribe-Post': 'List-Unsubscribe=One-Click'
            }
          });

          // Update lead status
          await dbQuery(`
            UPDATE amazon_seller_leads
            SET status = 'contacted', email_sent_at = NOW(), updated_at = NOW()
            WHERE id = $1
          `, [lead.id]);

          // Record in parallel-safe history
          await recordEmailSend(lead.email, 'amazon_outreach', 1, `amazon:${lead.id}:${Date.now()}`);

          sent++;
          console.log(`âœ‰ï¸ Amazon email sent to ${lead.email} (${lead.seller_name})`);

          // Small delay between sends
          await new Promise(r => setTimeout(r, 500));
        } else {
          errors.push(`No email provider configured`);
          break;
        }
      } catch (e) {
        console.error(`Failed to send Amazon email to ${lead.email}:`, e.message);
        errors.push(`${lead.email}: ${e.message}`);
      }
    }

    res.json({
      success: true,
      dry_run: dryRun,
      total_leads: leads.length,
      sent: sent,
      errors: errors.length > 0 ? errors : undefined
    });
  } catch (error) {
    console.error('Amazon cron error:', error.message);
    res.status(500).json({ error: 'Failed to send Amazon emails' });
  }
});

// ============================================
// SALES AUTOMATION ENDPOINTS
// ============================================

// Email Templates for Sales Automation
const SALES_EMAIL_TEMPLATES = {
  yelp_audit: {
    subject: '{business_name}: {unanswered} unbeantwortete Yelp Reviews kosten Sie Kunden',
    body: `Hallo,

ich habe mir gerade das Yelp-Profil von {business_name} angeschaut und festgestellt:

- {total_reviews} Reviews insgesamt
- Nur {owner_responses} davon beantwortet ({response_rate}%)
- {unanswered} Reviews warten auf eine Antwort

Studien zeigen: Businesses die auf Reviews antworten erhalten 35% mehr Anfragen.

Mit ReviewResponder koennen Sie auf alle {unanswered} Reviews in unter 10 Minuten antworten - mit KI-generierten, professionellen Antworten.

Kostenlos testen: https://tryreviewresponder.com?utm_source=yelp_audit&utm_campaign={city}

Beste Gruesse`,
  },
  g2_switcher: {
    subject: 'Frustriert mit {competitor}? Es gibt eine bessere Alternative',
    body: `Hallo {contact_name},

ich habe Ihre Bewertung zu {competitor} auf G2 gelesen - ich verstehe Ihre Frustration.

"{complaint_summary}"

Viele Businesses wechseln zu ReviewResponder weil:
- Keine versteckten Kosten
- KI-generierte Antworten in Sekunden
- 30-Tage Geld-zurueck-Garantie

Wir bieten Ihnen 14 Tage kostenlos zum Testen: https://tryreviewresponder.com?utm_source=g2_switch&utm_campaign={competitor}

Falls Sie Fragen haben, antworten Sie einfach auf diese Email.

Beste Gruesse`,
  },
  agency_partnership: {
    subject: 'White-Label Review Management fuer {agency_name} Kunden',
    body: `Hallo {contact_name},

ich habe {agency_name} auf Clutch gefunden und gesehen, dass Sie Local SEO Services anbieten.

Viele Ihrer Kunden brauchen wahrscheinlich auch Review Management - und wir koennen Ihnen helfen, diesen Service anzubieten ohne eigene Entwicklung.

Unser White-Label Angebot:
- 30% Revenue Share auf alle Kundenabos
- Ihr Branding, Ihr Dashboard
- Wir kuemmern uns um die Technik

Interesse an einem kurzen Gespraech?

Beste Gruesse,
ReviewResponder Partner Team

https://tryreviewresponder.com/partners?utm_source=clutch&utm_campaign=agency`,
  },
  agency_followup_1: {
    subject: 'Re: White-Label Review Management fuer {agency_name}',
    body: `Hallo {contact_name},

wollte kurz nachfragen ob Sie meine letzte Email gesehen haben.

Falls Review Management nicht auf Ihrer Roadmap ist - kein Problem. Aber falls doch: Wir haben bereits 20+ Agencies als Partner und die Ergebnisse sind beeindruckend.

Ein Partner berichtet: "Wir haben 5 Kunden in den ersten Monat onboarded - $2,450 zusaetzlicher Umsatz pro Monat."

Antworten Sie einfach falls Sie mehr erfahren moechten.

Beste Gruesse`,
  },
};

// POST /api/sales/yelp-leads - Submit Yelp leads from scraping
app.post('/api/sales/yelp-leads', async (req, res) => {
  const authKey = req.headers['x-api-key'] || req.query.key;
  if (
    !safeCompare(authKey, process.env.ADMIN_SECRET) &&
    !safeCompare(authKey, process.env.CRON_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { leads } = req.body;
    if (!Array.isArray(leads) || leads.length === 0) {
      return res.status(400).json({ error: 'leads array required' });
    }

    let inserted = 0;
    let skipped = 0;

    for (const lead of leads) {
      // Check if already exists
      const existing = await dbGet('SELECT id FROM yelp_leads WHERE yelp_url = $1', [
        lead.yelp_url,
      ]);
      if (existing) {
        skipped++;
        continue;
      }

      await dbQuery(
        `
        INSERT INTO yelp_leads (business_name, yelp_url, city, category, total_reviews, owner_responses, response_rate, website, phone)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      `,
        [
          lead.business_name,
          lead.yelp_url,
          lead.city,
          lead.category,
          lead.total_reviews || 0,
          lead.owner_responses || 0,
          lead.response_rate || 0,
          lead.website,
          lead.phone,
        ]
      );
      inserted++;
    }

    res.json({ success: true, inserted, skipped, total: leads.length });
  } catch (error) {
    console.error('Yelp leads submission error:', error);
    res.status(500).json({ error: 'Failed to submit leads' });
  }
});

// POST /api/sales/competitor-leads - Submit G2 competitor leads with auto demo + email
app.post('/api/sales/competitor-leads', async (req, res) => {
  const authKey = req.headers['x-api-key'] || req.query.key;
  if (
    !safeCompare(authKey, process.env.ADMIN_SECRET) &&
    !safeCompare(authKey, process.env.CRON_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { leads, generate_demos = false, send_emails = false } = req.body;
    if (!Array.isArray(leads) || leads.length === 0) {
      return res.status(400).json({ error: 'leads array required' });
    }

    const results = {
      inserted: 0,
      skipped: 0,
      emails_found: 0,
      demos_generated: 0,
      emails_sent: 0,
      errors: [],
    };

    for (const lead of leads) {
      try {
        // Check if already exists (by company + competitor combo)
        const existing = await dbGet(
          'SELECT id FROM competitor_leads WHERE company_name = $1 AND competitor = $2',
          [lead.company_name, lead.competitor]
        );
        if (existing) {
          results.skipped++;
          continue;
        }

        // Insert lead with email if provided
        const insertResult = await dbQuery(
          `
          INSERT INTO competitor_leads (company_name, reviewer_name, reviewer_title, competitor, star_rating, review_title, complaint_summary, review_date, g2_url, website, email, email_source)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          RETURNING id
        `,
          [
            lead.company_name,
            lead.reviewer_name,
            lead.reviewer_title,
            lead.competitor,
            lead.star_rating,
            lead.review_title,
            lead.complaint_summary,
            lead.review_date,
            lead.g2_url,
            lead.website,
            lead.email || null,
            lead.email ? 'scraped' : null,
          ]
        );
        results.inserted++;

        if (lead.email) {
          results.emails_found++;
        }

        const leadId = insertResult.rows?.[0]?.id;

        // Generate demo and send email if requested
        if (send_emails && lead.email && leadId) {
          try {
            // Generate personalized AI response based on their complaint
            const aiResponse = await generateG2SwitcherResponse(
              lead.company_name,
              lead.reviewer_name,
              lead.competitor,
              lead.complaint_summary
            );

            if (aiResponse) {
              // Send personalized email with their pain point
              const emailSubject = `${lead.company_name} - saw your ${lead.competitor} review`;
              const emailBody = `Hey ${lead.reviewer_name?.split(' ')[0] || 'there'},

Saw your G2 review about ${lead.competitor}. "${lead.complaint_summary?.slice(0, 100)}..." - I get it, that's frustrating.

I built something simpler. No contracts, no hidden fees. Just AI-powered review responses that actually sound human.

Here's what a response for your business could look like:

${aiResponse}

Want to try it? 20 free responses, no credit card:
https://tryreviewresponder.com?ref=g2-${lead.competitor}

Cheers,
Berend

P.S. Happy to hop on a quick call if you want to see how it compares to ${lead.competitor}.`;

              await sendEmail({
                to: lead.email,
                subject: emailSubject,
                text: emailBody,
                type: 'outreach',
                campaign: `g2-switcher-${lead.competitor}`,
                from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
              });

              await dbQuery(
                'UPDATE competitor_leads SET email_sent = TRUE, email_sent_at = NOW() WHERE id = $1',
                [leadId]
              );
              results.emails_sent++;
              results.demos_generated++;
            }
          } catch (emailErr) {
            results.errors.push(`Email failed for ${lead.company_name}: ${emailErr.message}`);
          }
        }
      } catch (leadErr) {
        results.errors.push(`Lead ${lead.company_name}: ${leadErr.message}`);
      }
    }

    res.json({ success: true, ...results, total: leads.length });
  } catch (error) {
    console.error('Competitor leads submission error:', error);
    res.status(500).json({ error: 'Failed to submit leads' });
  }
});

// Helper: Generate personalized G2 switcher response
async function generateG2SwitcherResponse(companyName, reviewerName, competitor, complaint) {
  try {
    const prompt = `Generate a sample review response for a business called "${companyName}".
This is to show them what our AI review response tool can do.

Create a professional, friendly response to a hypothetical negative review.
The response should:
- Be 2-3 sentences
- Sound human, not robotic
- Address a common complaint (slow service, quality issue, etc)
- End with the business name

Do NOT mention ${competitor} or that this is a demo. Just write a great review response.`;

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 200,
      messages: [{ role: 'user', content: prompt }],
    });

    return response.content[0]?.text?.trim() || null;
  } catch (err) {
    console.error('G2 response generation error:', err.message);
    return null;
  }
}

// POST /api/sales/linkedin-leads - Submit LinkedIn leads
app.post('/api/sales/linkedin-leads', async (req, res) => {
  const authKey = req.headers['x-api-key'] || req.query.key;
  if (
    !safeCompare(authKey, process.env.ADMIN_SECRET) &&
    !safeCompare(authKey, process.env.CRON_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { leads } = req.body;
    if (!Array.isArray(leads) || leads.length === 0) {
      return res.status(400).json({ error: 'leads array required' });
    }

    let inserted = 0;
    let skipped = 0;

    for (const lead of leads) {
      const existing = await dbGet('SELECT id FROM linkedin_outreach WHERE linkedin_url = $1', [
        lead.linkedin_url,
      ]);
      if (existing) {
        skipped++;
        continue;
      }

      await dbQuery(
        `
        INSERT INTO linkedin_outreach (name, title, company, location, linkedin_url)
        VALUES ($1, $2, $3, $4, $5)
      `,
        [lead.name, lead.title, lead.company, lead.location, lead.linkedin_url]
      );
      inserted++;
    }

    res.json({ success: true, inserted, skipped, total: leads.length });
  } catch (error) {
    console.error('LinkedIn leads submission error:', error);
    res.status(500).json({ error: 'Failed to submit leads' });
  }
});

// POST /api/outreach/linkedin-demo - Generate personalized demo for LinkedIn outreach
app.post('/api/outreach/linkedin-demo', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.headers['x-api-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized - Admin key required' });
  }

  try {
    const { linkedin_url, first_name, company, business_name, city } = req.body;

    if (!linkedin_url && !business_name) {
      return res.status(400).json({ error: 'Either linkedin_url or business_name required' });
    }

    // Extract first name from full name if not provided
    const contactFirstName = first_name || (req.body.name ? req.body.name.split(' ')[0] : 'there');
    const contactCompany = company || business_name;

    // Try to find the business on Google Maps
    let placeId = null;
    let googleRating = null;
    let totalReviews = 0;
    let scrapedReviews = [];
    let generatedResponses = [];

    const searchName = business_name || contactCompany;
    const searchCity = city || '';

    if (searchName) {
      try {
        const placeResult = await lookupPlaceId(searchName, searchCity);
        placeId = placeResult.placeId;
        googleRating = placeResult.rating;
        totalReviews = placeResult.totalReviews || 0;
      } catch (err) {
        console.log('Place lookup failed:', err.message);
      }
    }

    // If we found a place, try to get reviews and generate demo
    if (placeId && process.env.SERPAPI_KEY) {
      try {
        // Get place details for rating
        const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=rating,user_ratings_total,name&key=${process.env.GOOGLE_PLACES_API_KEY}`;
        const detailsRes = await fetch(detailsUrl);
        const detailsData = await detailsRes.json();

        if (detailsData.result) {
          googleRating = detailsData.result.rating;
          totalReviews = detailsData.result.user_ratings_total || 0;
        }

        // Scrape reviews via SerpAPI
        scrapedReviews = await scrapeGoogleReviews(placeId, 3);

        // Generate AI responses for each review
        for (const review of scrapedReviews) {
          const aiResponse = await generateDemoResponse(
            review,
            searchName,
            null,
            searchCity,
            googleRating,
            totalReviews
          );
          generatedResponses.push({
            review: review,
            ai_response: aiResponse,
          });
        }
      } catch (err) {
        console.log('Review scraping/generation failed:', err.message);
      }
    }

    // Generate demo token
    const demoToken = generateDemoToken();
    const demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;

    // Generate connection note (LinkedIn limit: 200 chars) - SIMPLE & PERSONAL
    let connectionNote;
    if (scrapedReviews.length > 0) {
      // Short business name (first 2 words max)
      const shortBizName = searchName.split(' ').slice(0, 2).join(' ');
      // Simple, mysterious, personal
      connectionNote = `Hey ${contactFirstName}! Made you something for ${shortBizName}: ${demoUrl} - Berend`;
    } else {
      // Fallback without demo
      connectionNote = `Hey ${contactFirstName}! Made something for review responses - would love your take: tryreviewresponder.com - Berend`;
    }

    // Save to database (update existing or insert new)
    let linkedinLeadId;
    if (linkedin_url) {
      const existing = await dbGet('SELECT id FROM linkedin_outreach WHERE linkedin_url = $1', [
        linkedin_url,
      ]);
      if (existing) {
        await dbQuery(
          `
          UPDATE linkedin_outreach
          SET demo_token = $1, demo_url = $2, connection_note = $3,
              business_name = $4, google_place_id = $5, google_rating = $6
          WHERE id = $7
        `,
          [demoToken, demoUrl, connectionNote, searchName, placeId, googleRating, existing.id]
        );
        linkedinLeadId = existing.id;
      } else {
        const inserted = await dbGet(
          `
          INSERT INTO linkedin_outreach (name, company, linkedin_url, demo_token, demo_url, connection_note, business_name, google_place_id, google_rating)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING id
        `,
          [
            req.body.name || contactFirstName,
            contactCompany,
            linkedin_url,
            demoToken,
            demoUrl,
            connectionNote,
            searchName,
            placeId,
            googleRating,
          ]
        );
        linkedinLeadId = inserted.id;
      }
    }

    // Also store in demo_generations if we have reviews
    if (scrapedReviews.length > 0) {
      await dbQuery(
        `
        INSERT INTO demo_generations (business_name, google_place_id, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        ON CONFLICT (demo_token) DO UPDATE SET generated_responses = $7
      `,
        [
          searchName,
          placeId,
          googleRating,
          totalReviews,
          JSON.stringify(scrapedReviews),
          demoToken,
          JSON.stringify(generatedResponses),
        ]
      );
    }

    // Log for sales state tracking
    await logSalesAction('linkedin_demo_created', 'outreach', {
      count: 1,
      business: searchName,
      has_reviews: scrapedReviews.length > 0,
    });

    res.json({
      success: true,
      demo_token: demoToken,
      demo_url: demoUrl,
      connection_note: connectionNote,
      linkedin_lead_id: linkedinLeadId,
      has_reviews: scrapedReviews.length > 0,
      reviews_processed: scrapedReviews.length,
      google_rating: googleRating,
      business_name: searchName,
    });
  } catch (error) {
    console.error('LinkedIn demo generation error:', error);
    res.status(500).json({ error: 'Failed to generate LinkedIn demo' });
  }
});

// GET /api/outreach/linkedin-demo/:id - Get LinkedIn lead with demo info
app.get('/api/outreach/linkedin-demo/:id', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.headers['x-api-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const lead = await dbGet('SELECT * FROM linkedin_outreach WHERE id = $1', [req.params.id]);
    if (!lead) {
      return res.status(404).json({ error: 'Lead not found' });
    }
    res.json(lead);
  } catch (error) {
    console.error('LinkedIn lead fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch lead' });
  }
});

// PUT /api/outreach/linkedin-demo/:id/sent - Mark connection as sent
app.put('/api/outreach/linkedin-demo/:id/sent', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.headers['x-api-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    await dbQuery(
      `
      UPDATE linkedin_outreach
      SET connection_sent = TRUE, connection_sent_at = NOW()
      WHERE id = $1
    `,
      [req.params.id]
    );
    res.json({ success: true });
  } catch (error) {
    console.error('LinkedIn sent update error:', error);
    res.status(500).json({ error: 'Failed to update' });
  }
});

// PUT /api/outreach/linkedin-demo/:id/accepted - Mark connection as accepted
app.put('/api/outreach/linkedin-demo/:id/accepted', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.headers['x-api-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    await dbQuery(
      `
      UPDATE linkedin_outreach
      SET connection_accepted = TRUE, connection_accepted_at = NOW()
      WHERE id = $1
    `,
      [req.params.id]
    );
    res.json({ success: true });
  } catch (error) {
    console.error('LinkedIn accepted update error:', error);
    res.status(500).json({ error: 'Failed to update' });
  }
});

// GET /api/outreach/linkedin-pending - Get LinkedIn leads pending connection
app.get('/api/outreach/linkedin-pending', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.headers['x-api-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);
    const leads = await dbAll(
      `
      SELECT * FROM linkedin_outreach
      WHERE demo_token IS NOT NULL
        AND connection_sent = FALSE
      ORDER BY created_at DESC
      LIMIT $1
    `,
      [limit]
    );
    res.json({ leads, count: leads.length });
  } catch (error) {
    console.error('LinkedIn pending fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch pending leads' });
  }
});

// GET /api/cron/linkedin-demo-daily - Auto-generate LinkedIn demos and send reminder email
app.get('/api/cron/linkedin-demo-daily', async (req, res) => {
  const cronSecret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(cronSecret || '', process.env.CRON_SECRET || '')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const limit = parseInt(req.query.limit) || 5;
    const targetCities = ['Munich', 'Berlin', 'Hamburg', 'Frankfurt', 'Vienna', 'Zurich'];

    const results = {
      searched: 0,
      demos_created: 0,
      demos_failed: 0,
      leads: [],
    };

    // Strategy 1: Find new restaurants via Google Places (rotate through cities)
    const today = new Date().getDay(); // 0-6
    const cityIndex = today % targetCities.length;
    const targetCity = targetCities[cityIndex];

    console.log(`[LinkedIn Demo Daily] Searching restaurants in ${targetCity}...`);

    // Search for restaurants with many reviews in target city
    const searchTypes = ['restaurant', 'hotel', 'cafe'];
    const searchType = searchTypes[today % searchTypes.length];

    try {
      // Use Google Places Text Search
      const searchUrl = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${searchType}+in+${encodeURIComponent(targetCity)}&key=${process.env.GOOGLE_PLACES_API_KEY}`;
      const searchRes = await fetch(searchUrl);
      const searchData = await searchRes.json();

      if (searchData.results && searchData.results.length > 0) {
        // Filter for businesses with good review counts
        const candidates = searchData.results
          .filter(p => p.user_ratings_total >= 100 && p.rating >= 3.5 && p.rating <= 4.5)
          .sort((a, b) => b.user_ratings_total - a.user_ratings_total)
          .slice(0, limit * 2); // Get extra in case some fail

        for (const place of candidates) {
          if (results.demos_created >= limit) break;
          results.searched++;

          // Check if we already have this business
          const existing = await dbGet(
            'SELECT id FROM linkedin_outreach WHERE business_name = $1 OR google_place_id = $2',
            [place.name, place.place_id]
          );

          if (existing) {
            console.log(`[LinkedIn Demo Daily] Skipping ${place.name} - already exists`);
            continue;
          }

          // Also check demo_generations
          const existingDemo = await dbGet(
            'SELECT id FROM demo_generations WHERE business_name = $1 OR google_place_id = $2',
            [place.name, place.place_id]
          );

          if (existingDemo) {
            console.log(`[LinkedIn Demo Daily] Skipping ${place.name} - demo already exists`);
            continue;
          }

          try {
            // Scrape reviews via SerpAPI
            const reviews = await scrapeGoogleReviews(place.place_id, 5);

            // Find reviews to respond to (prefer negative, but take any if none)
            let targetReviews = reviews.filter(r => r.rating <= 3).slice(0, 3);

            // If no negative reviews, take the lowest-rated ones available
            if (targetReviews.length === 0) {
              targetReviews = reviews.sort((a, b) => a.rating - b.rating).slice(0, 3);
            }

            if (targetReviews.length === 0) {
              console.log(`[LinkedIn Demo Daily] ${place.name} has no reviews at all, skipping`);
              continue;
            }

            // Generate AI responses
            const generatedResponses = [];
            for (const review of targetReviews) {
              const aiResponse = await generateDemoResponse(review, place.name);
              generatedResponses.push({
                review: {
                  text: review.text,
                  rating: review.rating,
                  author: review.author,
                  date: review.date,
                  source: 'google',
                },
                ai_response: aiResponse,
              });
            }

            // Generate demo token and save
            const demoToken = generateDemoToken();
            const demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;

            // Save to demo_generations
            await dbQuery(
              `
              INSERT INTO demo_generations
              (business_name, google_place_id, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            `,
              [
                place.name,
                place.place_id,
                targetCity,
                place.rating,
                place.user_ratings_total,
                JSON.stringify(reviews),
                demoToken,
                JSON.stringify(generatedResponses),
              ]
            );

            // Save to linkedin_outreach (without LinkedIn URL - user needs to find it)
            // Simple connection note template - user replaces [NAME] when sending
            const shortBizName = place.name.split(' ').slice(0, 2).join(' ');
            const connectionNote = `Hey [NAME]! Made you something for ${shortBizName}: ${demoUrl} - Berend`;

            const inserted = await dbGet(
              `
              INSERT INTO linkedin_outreach
              (name, company, business_name, google_place_id, google_rating, demo_token, demo_url, connection_note, notes)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
              RETURNING id
            `,
              [
                '[FIND ON LINKEDIN]',
                place.name,
                place.name,
                place.place_id,
                place.rating,
                demoToken,
                demoUrl,
                connectionNote,
                `Auto-generated on ${new Date().toISOString().split('T')[0]}. City: ${targetCity}. Reviews: ${place.user_ratings_total}`,
              ]
            );

            results.demos_created++;
            results.leads.push({
              id: inserted.id,
              business_name: place.name,
              city: targetCity,
              rating: place.rating,
              reviews: place.user_ratings_total,
              demo_url: demoUrl,
              negative_reviews: targetReviews.length,
            });

            console.log(
              `[LinkedIn Demo Daily] Created demo for ${place.name} (${place.rating} stars, ${place.user_ratings_total} reviews)`
            );
          } catch (demoError) {
            console.error(
              `[LinkedIn Demo Daily] Failed to create demo for ${place.name}:`,
              demoError.message
            );
            results.demos_failed++;
          }
        }
      }
    } catch (searchError) {
      console.error('[LinkedIn Demo Daily] Google Places search error:', searchError.message);
    }

    // Send reminder email if we have new leads
    if (results.leads.length > 0) {
      try {
        const leadsList = results.leads
          .map(
            l =>
              `- ${l.business_name} (${l.city}) - ${l.rating} stars, ${l.reviews} reviews\n  Demo: ${l.demo_url}`
          )
          .join('\n\n');

        await resend.emails.send({
          from: 'ReviewResponder <notifications@tryreviewresponder.com>',
          to: 'berend.mainz@web.de',
          subject: `${results.leads.length} neue LinkedIn Leads warten auf dich!`,
          html: `
            <h2>Neue LinkedIn Demos generiert</h2>
            <p>Es wurden <strong>${results.leads.length} neue personalisierte Demos</strong> erstellt.</p>

            <h3>Deine Leads f\xFCr heute:</h3>
            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-size: 14px;">${leadsList}</pre>

            <h3>N\xE4chste Schritte:</h3>
            <ol>
              <li>Finde die Restaurant-Owner auf LinkedIn (suche nach dem Restaurant-Namen)</li>
              <li>Starte Chrome MCP: <code>claude --chrome</code></li>
              <li>Claude sendet die Connection Requests mit den Demo-Links</li>
            </ol>

            <p style="margin-top: 20px;">
              <a href="https://review-responder.onrender.com/api/outreach/linkedin-pending?key=${process.env.ADMIN_SECRET}"
                 style="background: #4f46e5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px;">
                Alle Pending Leads anzeigen
              </a>
            </p>

            <p style="color: #666; font-size: 12px; margin-top: 30px;">
              Stadt heute: ${targetCity} | Typ: ${searchType} | Gesucht: ${results.searched}
            </p>
          `,
        });
        console.log('[LinkedIn Demo Daily] Reminder email sent');
      } catch (emailError) {
        console.error('[LinkedIn Demo Daily] Email error:', emailError.message);
      }
    }

    res.json({
      ok: true,
      city: targetCity,
      type: searchType,
      ...results,
    });
  } catch (error) {
    console.error('[LinkedIn Demo Daily] Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/sales/agency-leads - Submit agency partnership leads
app.post('/api/sales/agency-leads', async (req, res) => {
  const authKey = req.headers['x-api-key'] || req.query.key;
  if (
    !safeCompare(authKey, process.env.ADMIN_SECRET) &&
    !safeCompare(authKey, process.env.CRON_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const { leads } = req.body;
    if (!Array.isArray(leads) || leads.length === 0) {
      return res.status(400).json({ error: 'leads array required' });
    }

    let inserted = 0;
    let skipped = 0;

    for (const lead of leads) {
      const existing = await dbGet('SELECT id FROM agency_leads WHERE clutch_url = $1', [
        lead.clutch_url,
      ]);
      if (existing) {
        skipped++;
        continue;
      }

      await dbQuery(
        `
        INSERT INTO agency_leads (agency_name, website, clutch_url, clutch_rating, num_reviews, services, location, min_project_size, hourly_rate, employees)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      `,
        [
          lead.agency_name,
          lead.website,
          lead.clutch_url,
          lead.clutch_rating,
          lead.num_reviews,
          lead.services,
          lead.location,
          lead.min_project_size,
          lead.hourly_rate,
          lead.employees,
        ]
      );
      inserted++;
    }

    res.json({ success: true, inserted, skipped, total: leads.length });
  } catch (error) {
    console.error('Agency leads submission error:', error);
    res.status(500).json({ error: 'Failed to submit leads' });
  }
});

// GET /api/sales/dashboard - Sales automation dashboard
app.get('/api/sales/dashboard', async (req, res) => {
  const authKey = req.headers['x-api-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const [yelp, competitor, linkedin, agency] = await Promise.all([
      dbAll(
        'SELECT COUNT(*) as total, COUNT(*) FILTER (WHERE email_sent) as emailed, COUNT(*) FILTER (WHERE replied) as replied FROM yelp_leads'
      ),
      dbAll(
        'SELECT COUNT(*) as total, COUNT(*) FILTER (WHERE email_sent) as emailed, COUNT(*) FILTER (WHERE replied) as replied FROM competitor_leads'
      ),
      dbAll(
        'SELECT COUNT(*) as total, COUNT(*) FILTER (WHERE connection_sent) as sent, COUNT(*) FILTER (WHERE connection_accepted) as accepted, COUNT(*) FILTER (WHERE replied) as replied FROM linkedin_outreach'
      ),
      dbAll(
        'SELECT COUNT(*) as total, COUNT(*) FILTER (WHERE email_sequence > 0) as emailed, COUNT(*) FILTER (WHERE replied) as replied, COUNT(*) FILTER (WHERE interested) as interested FROM agency_leads'
      ),
    ]);

    res.json({
      yelp_leads: yelp[0],
      competitor_leads: competitor[0],
      linkedin_outreach: linkedin[0],
      agency_leads: agency[0],
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get dashboard' });
  }
});

// GET /api/admin/scraper-status - Scraper status dashboard with priorities
app.get('/api/admin/scraper-status', async (req, res) => {
  // Accept both x-api-key and x-admin-key for consistency with other admin endpoints
  const authKey = req.headers['x-api-key'] || req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Define thresholds for each source
    const thresholds = {
      g2_competitors: { low: 30, critical: 15 },
      tripadvisor: { low: 20, critical: 10 },
      linkedin: { low: 50, critical: 25 },
      yelp: { low: 20, critical: 10 },
      agency: { low: 10, critical: 5 },
    };

    // Query all lead sources in parallel
    const [
      outreachLeads,
      tripadvisorLeads,
      competitorLeads,
      linkedinLeads,
      yelpLeads,
      agencyLeads,
      emailsToday,
      lastCronRun,
      lastTripadvisorScrape,
    ] = await Promise.all([
      // Main outreach leads (Daily Outreach - excludes TripAdvisor)
      dbGet(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE status = 'new') as not_contacted,
          COUNT(*) FILTER (WHERE email IS NOT NULL) as with_email
        FROM outreach_leads
        WHERE source != 'tripadvisor' OR source IS NULL
      `),
      // TripAdvisor leads (separate source)
      dbGet(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE status = 'new') as not_contacted,
          COUNT(*) FILTER (WHERE email IS NOT NULL) as with_email,
          COUNT(*) FILTER (WHERE demo_url IS NOT NULL) as with_demo,
          MAX(created_at) as last_scraped
        FROM outreach_leads
        WHERE source = 'tripadvisor'
      `),
      // G2 Competitor leads
      dbGet(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE email_sent = FALSE) as not_contacted,
          COUNT(*) FILTER (WHERE competitor = 'birdeye') as birdeye,
          COUNT(*) FILTER (WHERE competitor = 'podium') as podium
        FROM competitor_leads
      `),
      // LinkedIn leads + limits tracking
      dbGet(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE connection_sent = FALSE) as pending,
          COUNT(*) FILTER (WHERE connection_accepted = TRUE) as accepted,
          COUNT(*) FILTER (WHERE demo_viewed_at IS NOT NULL) as demos_viewed,
          -- Daily/Weekly limits tracking
          COUNT(*) FILTER (WHERE DATE(connection_sent_at) = CURRENT_DATE) as connections_today,
          COUNT(*) FILTER (WHERE connection_sent_at >= NOW() - INTERVAL '7 days') as connections_this_week,
          COUNT(*) FILTER (WHERE DATE(message_sent_at) = CURRENT_DATE) as messages_today
        FROM linkedin_outreach
      `),
      // Yelp leads
      dbGet(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE email_sent = FALSE) as not_contacted,
          COUNT(*) FILTER (WHERE email IS NOT NULL) as with_email
        FROM yelp_leads
      `),
      // Agency leads
      dbGet(`
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE email_sequence = 0) as not_contacted
        FROM agency_leads
      `),
      // Emails sent today
      dbGet(`
        SELECT COUNT(*) as count
        FROM outreach_emails
        WHERE DATE(sent_at) = CURRENT_DATE
      `),
      // Last cron run (from email_logs)
      dbGet(`
        SELECT MAX(sent_at) as last_run
        FROM email_logs
        WHERE campaign = 'main' OR campaign = 'review_alert'
      `),
      // Last TripAdvisor email sent
      dbGet(`
        SELECT MAX(sent_at) as last_email
        FROM outreach_emails
        WHERE campaign = 'tripadvisor-review-alert' OR campaign = 'tripadvisor-auto'
      `),
    ]);

    // Helper function to determine status
    const getStatus = (count, threshold) => {
      if (count < threshold.critical) return 'critical';
      if (count < threshold.low) return 'low';
      return 'ok';
    };

    // Build sources array
    const sources = [
      // Tier 1: Automatic
      {
        tier: 1,
        name: 'Daily Outreach',
        type: 'automatic',
        command: null,
        leads_total: parseInt(outreachLeads?.total || 0),
        leads_not_contacted: parseInt(outreachLeads?.not_contacted || 0),
        leads_with_email: parseInt(outreachLeads?.with_email || 0),
        emails_today: parseInt(emailsToday?.count || 0),
        status: 'ok',
        last_run: lastCronRun?.last_run || null,
        priority_reason: '70% aller Leads, automatisch',
      },
      {
        tier: 1,
        name: 'Drip Emails',
        type: 'automatic',
        command: null,
        status: 'ok',
        priority_reason: 'Nurturing, automatisch',
      },
      {
        tier: 1,
        name: 'Blog Generation',
        type: 'automatic',
        command: null,
        status: 'ok',
        priority_reason: 'SEO Traffic, 3x/Woche',
      },
      // Tier 2: Manual + High ROI
      {
        tier: 2,
        name: 'G2 Competitors',
        type: 'manual',
        requires_chrome_mcp: true,
        slash_command: '/g2-miner',
        chrome_command: 'claude --chrome',
        scrape_prompt: '/g2-miner birdeye',
        leads_total: parseInt(competitorLeads?.total || 0),
        leads_not_contacted: parseInt(competitorLeads?.not_contacted || 0),
        by_competitor: {
          birdeye: parseInt(competitorLeads?.birdeye || 0),
          podium: parseInt(competitorLeads?.podium || 0),
        },
        threshold_low: thresholds.g2_competitors.low,
        threshold_critical: thresholds.g2_competitors.critical,
        status: getStatus(parseInt(competitorLeads?.not_contacted || 0), thresholds.g2_competitors),
        priority_reason: 'Pain Point Leads - bereits unzufrieden, Chrome MCP nÃ¶tig',
        workflow: [
          '1. Starte: claude --chrome',
          '2. Tippe: /g2-miner birdeye (oder podium)',
          '3. Claude scraped G2 Reviews automatisch',
          '4. Finde LinkedIn Profiles manuell',
        ],
      },
      {
        tier: 2,
        name: 'TripAdvisor',
        type: 'manual',
        requires_chrome_mcp: true,
        slash_command: '/scrape-leads',
        chrome_command: 'claude --chrome',
        scrape_prompt: '/scrape-leads restaurants munich',
        leads_total: parseInt(tripadvisorLeads?.total || 0),
        leads_not_contacted: parseInt(tripadvisorLeads?.not_contacted || 0),
        leads_with_email: parseInt(tripadvisorLeads?.with_email || 0),
        leads_with_demo: parseInt(tripadvisorLeads?.with_demo || 0),
        last_scraped: tripadvisorLeads?.last_scraped || null,
        last_email_sent: lastTripadvisorScrape?.last_email || null,
        threshold_low: thresholds.tripadvisor.low,
        threshold_critical: thresholds.tripadvisor.critical,
        status: getStatus(parseInt(tripadvisorLeads?.not_contacted || 0), thresholds.tripadvisor),
        priority_reason: 'Restaurants = Hauptzielgruppe, Chrome MCP nÃ¶tig',
        available_cities: [
          'nyc',
          'la',
          'chicago',
          'miami',
          'berlin',
          'munich',
          'hamburg',
          'vienna',
          'zurich',
          'london',
          'paris',
        ],
        workflow: [
          '1. Starte: claude --chrome',
          '2. Tippe: /scrape-leads restaurants [city]',
          '3. Claude scraped TripAdvisor automatisch',
          '4. Cron sendet Emails mit Demos (09:00)',
        ],
      },
      {
        tier: 2,
        name: 'LinkedIn',
        type: 'manual',
        requires_chrome_mcp: true,
        slash_command: '/linkedin-connect',
        chrome_command: 'claude --chrome',
        scrape_prompt: '/linkedin-connect "Restaurant Owner" Germany',
        leads_total: parseInt(linkedinLeads?.total || 0),
        connections_pending: parseInt(linkedinLeads?.pending || 0),
        connections_accepted: parseInt(linkedinLeads?.accepted || 0),
        demos_viewed: parseInt(linkedinLeads?.demos_viewed || 0),
        // LinkedIn Limits Tracking
        limits: {
          connections_today: parseInt(linkedinLeads?.connections_today || 0),
          connections_today_max: 20,
          connections_today_remaining: Math.max(
            0,
            20 - parseInt(linkedinLeads?.connections_today || 0)
          ),
          connections_this_week: parseInt(linkedinLeads?.connections_this_week || 0),
          connections_week_max: 100,
          connections_week_remaining: Math.max(
            0,
            100 - parseInt(linkedinLeads?.connections_this_week || 0)
          ),
          messages_today: parseInt(linkedinLeads?.messages_today || 0),
          messages_today_max: 50,
          messages_today_remaining: Math.max(0, 50 - parseInt(linkedinLeads?.messages_today || 0)),
          // Status indicators
          daily_status:
            parseInt(linkedinLeads?.connections_today || 0) >= 20
              ? 'limit_reached'
              : parseInt(linkedinLeads?.connections_today || 0) >= 15
                ? 'warning'
                : 'ok',
          weekly_status:
            parseInt(linkedinLeads?.connections_this_week || 0) >= 100
              ? 'limit_reached'
              : parseInt(linkedinLeads?.connections_this_week || 0) >= 80
                ? 'warning'
                : 'ok',
        },
        threshold_low: thresholds.linkedin.low,
        threshold_critical: thresholds.linkedin.critical,
        status: getStatus(parseInt(linkedinLeads?.total || 0), thresholds.linkedin),
        priority_reason: 'Direkte Entscheider, Chrome MCP nÃ¶tig',
        workflow: [
          '1. Starte: claude --chrome',
          '2. Tippe: /linkedin-connect "Restaurant Owner" Germany',
          '3. Claude verbindet automatisch (max 20/Tag)',
          '4. Follow-up: /linkedin-connect followup',
        ],
      },
      // Tier 3: Experimental
      {
        tier: 3,
        name: 'Yelp Audit',
        type: 'manual',
        command: '/yelp-audit Berlin restaurants',
        leads_total: parseInt(yelpLeads?.total || 0),
        leads_not_contacted: parseInt(yelpLeads?.not_contacted || 0),
        leads_with_email: parseInt(yelpLeads?.with_email || 0),
        threshold_low: thresholds.yelp.low,
        threshold_critical: thresholds.yelp.critical,
        status: getStatus(parseInt(yelpLeads?.total || 0), thresholds.yelp),
        priority_reason: 'Experimentell - niedrige Response Rate Businesses',
      },
      {
        tier: 3,
        name: 'Agency Recruiter',
        type: 'manual',
        command: '/agency-recruiter local-seo',
        leads_total: parseInt(agencyLeads?.total || 0),
        leads_not_contacted: parseInt(agencyLeads?.not_contacted || 0),
        threshold_low: thresholds.agency.low,
        threshold_critical: thresholds.agency.critical,
        status: getStatus(parseInt(agencyLeads?.total || 0), thresholds.agency),
        priority_reason: 'White-Label Partners = recurring revenue',
      },
    ];

    // Generate recommendations for critical/low sources
    const recommendations = sources
      .filter(s => s.type === 'manual' && (s.status === 'critical' || s.status === 'low'))
      .sort((a, b) => {
        // Sort by tier first, then by status severity
        if (a.tier !== b.tier) return a.tier - b.tier;
        if (a.status === 'critical' && b.status !== 'critical') return -1;
        return 1;
      })
      .map(s => ({
        priority: s.status === 'critical' ? 'high' : 'medium',
        source: s.name,
        leads: s.leads_total,
        threshold: s.threshold_low,
        action: `Starte ${s.scrape_prompt || s.command} - nur ${s.leads_total} Leads`,
        command: s.scrape_prompt || s.command,
      }));

    // Summary stats
    const summary = {
      automatic_sources: sources.filter(s => s.type === 'automatic').length,
      manual_sources: sources.filter(s => s.type === 'manual').length,
      critical_count: sources.filter(s => s.status === 'critical').length,
      low_count: sources.filter(s => s.status === 'low').length,
      total_leads: sources.reduce((sum, s) => sum + (s.leads_total || 0), 0),
    };

    res.json({
      sources,
      recommendations,
      summary,
      notifications: {
        enabled: true,
        email: 'berend.mainz@web.de',
      },
    });
  } catch (error) {
    console.error('Scraper status error:', error);
    res.status(500).json({ error: 'Failed to get scraper status' });
  }
});

// GET /api/cron/scraper-alerts - Send email alerts for low lead sources
app.get('/api/cron/scraper-alerts', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  const force = req.query.force === 'true';

  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Check if we already sent an alert today (unless force=true)
    if (!force) {
      const lastAlert = await dbGet(`
        SELECT sent_at FROM email_logs
        WHERE campaign = 'scraper-alert'
        AND DATE(sent_at) = CURRENT_DATE
        LIMIT 1
      `);
      if (lastAlert) {
        return res.json({ ok: true, message: 'Alert already sent today', skipped: true });
      }
    }

    // Get scraper status
    const statusResponse = await fetch(
      `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/admin/scraper-status?key=${process.env.ADMIN_SECRET}`
    );
    const status = await statusResponse.json();

    // Filter for critical and low sources
    const criticalSources = status.sources.filter(
      s => s.status === 'critical' && s.type === 'manual'
    );
    const lowSources = status.sources.filter(s => s.status === 'low' && s.type === 'manual');

    if (criticalSources.length === 0 && lowSources.length === 0) {
      return res.json({ ok: true, message: 'All sources healthy', alerts: 0 });
    }

    // Build email content
    let emailBody = `Hallo Berend,\n\nDeine wichtigsten manuellen Lead-Quellen brauchen Aufmerksamkeit:\n\n`;

    if (criticalSources.length > 0) {
      emailBody += `KRITISCH:\n`;
      emailBody += `${'â”€'.repeat(40)}\n`;
      for (const s of criticalSources) {
        emailBody += `[!] ${s.name}: ${s.leads_total} Leads (Threshold: ${s.threshold_low})\n`;
        emailBody += `    â†’ ${s.command}\n`;
        emailBody += `    â†’ Warum wichtig: ${s.priority_reason}\n\n`;
      }
    }

    if (lowSources.length > 0) {
      emailBody += `\nNIEDRIG:\n`;
      emailBody += `${'â”€'.repeat(40)}\n`;
      for (const s of lowSources) {
        emailBody += `[*] ${s.name}: ${s.leads_total} Leads (Threshold: ${s.threshold_low})\n`;
        emailBody += `    â†’ ${s.command}\n\n`;
      }
    }

    // Add automatic systems status
    const autoSources = status.sources.filter(s => s.type === 'automatic');
    emailBody += `\nAutomatische Systeme:\n`;
    emailBody += `${'â”€'.repeat(40)}\n`;
    for (const s of autoSources) {
      const leadsInfo = s.leads_total ? ` (${s.leads_total} Leads)` : '';
      emailBody += `[OK] ${s.name}${leadsInfo}\n`;
    }

    emailBody += `\n\nDashboard: https://tryreviewresponder.com/admin\n`;

    // Send email
    const subject =
      criticalSources.length > 0
        ? `Scraper Alert: ${criticalSources.length} kritische Lead-Quelle(n)`
        : `Scraper Alert: ${lowSources.length} Lead-Quelle(n) niedrig`;

    await sendEmail({
      to: 'berend.mainz@web.de',
      subject,
      text: emailBody,
      type: 'transactional',
      campaign: 'scraper-alert',
    });

    res.json({
      ok: true,
      message: 'Alert sent',
      critical: criticalSources.length,
      low: lowSources.length,
    });
  } catch (error) {
    console.error('Scraper alerts error:', error);
    res.status(500).json({ error: error.message?.substring(0, 100) });
  }
});

// GET /api/admin/automation-health - All-in-One Monitoring for Review Alert System
app.get('/api/admin/automation-health', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // 1. Get last Daily Outreach run info
    const lastOutreachEmail = await dbGet(`
      SELECT created_at, campaign FROM outreach_emails
      WHERE campaign IN ('main', 'review_alert')
      ORDER BY created_at DESC LIMIT 1
    `);

    // 2. Get today's stats
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);

    const todayStats = await dbGet(
      `
      SELECT
        COUNT(*) FILTER (WHERE created_at >= $1) as leads_today,
        COUNT(*) FILTER (WHERE demo_url IS NOT NULL AND created_at >= $1) as demos_today,
        COUNT(*) FILTER (WHERE demo_url IS NULL AND ai_response_draft IS NOT NULL AND created_at >= $1) as fallbacks_today
      FROM outreach_leads
    `,
      [todayStart.toISOString()]
    );

    const emailsToday = await dbGet(
      `
      SELECT COUNT(*) as count FROM outreach_emails WHERE created_at >= $1
    `,
      [todayStart.toISOString()]
    );

    // 3. Get demo stats
    const demoStats = await dbGet(`
      SELECT
        COUNT(*) as total_demos,
        COUNT(*) FILTER (WHERE email_sent_at IS NOT NULL) as with_email,
        COUNT(*) FILTER (WHERE demo_page_viewed_at IS NOT NULL) as viewed,
        COUNT(*) FILTER (WHERE converted_at IS NOT NULL) as converted
      FROM demo_generations
    `);

    // 4. Get overall funnel
    const funnelStats = await dbGet(`
      SELECT
        COUNT(*) as total_leads,
        COUNT(*) FILTER (WHERE email IS NOT NULL) as with_email,
        COUNT(*) FILTER (WHERE demo_url IS NOT NULL) as with_demo,
        COUNT(*) FILTER (WHERE status = 'contacted') as contacted
      FROM outreach_leads
    `);

    const openStats = await dbGet(`
      SELECT COUNT(DISTINCT email) as unique_opens FROM outreach_tracking
    `);

    const clickStats = await dbGet(`
      SELECT COUNT(DISTINCT email) as unique_clicks FROM outreach_clicks
    `);

    // 5. API usage estimates (based on recent activity)
    const last7Days = new Date();
    last7Days.setDate(last7Days.getDate() - 7);

    const recentLeads = await dbGet(
      `
      SELECT COUNT(*) as count FROM outreach_leads WHERE created_at >= $1
    `,
      [last7Days.toISOString()]
    );

    const recentDemos = await dbGet(
      `
      SELECT COUNT(*) as count FROM demo_generations WHERE created_at >= $1
    `,
      [last7Days.toISOString()]
    );

    // Calculate estimated API usage
    const leadsPerDay = Math.round(parseInt(recentLeads?.count || 0) / 7);
    const demosPerDay = Math.round(parseInt(recentDemos?.count || 0) / 7);

    // SerpAPI: ~1 request per demo attempt
    const serpApiUsageEstimate = demosPerDay * 30; // Monthly estimate
    const serpApiLimit = 100; // Free tier

    // Google Places: ~1-2 requests per lead
    const googlePlacesCostEstimate = leadsPerDay * 0.017 * 30; // $0.017 per request

    // Hunter.io: Using website scraper, so minimal
    const hunterUsed = await dbGet(
      `
      SELECT COUNT(*) as count FROM outreach_leads
      WHERE email_source = 'hunter' AND created_at >= $1
    `,
      [last7Days.toISOString()]
    );

    // 6. Check for errors/warnings
    const alerts = [];
    const serpApiKeyCount = getSerpApiKeyCount();
    const effectiveSerpApiLimit = serpApiKeyCount * 100; // 100 per key on free tier

    if (serpApiUsageEstimate > effectiveSerpApiLimit * 0.8) {
      alerts.push({
        type: 'warning',
        message: `SerpAPI usage high: ~${serpApiUsageEstimate}/mo (limit: ${effectiveSerpApiLimit} with ${serpApiKeyCount} key${serpApiKeyCount > 1 ? 's' : ''})`,
      });
    }

    if (serpApiKeyCount === 0 && !process.env.OUTSCRAPER_API_KEY && !process.env.SERPER_API_KEY) {
      alerts.push({
        type: 'error',
        message: 'No review scraping API configured (need SERPER_API_KEY, SERPAPI_KEY, or OUTSCRAPER_API_KEY)',
      });
    }

    // Serper.dev check - now our primary review scraper!
    if (process.env.SERPER_API_KEY) {
      alerts.push({
        type: 'info',
        message: 'Serper.dev configured as PRIMARY review scraper (2500 free credits/mo)',
      });
    }

    if (!process.env.GOOGLE_PLACES_API_KEY) {
      alerts.push({
        type: 'error',
        message: 'GOOGLE_PLACES_API_KEY not configured - lead scraping will fail!',
      });
    }

    const hunterLimit = 25;
    const hunterUsedCount = parseInt(hunterUsed?.count || 0);
    if (hunterUsedCount > hunterLimit * 0.7) {
      alerts.push({
        type: 'warning',
        message: `Hunter.io ${Math.round((hunterUsedCount / hunterLimit) * 100)}% used (${hunterUsedCount}/${hunterLimit})`,
      });
    }

    // Calculate rates
    const totalLeads = parseInt(funnelStats?.total_leads || 0);
    const withEmail = parseInt(funnelStats?.with_email || 0);
    const contacted = parseInt(funnelStats?.contacted || 0);
    const uniqueOpens = parseInt(openStats?.unique_opens || 0);
    const uniqueClicks = parseInt(clickStats?.unique_clicks || 0);
    const converted = parseInt(demoStats?.converted || 0);

    res.json({
      daily_outreach: {
        last_run: lastOutreachEmail?.created_at || null,
        last_campaign: lastOutreachEmail?.campaign || null,
        today: {
          leads_scraped: parseInt(todayStats?.leads_today || 0),
          demos_generated: parseInt(todayStats?.demos_today || 0),
          demos_failed_fallback: parseInt(todayStats?.fallbacks_today || 0),
          emails_sent: parseInt(emailsToday?.count || 0),
        },
      },
      api_usage: {
        serpapi: {
          estimated_monthly: serpApiUsageEstimate,
          limit: effectiveSerpApiLimit,
          key_count: serpApiKeyCount,
          percent:
            effectiveSerpApiLimit > 0
              ? Math.round((serpApiUsageEstimate / effectiveSerpApiLimit) * 100)
              : 0,
          note:
            serpApiKeyCount > 1
              ? `${serpApiKeyCount} keys rotating (${effectiveSerpApiLimit} total searches/mo)`
              : null,
        },
        outscraper: {
          configured: getOutscraperKeyCount() > 0,
          key_count: getOutscraperKeyCount(),
          limit_per_key: 500,
          total_limit: getOutscraperKeyCount() * 500,
          note: getOutscraperKeyCount() > 1
            ? `${getOutscraperKeyCount()} keys rotating (${getOutscraperKeyCount() * 500} reviews/mo total)`
            : 'PRIMARY for reviews (500 free/mo)',
        },
        google_places: {
          estimated_monthly_cost_usd: Math.round(googlePlacesCostEstimate * 100) / 100,
          configured: !!process.env.GOOGLE_PLACES_API_KEY,
        },
        hunter_io: {
          used_this_week: hunterUsedCount,
          limit: hunterLimit,
          percent: Math.round((hunterUsedCount / hunterLimit) * 100),
          note: 'Last resort - after scraper, pattern guess, snov.io',
        },
        snov_io: {
          configured: !!(process.env.SNOV_CLIENT_ID && process.env.SNOV_CLIENT_SECRET),
          free_tier_limit: 50,
          note: '50 free/month - 3rd fallback after scraper and pattern',
        },
        apollo_io: {
          configured: !!process.env.APOLLO_API_KEY,
          free_tier_limit: 95,
          note: '95 free credits/month - finds decision makers',
        },
        email_finding: {
          fallback_order: [
            'website_scraper (FREE)',
            'pattern_guess (FREE)',
            'snov.io (50/mo)',
            'apollo.io (95/mo)',
            'hunter.io (25/wk)',
          ],
          note: 'Multi-fallback system maximizes free tier usage',
        },
      },
      funnel: {
        total_leads: totalLeads,
        with_email: withEmail,
        email_rate: totalLeads > 0 ? `${Math.round((withEmail / totalLeads) * 100)}%` : '0%',
        contacted: contacted,
        unique_opens: uniqueOpens,
        open_rate: contacted > 0 ? `${Math.round((uniqueOpens / contacted) * 100)}%` : '0%',
        unique_clicks: uniqueClicks,
        click_rate: contacted > 0 ? `${Math.round((uniqueClicks / contacted) * 100)}%` : '0%',
        conversions: converted,
      },
      demos: {
        total: parseInt(demoStats?.total_demos || 0),
        emails_sent: parseInt(demoStats?.with_email || 0),
        pages_viewed: parseInt(demoStats?.viewed || 0),
        view_rate:
          parseInt(demoStats?.with_email || 0) > 0
            ? `${Math.round((parseInt(demoStats?.viewed || 0) / parseInt(demoStats?.with_email || 0)) * 100)}%`
            : '0%',
        converted: converted,
      },
      alerts,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Automation health error:', error);
    res.status(500).json({ error: error.message?.substring(0, 100) });
  }
});

// GET /api/admin/test-review-scraper - Test SerpAPI + Outscraper integration
app.get('/api/admin/test-review-scraper', async (req, res) => {
  const adminKey = req.query.key;
  if (!safeCompare(adminKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const placeId = req.query.place_id || 'ChIJAVkDPzdOdkgR0qxvevTUGjo'; // Default: Cafe Central Wien
  const forceOutscraper = req.query.force_outscraper === 'true';

  try {
    let reviews;
    let source;

    if (forceOutscraper) {
      // Force Outscraper to test it directly
      if (!process.env.OUTSCRAPER_API_KEY) {
        return res.json({ error: 'OUTSCRAPER_API_KEY not configured', configured: false });
      }
      reviews = await scrapeGoogleReviewsOutscraper(placeId, 3);
      source = 'outscraper_direct';
    } else {
      // Use normal flow (SerpAPI first, Outscraper fallback)
      reviews = await scrapeGoogleReviews(placeId, 3);
      source = 'auto_fallback';
    }

    res.json({
      success: true,
      source,
      place_id: placeId,
      reviews_found: reviews.length,
      reviews: reviews.map(r => ({
        author: r.author,
        rating: r.rating,
        text: r.text?.substring(0, 100) + (r.text?.length > 100 ? '...' : ''),
      })),
      apis_configured: {
        serper: !!process.env.SERPER_API_KEY,
        serpapi: !!getNextSerpApiKey(),
        serpapi_keys: getSerpApiKeyCount(),
        outscraper: !!process.env.OUTSCRAPER_API_KEY,
        outscraper_keys: getOutscraperKeyCount(),
      },
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
      apis_configured: {
        serper: !!process.env.SERPER_API_KEY,
        serpapi: !!getNextSerpApiKey(),
        serpapi_keys: getSerpApiKeyCount(),
        outscraper: !!process.env.OUTSCRAPER_API_KEY,
        outscraper_keys: getOutscraperKeyCount(),
      },
    });
  }
});

// GET /api/cron/send-yelp-emails - Send emails to Yelp leads
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/send-yelp-emails', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Get leads with email but not yet emailed (max 20 per run)
    const leads = await dbAll(`
      SELECT * FROM yelp_leads
      WHERE email IS NOT NULL AND email_sent = FALSE
      ORDER BY created_at DESC
      LIMIT 20
    `);

    if (leads.length === 0) {
      return res.json({ message: 'No Yelp leads to email', sent: 0 });
    }

    let sent = 0;
    let failed = 0;

    for (const lead of leads) {
      try {
        const unanswered = lead.total_reviews - lead.owner_responses;
        const subject = SALES_EMAIL_TEMPLATES.yelp_audit.subject
          .replace('{business_name}', lead.business_name)
          .replace('{unanswered}', unanswered);

        const body = SALES_EMAIL_TEMPLATES.yelp_audit.body
          .replace(/{business_name}/g, lead.business_name)
          .replace('{total_reviews}', lead.total_reviews)
          .replace('{owner_responses}', lead.owner_responses)
          .replace('{response_rate}', lead.response_rate)
          .replace(/{unanswered}/g, unanswered)
          .replace('{city}', lead.city || 'general');

        if (resend || brevoApi) {
          await sendEmail({
            to: lead.email,
            subject: subject,
            text: body,
            type: 'outreach',
            campaign: 'yelp-audit',
            from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
          });

          await dbQuery(
            'UPDATE yelp_leads SET email_sent = TRUE, email_sent_at = NOW() WHERE id = $1',
            [lead.id]
          );
          sent++;
        }
      } catch (emailError) {
        console.error(`Failed to send email to ${lead.email}:`, emailError.message);
        failed++;
      }
    }

    res.json({ success: true, sent, failed, total: leads.length });
  } catch (error) {
    console.error('Yelp email cron error:', error);
    res.status(500).json({ error: 'Yelp email cron failed' });
  }
});

// GET /api/cron/send-g2-emails - Send emails + follow-ups to G2 competitor leads
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/send-g2-emails', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const results = { first_emails: 0, followups: 0, failed: 0 };

    // 1. Send first emails to new leads
    const newLeads = await dbAll(`
      SELECT * FROM competitor_leads
      WHERE email IS NOT NULL AND email_sent = FALSE
      ORDER BY created_at DESC
      LIMIT 10
    `);

    for (const lead of newLeads) {
      try {
        const firstName = lead.reviewer_name?.split(' ')[0] || 'there';
        const subject = `${lead.company_name} - saw your ${lead.competitor} review`;
        const body = `Hey ${firstName},

Saw your G2 review about ${lead.competitor}. "${(lead.complaint_summary || 'the issues you mentioned')?.slice(0, 80)}..." - I totally get it.

Built something simpler. No contracts, no hidden fees. AI-powered review responses that actually sound human.

20 free responses, no credit card:
https://tryreviewresponder.com?ref=g2-${lead.competitor}

Cheers,
Berend`;

        await sendEmail({
          to: lead.email,
          subject,
          text: body,
          type: 'outreach',
          campaign: `g2-switcher-${lead.competitor}`,
          from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
        });

        await dbQuery(
          'UPDATE competitor_leads SET email_sent = TRUE, email_sent_at = NOW() WHERE id = $1',
          [lead.id]
        );
        results.first_emails++;
      } catch (err) {
        console.error(`G2 first email failed for ${lead.email}:`, err.message);
        results.failed++;
      }
    }

    // 2. Send follow-ups (4 days after first email, no reply)
    const followupLeads = await dbAll(`
      SELECT * FROM competitor_leads
      WHERE email IS NOT NULL
        AND email_sent = TRUE
        AND followup_sent = FALSE
        AND replied = FALSE
        AND email_sent_at < NOW() - INTERVAL '4 days'
      ORDER BY email_sent_at ASC
      LIMIT 10
    `);

    for (const lead of followupLeads) {
      try {
        const firstName = lead.reviewer_name?.split(' ')[0] || 'there';
        const subject = `Re: ${lead.company_name}`;
        const body = `Hey ${firstName},

Quick follow-up - did you get a chance to check out the review response tool?

I know switching from ${lead.competitor} feels like a hassle, but honestly it takes 2 minutes to try:
https://tryreviewresponder.com?ref=g2-followup

No signup needed for the first 20 responses.

Let me know if you have any questions!

Berend`;

        await sendEmail({
          to: lead.email,
          subject,
          text: body,
          type: 'outreach',
          campaign: `g2-followup-${lead.competitor}`,
          from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
        });

        await dbQuery(
          'UPDATE competitor_leads SET followup_sent = TRUE, followup_sent_at = NOW() WHERE id = $1',
          [lead.id]
        );
        results.followups++;
      } catch (err) {
        console.error(`G2 followup failed for ${lead.email}:`, err.message);
        results.failed++;
      }
    }

    console.log(
      `G2 cron: ${results.first_emails} first, ${results.followups} followups, ${results.failed} failed`
    );
    res.json({ ok: true, ...results });
  } catch (error) {
    console.error('G2 email cron error:', error);
    res.status(500).json({ ok: false, err: error.message?.slice(0, 100) });
  }
});

// GET /api/cron/send-agency-emails - Send partnership emails to agencies
// Changed from POST to GET for cron-job.org compatibility (14.01.2026)
app.get('/api/cron/send-agency-emails', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Get agencies for initial email (sequence 0) or follow-ups
    const newLeads = await dbAll(`
      SELECT * FROM agency_leads
      WHERE email IS NOT NULL AND email_sequence = 0
      ORDER BY created_at DESC
      LIMIT 10
    `);

    // Get leads for follow-up (sent > 4 days ago, sequence 1)
    const followupLeads = await dbAll(`
      SELECT * FROM agency_leads
      WHERE email IS NOT NULL
        AND email_sequence = 1
        AND last_email_sent < NOW() - INTERVAL '4 days'
        AND replied = FALSE
      LIMIT 10
    `);

    let sent = 0;
    let failed = 0;

    // Send initial emails
    for (const lead of newLeads) {
      try {
        const contactName = lead.contact_name || 'there';
        const subject = SALES_EMAIL_TEMPLATES.agency_partnership.subject.replace(
          '{agency_name}',
          lead.agency_name
        );

        const body = SALES_EMAIL_TEMPLATES.agency_partnership.body
          .replace(/{agency_name}/g, lead.agency_name)
          .replace('{contact_name}', contactName);

        if (resend || brevoApi) {
          await sendEmail({
            to: lead.email,
            subject: subject,
            text: body,
            type: 'outreach',
            campaign: 'agency-partnership',
            from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
          });

          await dbQuery(
            'UPDATE agency_leads SET email_sequence = 1, last_email_sent = NOW() WHERE id = $1',
            [lead.id]
          );
          sent++;
        }
      } catch (emailError) {
        console.error(`Failed to send email to ${lead.email}:`, emailError.message);
        failed++;
      }
    }

    // Send follow-up emails
    for (const lead of followupLeads) {
      try {
        const contactName = lead.contact_name || 'there';
        const subject = SALES_EMAIL_TEMPLATES.agency_followup_1.subject.replace(
          '{agency_name}',
          lead.agency_name
        );

        const body = SALES_EMAIL_TEMPLATES.agency_followup_1.body
          .replace(/{agency_name}/g, lead.agency_name)
          .replace('{contact_name}', contactName);

        if (resend || brevoApi) {
          await sendEmail({
            to: lead.email,
            subject: subject,
            text: body,
            type: 'outreach',
            campaign: 'agency-followup',
            from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
          });

          await dbQuery(
            'UPDATE agency_leads SET email_sequence = 2, last_email_sent = NOW() WHERE id = $1',
            [lead.id]
          );
          sent++;
        }
      } catch (emailError) {
        console.error(`Failed to send followup to ${lead.email}:`, emailError.message);
        failed++;
      }
    }

    res.json({
      success: true,
      sent,
      failed,
      newLeads: newLeads.length,
      followups: followupLeads.length,
    });
  } catch (error) {
    console.error('Agency email cron error:', error);
    res.status(500).json({ error: 'Agency email cron failed' });
  }
});

// ============== OMNICHANNEL OUTREACH ==============
// Multi-platform demo delivery - Email + Twitter + Facebook + Instagram + LinkedIn

// GET /api/admin/leads-for-omnichannel - Get leads with demos ready for multi-channel outreach
app.get('/api/admin/leads-for-omnichannel', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const channel = req.query.channel; // Optional: filter by channel not yet contacted
    const limit = parseInt(req.query.limit) || 20;

    let query = `
      SELECT
        l.id, l.business_name, l.website, l.email, l.city, l.contact_name,
        l.demo_url, l.demo_token,
        l.twitter_handle, l.facebook_page, l.instagram_handle, l.linkedin_company,
        l.channels_contacted
      FROM outreach_leads l
      WHERE l.demo_url IS NOT NULL
        AND l.website IS NOT NULL
        ${getTestEmailExcludeClause('l.email')}
    `;

    // Filter by channel if specified
    if (channel) {
      query += ` AND (l.channels_contacted IS NULL OR NOT (l.channels_contacted ? '${channel}'))`;
    }

    query += ` ORDER BY l.created_at DESC LIMIT $1`;

    const leads = await dbAll(query, [limit]);

    res.json({
      success: true,
      count: leads.length,
      leads: leads,
      channels: ['twitter', 'facebook', 'instagram', 'linkedin'],
    });
  } catch (error) {
    console.error('Omnichannel leads error:', error);
    res.status(500).json({ error: 'Failed to get leads' });
  }
});

// PUT /api/admin/lead-social-links - Update lead with discovered social links
app.put('/api/admin/lead-social-links', async (req, res) => {
  const authKey = req.headers['x-admin-key'];
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { lead_id, twitter_handle, facebook_page, instagram_handle, linkedin_company, google_business_url, contact_form_url } = req.body;

  if (!lead_id) {
    return res.status(400).json({ error: 'lead_id required' });
  }

  try {
    const updates = [];
    const values = [];
    let paramIndex = 1;

    if (twitter_handle !== undefined) {
      updates.push(`twitter_handle = $${paramIndex++}`);
      values.push(twitter_handle);
    }
    if (facebook_page !== undefined) {
      updates.push(`facebook_page = $${paramIndex++}`);
      values.push(facebook_page);
    }
    if (instagram_handle !== undefined) {
      updates.push(`instagram_handle = $${paramIndex++}`);
      values.push(instagram_handle);
    }
    if (linkedin_company !== undefined) {
      updates.push(`linkedin_company = $${paramIndex++}`);
      values.push(linkedin_company);
    }
    if (google_business_url !== undefined) {
      updates.push(`google_business_url = $${paramIndex++}`);
      values.push(google_business_url);
    }
    if (contact_form_url !== undefined) {
      updates.push(`contact_form_url = $${paramIndex++}`);
      values.push(contact_form_url);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No social links provided' });
    }

    values.push(lead_id);
    await dbQuery(
      `UPDATE outreach_leads SET ${updates.join(', ')} WHERE id = $${paramIndex}`,
      values
    );

    res.json({ success: true, updated: updates.length });
  } catch (error) {
    console.error('Update social links error:', error);
    res.status(500).json({ error: 'Failed to update' });
  }
});

// PUT /api/admin/mark-channel-contacted - Mark a channel as contacted for a lead
app.put('/api/admin/mark-channel-contacted', async (req, res) => {
  const authKey = req.headers['x-admin-key'];
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { lead_id, channel, message_sent, error: sendError } = req.body;

  if (!lead_id || !channel) {
    return res.status(400).json({ error: 'lead_id and channel required' });
  }

  const validChannels = ['email', 'twitter', 'facebook', 'instagram', 'linkedin', 'google_business', 'contact_form'];
  if (!validChannels.includes(channel)) {
    return res.status(400).json({ error: `Invalid channel. Valid: ${validChannels.join(', ')}` });
  }

  try {
    // Update channels_contacted JSONB
    await dbQuery(
      `UPDATE outreach_leads
       SET channels_contacted = COALESCE(channels_contacted, '{}'::jsonb) || $1::jsonb
       WHERE id = $2`,
      [JSON.stringify({ [channel]: { sent_at: new Date().toISOString(), success: !sendError, error: sendError || null } }), lead_id]
    );

    res.json({ success: true, channel, lead_id });
  } catch (error) {
    console.error('Mark channel contacted error:', error);
    res.status(500).json({ error: 'Failed to update' });
  }
});

// GET /api/admin/omnichannel-stats - Get stats on multi-channel outreach
app.get('/api/admin/omnichannel-stats', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Count leads with demos
    const leadsWithDemos = await dbGet('SELECT COUNT(*) as count FROM outreach_leads WHERE demo_url IS NOT NULL');

    // Count leads with social links found
    const withTwitter = await dbGet('SELECT COUNT(*) as count FROM outreach_leads WHERE twitter_handle IS NOT NULL');
    const withFacebook = await dbGet('SELECT COUNT(*) as count FROM outreach_leads WHERE facebook_page IS NOT NULL');
    const withInstagram = await dbGet('SELECT COUNT(*) as count FROM outreach_leads WHERE instagram_handle IS NOT NULL');
    const withLinkedIn = await dbGet('SELECT COUNT(*) as count FROM outreach_leads WHERE linkedin_company IS NOT NULL');

    // Count contacted by channel (from JSONB)
    const contactedByChannel = {};
    for (const channel of ['email', 'twitter', 'facebook', 'instagram', 'linkedin']) {
      const result = await dbGet(
        `SELECT COUNT(*) as count FROM outreach_leads WHERE channels_contacted ? $1`,
        [channel]
      );
      contactedByChannel[channel] = parseInt(result?.count || 0);
    }

    res.json({
      success: true,
      leads_with_demos: parseInt(leadsWithDemos?.count || 0),
      social_links_found: {
        twitter: parseInt(withTwitter?.count || 0),
        facebook: parseInt(withFacebook?.count || 0),
        instagram: parseInt(withInstagram?.count || 0),
        linkedin: parseInt(withLinkedIn?.count || 0),
      },
      contacted_by_channel: contactedByChannel,
      potential_reach: {
        twitter: parseInt(withTwitter?.count || 0) - contactedByChannel.twitter,
        facebook: parseInt(withFacebook?.count || 0) - contactedByChannel.facebook,
        instagram: parseInt(withInstagram?.count || 0) - contactedByChannel.instagram,
        linkedin: parseInt(withLinkedIn?.count || 0) - contactedByChannel.linkedin,
      },
    });
  } catch (error) {
    console.error('Omnichannel stats error:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// ============== CHROME MCP INTEGRATION ENDPOINTS ==============
// These endpoints support the night agents for Chrome MCP email finding and demo generation

// GET /api/admin/lead-needs-email - Get a lead that needs high-quality email
app.get('/api/admin/lead-needs-email', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Find lead that has generic/no email but has a website to scrape
    const lead = await dbGet(`
      SELECT id, business_name, city, website, email, google_place_id, google_reviews_count
      FROM outreach_leads
      WHERE website IS NOT NULL
        AND website != ''
        AND (
          email IS NULL
          OR email LIKE 'info@%'
          OR email LIKE 'contact@%'
          OR email LIKE 'hello@%'
          OR email LIKE 'office@%'
        )
        AND status = 'new'
      ORDER BY google_reviews_count DESC NULLS LAST
      LIMIT 1
    `);

    res.json(lead || null);
  } catch (error) {
    console.error('Lead needs email error:', error);
    res.status(500).json({ error: 'Failed to get lead' });
  }
});

// GET /api/admin/lead-needs-demo - Get a lead that has email but no demo
app.get('/api/admin/lead-needs-demo', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // Find lead with email but no demo yet
    const lead = await dbGet(`
      SELECT id, business_name, city, website, email, google_place_id, google_reviews_count
      FROM outreach_leads
      WHERE email IS NOT NULL
        AND email != ''
        AND demo_url IS NULL
        AND status = 'new'
      ORDER BY google_reviews_count DESC NULLS LAST
      LIMIT 1
    `);

    res.json(lead || null);
  } catch (error) {
    console.error('Lead needs demo error:', error);
    res.status(500).json({ error: 'Failed to get lead' });
  }
});

// GET /api/admin/leads-needing-enrichment - Get batch of leads for enrichment
app.get('/api/admin/leads-needing-enrichment', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const limit = parseInt(req.query.limit) || 50;

  try {
    // Get leads needing email (have website but generic/no email)
    const needsEmail = await dbAll(`
      SELECT id, business_name, city, website, email, google_reviews_count
      FROM outreach_leads
      WHERE website IS NOT NULL AND website != ''
        AND (
          email IS NULL
          OR email LIKE 'info@%'
          OR email LIKE 'contact@%'
          OR email LIKE 'hello@%'
          OR email LIKE 'office@%'
        )
        AND status = 'new'
      ORDER BY google_reviews_count DESC NULLS LAST
      LIMIT $1
    `, [Math.ceil(limit / 2)]);

    // Get leads needing demo (have email but no demo)
    const needsDemo = await dbAll(`
      SELECT id, business_name, city, email, google_place_id, google_reviews_count
      FROM outreach_leads
      WHERE email IS NOT NULL AND email != ''
        AND demo_url IS NULL
        AND status = 'new'
      ORDER BY google_reviews_count DESC NULLS LAST
      LIMIT $1
    `, [Math.ceil(limit / 2)]);

    // Get totals for progress tracking
    const totalNeedsEmail = await dbGet(`
      SELECT COUNT(*) as count FROM outreach_leads
      WHERE website IS NOT NULL AND website != ''
        AND (email IS NULL OR email LIKE 'info@%' OR email LIKE 'contact@%' OR email LIKE 'hello@%' OR email LIKE 'office@%')
        AND status = 'new'
    `);

    const totalNeedsDemo = await dbGet(`
      SELECT COUNT(*) as count FROM outreach_leads
      WHERE email IS NOT NULL AND email != ''
        AND demo_url IS NULL
        AND status = 'new'
    `);

    res.json({
      needs_email: needsEmail || [],
      needs_demo: needsDemo || [],
      totals: {
        needs_email: parseInt(totalNeedsEmail?.count || 0),
        needs_demo: parseInt(totalNeedsDemo?.count || 0)
      }
    });
  } catch (error) {
    console.error('Leads needing enrichment error:', error);
    res.status(500).json({ error: 'Failed to get leads' });
  }
});

// POST /api/admin/save-found-email - Save email found via Chrome MCP
app.post('/api/admin/save-found-email', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { lead_id, email, source, confidence, owner_name } = req.body;

  if (!lead_id || !email) {
    return res.status(400).json({ error: 'lead_id and email are required' });
  }

  try {
    // Update the lead with the found email
    await dbQuery(`
      UPDATE outreach_leads
      SET
        email = $1,
        email_source = $2,
        owner_name = COALESCE($3, owner_name),
        updated_at = NOW()
      WHERE id = $4
    `, [email, source || 'chrome_mcp', owner_name, lead_id]);

    console.log(`[Chrome MCP] Saved email for lead ${lead_id}: ${email} (source: ${source}, confidence: ${confidence})`);

    res.json({
      success: true,
      lead_id,
      email,
      source
    });
  } catch (error) {
    console.error('Save found email error:', error);
    res.status(500).json({ error: 'Failed to save email' });
  }
});

// POST /api/admin/save-demo-from-chrome - Save demo generated via Chrome MCP scraping
app.post('/api/admin/save-demo-from-chrome', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { lead_id, reviews, responses, source } = req.body;

  if (!lead_id || !reviews || !responses) {
    return res.status(400).json({ error: 'lead_id, reviews, and responses are required' });
  }

  try {
    // Get lead info
    const lead = await dbGet('SELECT * FROM outreach_leads WHERE id = $1', [lead_id]);
    if (!lead) {
      return res.status(404).json({ error: 'Lead not found' });
    }

    // Generate demo token
    const demoToken = 'rr-demo-' + require('crypto').randomBytes(6).toString('hex');

    // Store in demo_generations
    await dbQuery(`
      INSERT INTO demo_generations (
        business_name, google_place_id, reviews_data, responses_data,
        demo_token, source, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, NOW())
      ON CONFLICT (google_place_id) WHERE google_place_id IS NOT NULL
      DO UPDATE SET
        reviews_data = $3,
        responses_data = $4,
        demo_token = $5,
        updated_at = NOW()
    `, [
      lead.business_name,
      lead.google_place_id,
      JSON.stringify(reviews),
      JSON.stringify(responses),
      demoToken,
      source || 'chrome_maps_scrape'
    ]);

    // Update lead with demo URL
    const demoUrl = `https://tryreviewresponder.com/demo/${demoToken}`;
    await dbQuery(`
      UPDATE outreach_leads
      SET demo_url = $1, demo_token = $2, updated_at = NOW()
      WHERE id = $3
    `, [demoUrl, demoToken, lead_id]);

    console.log(`[Chrome MCP] Saved demo for lead ${lead_id}: ${demoUrl} (${reviews.length} reviews)`);

    res.json({
      success: true,
      lead_id,
      demo_url: demoUrl,
      demo_token: demoToken,
      reviews_count: reviews.length
    });
  } catch (error) {
    console.error('Save demo from chrome error:', error);
    res.status(500).json({ error: 'Failed to save demo' });
  }
});

// GET /api/admin/premium-ready-count - Count leads with both email AND demo (ready for outreach)
app.get('/api/admin/premium-ready-count', async (req, res) => {
  const authKey = req.headers['x-admin-key'] || req.query.key;
  if (!safeCompare(authKey, process.env.ADMIN_SECRET)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const premiumReady = await dbGet(`
      SELECT COUNT(*) as count
      FROM outreach_leads
      WHERE email IS NOT NULL
        AND email != ''
        AND email NOT LIKE 'info@%'
        AND email NOT LIKE 'contact@%'
        AND demo_url IS NOT NULL
        AND status = 'new'
    `);

    const totalWithDemo = await dbGet(`
      SELECT COUNT(*) as count
      FROM outreach_leads
      WHERE demo_url IS NOT NULL
    `);

    const totalWithEmail = await dbGet(`
      SELECT COUNT(*) as count
      FROM outreach_leads
      WHERE email IS NOT NULL AND email != ''
    `);

    const totalWithPersonalEmail = await dbGet(`
      SELECT COUNT(*) as count
      FROM outreach_leads
      WHERE email IS NOT NULL
        AND email != ''
        AND email NOT LIKE 'info@%'
        AND email NOT LIKE 'contact@%'
        AND email NOT LIKE 'hello@%'
        AND email NOT LIKE 'office@%'
    `);

    res.json({
      premium_ready: parseInt(premiumReady?.count || 0),
      with_demo: parseInt(totalWithDemo?.count || 0),
      with_email: parseInt(totalWithEmail?.count || 0),
      with_personal_email: parseInt(totalWithPersonalEmail?.count || 0),
      conversion_rate: totalWithEmail?.count > 0
        ? ((premiumReady?.count || 0) / (totalWithEmail?.count) * 100).toFixed(1) + '%'
        : '0%'
    });
  } catch (error) {
    console.error('Premium ready count error:', error);
    res.status(500).json({ error: 'Failed to get count' });
  }
});

// ============== BATCH PRE-SCRAPING ==============
// Pre-scrape reviews for leads to fill cache BEFORE daily outreach
// Run weekly via cron to ensure every lead gets a demo
app.get('/api/cron/batch-prescrape', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const limit = parseInt(req.query.limit) || 50;
  const results = { scraped: 0, cached: 0, failed: 0, skipped: 0 };

  try {
    // Find leads with email but no cached reviews (priority: high review count businesses)
    const leads = await dbAll(
      `SELECT DISTINCT ol.id, ol.business_name, ol.city, ol.google_place_id
       FROM outreach_leads ol
       LEFT JOIN demo_generations dg ON ol.google_place_id = dg.google_place_id
         AND dg.created_at > NOW() - INTERVAL '90 days'
       WHERE ol.email IS NOT NULL
       AND ol.google_place_id IS NOT NULL
       AND dg.id IS NULL
       AND ol.google_reviews_count >= 20
       ORDER BY ol.google_reviews_count DESC
       LIMIT $1`,
      [limit]
    );

    console.log(`[BATCH-PRESCRAPE] Found ${leads.length} leads without cached reviews`);

    for (const lead of leads) {
      try {
        // Check if we already have cached reviews (double-check)
        const existingCache = await dbQuery(
          `SELECT id FROM demo_generations
           WHERE google_place_id = $1
           AND created_at > NOW() - INTERVAL '90 days'`,
          [lead.google_place_id]
        );

        if (existingCache.rows.length > 0) {
          results.skipped++;
          continue;
        }

        // Scrape reviews (uses our 5-tier fallback: cache â†’ outscraper â†’ serpapi â†’ apify â†’ google places)
        const reviews = await scrapeGoogleReviews(lead.google_place_id, 10);

        if (reviews.length > 0) {
          // Save to demo_generations as cache (without actually generating AI responses yet)
          await dbQuery(
            `INSERT INTO demo_generations
             (business_name, google_place_id, city, scraped_reviews, demo_token, generated_responses)
             VALUES ($1, $2, $3, $4, $5, $6)
             ON CONFLICT (google_place_id) DO UPDATE SET
               scraped_reviews = EXCLUDED.scraped_reviews,
               created_at = NOW()`,
            [
              lead.business_name,
              lead.google_place_id,
              lead.city,
              JSON.stringify(reviews),
              `prescrape_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
              JSON.stringify([]), // Empty responses - will be generated on-demand
            ]
          );

          results.scraped++;
          console.log(`[BATCH-PRESCRAPE] Cached ${reviews.length} reviews for ${lead.business_name}`);
        } else {
          results.failed++;
        }

        // Rate limit: 1 request per 2 seconds
        await new Promise((r) => setTimeout(r, 2000));
      } catch (err) {
        console.error(`[BATCH-PRESCRAPE] Error for ${lead.business_name}: ${err.message}`);
        results.failed++;
      }
    }

    // Log action
    await logSalesAction('batch_prescrape', 'cron', {
      leads_checked: leads.length,
      reviews_scraped: results.scraped,
      failed: results.failed,
    });

    res.json({
      success: true,
      message: `Pre-scraped reviews for ${results.scraped} businesses`,
      results,
      next_run: 'Weekly recommended - fills cache before daily outreach',
    });
  } catch (error) {
    console.error('[BATCH-PRESCRAPE] Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============== NIGHT BLAST AUTOMATION ==============
// Aggressive night-time sales automation - runs multiple cities, all follow-ups, all email queues
// Designed to run 3x per night (22:00, 02:00, 06:00) via cron-job.org
// NO Chrome MCP needed - all API-based

app.get('/api/cron/night-blast', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'] || req.query.secret;
  if (
    !safeCompare(cronSecret, process.env.CRON_SECRET) &&
    !safeCompare(cronSecret, process.env.ADMIN_SECRET)
  ) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  console.log('ðŸŒ™ NIGHT BLAST STARTED - Aggressive sales automation...');
  const startTime = Date.now();
  const results = {
    phase1_scraping: null,
    phase2_email_finding: null,
    phase3_demo_generation: null,
    phase4_hot_lead_followups: null,
    phase5_second_followups: null,
    phase6_demo_followups: null,
    phase7_g2_enrichment: null,
    phase8_source_emails: null,
    phase9_social_scraping: null,
  };

  try {
    // ===== PHASE 1: MULTI-CITY SCRAPING =====
    // Scrape 5 cities instead of 1 for aggressive lead generation
    console.log('ðŸ“ Phase 1: Multi-City Scraping...');

    const cities = [
      'New York',
      'Los Angeles',
      'Chicago',
      'Houston',
      'Miami',
      'Phoenix',
      'Philadelphia',
      'San Antonio',
      'San Diego',
      'Dallas',
      'San Jose',
      'Austin',
      'Jacksonville',
      'San Francisco',
      'Seattle',
      'Denver',
      'Boston',
      'Las Vegas',
      'Portland',
      'Atlanta',
      'London',
      'Dublin',
      'Berlin',
      'MÃ¼nchen',
      'Hamburg',
      'Frankfurt',
      'KÃ¶ln',
      'Stuttgart',
      'DÃ¼sseldorf',
      'Wien',
      'ZÃ¼rich',
      'Genf',
      'Leipzig',
      'Dresden',
      'Hannover',
      'NÃ¼rnberg',
      'Bremen',
      'Essen',
      'Salzburg',
      'Graz',
      'Linz',
      'Innsbruck',
      'Basel',
      'Bern',
      'Amsterdam',
      'BrÃ¼ssel',
    ];

    const industries = [
      'restaurant',
      'hotel',
      'dental office',
      'law firm',
      'auto repair shop',
      'hair salon',
      'gym',
      'real estate agency',
      'medical clinic',
      'retail store',
      'spa',
      'veterinary clinic',
      'physiotherapy',
      'accounting firm',
      'bakery',
      'coffee shop',
      'car dealership',
      'optician',
      'pharmacy',
      'florist',
    ];

    let totalScraped = 0;
    const citiesToScrape = 5; // Scrape 5 cities per night-blast run
    const leadsPerCity = 20; // 20 leads per city = 100 total

    // Calculate starting index based on hour to avoid overlap between runs
    const hourOfDay = new Date().getHours();
    const dayOfYear = Math.floor(
      (new Date() - new Date(new Date().getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)
    );
    const startCityIndex = (dayOfYear * 3 + Math.floor(hourOfDay / 8)) * citiesToScrape;

    if (process.env.GOOGLE_PLACES_API_KEY) {
      for (let i = 0; i < citiesToScrape; i++) {
        const cityIndex = (startCityIndex + i) % cities.length;
        const industryIndex = (dayOfYear + i) % industries.length;
        const city = cities[cityIndex];
        const industry = industries[industryIndex];

        try {
          const scrapeUrl = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(industry + ' in ' + city)}&key=${process.env.GOOGLE_PLACES_API_KEY}`;
          const response = await fetch(scrapeUrl);
          const data = await response.json();

          logApiCall({
            provider: 'google_places',
            endpoint: '/api/cron/night-blast',
            metadata: {
              type: 'textsearch',
              city,
              industry,
              resultsCount: data.results?.length || 0,
            },
          });

          if (data.results) {
            for (const place of data.results.slice(0, leadsPerCity)) {
              try {
                const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${place.place_id}&fields=name,formatted_address,formatted_phone_number,website,rating,user_ratings_total,reviews&key=${process.env.GOOGLE_PLACES_API_KEY}`;
                const detailsResponse = await fetch(detailsUrl);
                const details = await detailsResponse.json();

                if (details.status === 'OK') {
                  const result = details.result;

                  // Find worst review for personalized outreach
                  let worstReview = null;
                  if (result.reviews && result.reviews.length > 0) {
                    const badReviews = result.reviews.filter(r => r.rating <= 2);
                    if (badReviews.length > 0) {
                      worstReview = badReviews.reduce((worst, current) =>
                        (current.text?.length || 0) > (worst.text?.length || 0) ? current : worst
                      );
                    }
                  }

                  await dbQuery(
                    `INSERT INTO outreach_leads (business_name, business_type, city, address, phone, website, google_rating, google_reviews_count, source, worst_review_text, worst_review_rating, worst_review_author, has_bad_review)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'night_blast', $9, $10, $11, $12)
                    ON CONFLICT (business_name, city) DO UPDATE SET
                      website = COALESCE(EXCLUDED.website, outreach_leads.website),
                      phone = COALESCE(EXCLUDED.phone, outreach_leads.phone),
                      google_rating = COALESCE(EXCLUDED.google_rating, outreach_leads.google_rating),
                      google_reviews_count = COALESCE(EXCLUDED.google_reviews_count, outreach_leads.google_reviews_count),
                      worst_review_text = COALESCE(EXCLUDED.worst_review_text, outreach_leads.worst_review_text),
                      worst_review_rating = COALESCE(EXCLUDED.worst_review_rating, outreach_leads.worst_review_rating),
                      worst_review_author = COALESCE(EXCLUDED.worst_review_author, outreach_leads.worst_review_author),
                      has_bad_review = COALESCE(EXCLUDED.has_bad_review, outreach_leads.has_bad_review)`,
                    [
                      result.name,
                      industry,
                      city,
                      result.formatted_address || null,
                      result.formatted_phone_number || null,
                      result.website || null,
                      result.rating || null,
                      result.user_ratings_total || null,
                      worstReview?.text || null,
                      worstReview?.rating || null,
                      worstReview?.author_name || null,
                      worstReview !== null,
                    ]
                  );
                  totalScraped++;
                }

                await new Promise(r => setTimeout(r, 200)); // Rate limiting
              } catch (e) {
                console.error(`Place details error for ${place.name}:`, e.message);
              }
            }
          }
          console.log(`  âœ“ ${city} (${industry}): scraped`);
        } catch (e) {
          console.error(`City scrape error ${city}:`, e.message);
        }
      }
    }

    results.phase1_scraping = { leads_added: totalScraped, cities_scraped: citiesToScrape };
    console.log(`ðŸ“ Phase 1 complete: ${totalScraped} leads scraped`);

    // ===== PHASE 2: EMAIL FINDING =====
    // Find emails for all leads without email (limit 50 per run)
    console.log('ðŸ“§ Phase 2: Email Finding...');

    const leadsWithoutEmail = await dbAll(`
      SELECT id, business_name, website, city FROM outreach_leads
      WHERE email IS NULL AND website IS NOT NULL
      ORDER BY created_at DESC
      LIMIT 50
    `);

    let emailsFound = 0;
    for (const lead of leadsWithoutEmail) {
      try {
        const emailResult = await findEmailForLead(lead);
        if (emailResult?.email) {
          await dbQuery(
            'UPDATE outreach_leads SET email = $1, email_source = $2, contact_name = $3 WHERE id = $4',
            [
              emailResult.email,
              emailResult.source || 'night_blast',
              emailResult.contactName || null,
              lead.id,
            ]
          );
          emailsFound++;
        }
        await new Promise(r => setTimeout(r, 500)); // Rate limiting
      } catch (e) {
        console.error(`Email find error for ${lead.business_name}:`, e.message);
      }
    }

    results.phase2_email_finding = {
      processed: leadsWithoutEmail.length,
      emails_found: emailsFound,
    };
    console.log(`ðŸ“§ Phase 2 complete: ${emailsFound} emails found`);

    // ===== PHASE 3: DEMO GENERATION =====
    // Generate demos for leads with email but no demo (limit 20 per run)
    console.log('ðŸŽ¬ Phase 3: Demo Generation...');

    const leadsNeedingDemo = await dbAll(`
      SELECT l.id, l.business_name, l.city, l.email, l.contact_name
      FROM outreach_leads l
      LEFT JOIN demo_generations d ON l.id = d.lead_id
      WHERE l.email IS NOT NULL AND d.id IS NULL
      ORDER BY l.created_at DESC
      LIMIT 20
    `);

    let demosGenerated = 0;
    for (const lead of leadsNeedingDemo) {
      try {
        const placeInfo = await lookupPlaceId(lead.business_name, lead.city);
        if (placeInfo?.placeId) {
          const reviews = await scrapeGoogleReviews(placeInfo.placeId, 3);
          if (reviews && reviews.length > 0) {
            const demos = [];
            for (const review of reviews.slice(0, 3)) {
              try {
                const response = await generateDemoResponse(
                  review.text || review.snippet || '',
                  review.rating || 3,
                  placeInfo.name || lead.business_name
                );
                demos.push({
                  review: review.text || review.snippet || '',
                  rating: review.rating || 3,
                  author: review.author || 'Anonymous',
                  response: response,
                  review_link: review.review_link || review.link || null,
                });
              } catch (e) {
                console.error(`Response gen error:`, e.message);
              }
            }

            if (demos.length > 0) {
              const demoToken = crypto.randomBytes(16).toString('hex');
              await dbQuery(
                `INSERT INTO demo_generations (lead_id, demo_token, business_name, demo_data, created_at)
                VALUES ($1, $2, $3, $4, NOW())`,
                [lead.id, demoToken, lead.business_name, JSON.stringify(demos)]
              );
              demosGenerated++;
            }
          }
        }
        await new Promise(r => setTimeout(r, 1000)); // Rate limiting for API calls
      } catch (e) {
        console.error(`Demo gen error for ${lead.business_name}:`, e.message);
      }
    }

    results.phase3_demo_generation = {
      processed: leadsNeedingDemo.length,
      demos_generated: demosGenerated,
    };
    console.log(`ðŸŽ¬ Phase 3 complete: ${demosGenerated} demos generated`);

    // ===== PHASE 4: HOT LEAD FOLLOW-UPS =====
    // Send personalized demos to people who clicked
    console.log('ðŸ”¥ Phase 4: Hot Lead Follow-ups...');

    try {
      const hotLeadResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/followup-clickers?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      const hotLeadResult = await hotLeadResponse.json();
      results.phase4_hot_lead_followups = hotLeadResult;
      console.log(`ðŸ”¥ Phase 4 complete: ${hotLeadResult.sent || 0} hot lead follow-ups sent`);
    } catch (e) {
      results.phase4_hot_lead_followups = { error: e.message };
      console.error('Phase 4 error:', e.message);
    }

    // ===== PHASE 5: SECOND FOLLOW-UPS =====
    // Send second follow-up with better offer to clickers who haven't converted
    console.log('ðŸ“¨ Phase 5: Second Follow-ups...');

    try {
      const secondFollowupResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/second-followup?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      const secondFollowupResult = await secondFollowupResponse.json();
      results.phase5_second_followups = secondFollowupResult;
      console.log(`ðŸ“¨ Phase 5 complete: ${secondFollowupResult.sent || 0} second follow-ups sent`);
    } catch (e) {
      results.phase5_second_followups = { error: e.message };
      console.error('Phase 5 error:', e.message);
    }

    // ===== PHASE 6: DEMO FOLLOW-UPS =====
    // Follow-up to people who viewed demo but didn't convert
    console.log('ðŸ‘€ Phase 6: Demo Follow-ups...');

    try {
      const demoFollowupResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/demo-followup?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      const demoFollowupResult = await demoFollowupResponse.json();
      results.phase6_demo_followups = demoFollowupResult;
      console.log(`ðŸ‘€ Phase 6 complete: ${demoFollowupResult.sent || 0} demo follow-ups sent`);
    } catch (e) {
      results.phase6_demo_followups = { error: e.message };
      console.error('Phase 6 error:', e.message);
    }

    // ===== PHASE 7: G2 ENRICHMENT =====
    // Find domain and email for G2 competitor leads
    console.log('ðŸŽ¯ Phase 7: G2 Enrichment...');

    try {
      const g2EnrichResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/enrich-g2-leads?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      const g2EnrichResult = await g2EnrichResponse.json();
      results.phase7_g2_enrichment = g2EnrichResult;
      console.log(
        `ðŸŽ¯ Phase 7 complete: ${g2EnrichResult.domainsFound || 0} domains, ${g2EnrichResult.emailsFound || 0} emails found`
      );
    } catch (e) {
      results.phase7_g2_enrichment = { error: e.message };
      console.error('Phase 7 error:', e.message);
    }

    // ===== PHASE 8: SOURCE-SPECIFIC EMAILS =====
    // Send emails for TripAdvisor, Yelp, G2, Agency leads
    console.log('ðŸ“¬ Phase 8: Source-specific Emails...');

    const sourceEmailResults = {};

    // TripAdvisor emails
    try {
      const tripResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/send-tripadvisor-emails?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      sourceEmailResults.tripadvisor = await tripResponse.json();
    } catch (e) {
      sourceEmailResults.tripadvisor = { error: e.message };
    }

    // Yelp emails
    try {
      const yelpResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/send-yelp-emails?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      sourceEmailResults.yelp = await yelpResponse.json();
    } catch (e) {
      sourceEmailResults.yelp = { error: e.message };
    }

    // G2 emails
    try {
      const g2Response = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/send-g2-emails?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      sourceEmailResults.g2 = await g2Response.json();
    } catch (e) {
      sourceEmailResults.g2 = { error: e.message };
    }

    // Agency emails
    try {
      const agencyResponse = await fetch(
        `${process.env.BACKEND_URL || 'https://review-responder.onrender.com'}/api/cron/send-agency-emails?secret=${process.env.CRON_SECRET}`,
        { method: 'GET' }
      );
      sourceEmailResults.agency = await agencyResponse.json();
    } catch (e) {
      sourceEmailResults.agency = { error: e.message };
    }

    results.phase8_source_emails = sourceEmailResults;
    console.log('ðŸ“¬ Phase 8 complete');

    // ===== PHASE 9: SOCIAL LINK SCRAPING =====
    // Scrape websites for Twitter, Facebook, Instagram, LinkedIn links
    console.log('ðŸ”— Phase 9: Social Link Scraping...');

    try {
      const socialScrapeResults = { checked: 0, found: 0, twitter: 0, facebook: 0, instagram: 0, linkedin: 0 };

      // Get leads with websites but no social links (limit 50 per run)
      const leadsNeedingSocial = await dbAll(`
        SELECT id, business_name, website
        FROM outreach_leads
        WHERE website IS NOT NULL
          AND website != ''
          AND twitter_handle IS NULL
          AND facebook_page IS NULL
          AND instagram_handle IS NULL
          AND linkedin_company IS NULL
          AND demo_url IS NOT NULL
        ORDER BY created_at DESC
        LIMIT 50
      `);

      console.log(`ðŸ”— Found ${leadsNeedingSocial.length} leads needing social links`);

      for (const lead of leadsNeedingSocial) {
        try {
          // Fetch website with timeout
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 10000); // 10s timeout

          let url = lead.website;
          if (!url.startsWith('http')) {
            url = 'https://' + url;
          }

          const response = await fetch(url, {
            signal: controller.signal,
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            },
          });
          clearTimeout(timeout);

          if (response.ok) {
            const html = await response.text();

            // Extract social links using regex
            const socialLinks = {};

            // Twitter/X
            const twitterMatch = html.match(/href=["'](https?:\/\/(www\.)?(twitter\.com|x\.com)\/[^"'\s>]+)["']/i);
            if (twitterMatch) {
              const handle = twitterMatch[1].split('/').pop().split('?')[0];
              if (handle && handle.length > 0 && handle !== 'share' && handle !== 'intent') {
                socialLinks.twitter_handle = '@' + handle.replace('@', '');
                socialScrapeResults.twitter++;
              }
            }

            // Facebook
            const facebookMatch = html.match(/href=["'](https?:\/\/(www\.)?facebook\.com\/[^"'\s>]+)["']/i);
            if (facebookMatch) {
              const page = facebookMatch[1].split('facebook.com/')[1]?.split('?')[0];
              if (page && page.length > 0 && page !== 'sharer' && page !== 'share') {
                socialLinks.facebook_page = 'facebook.com/' + page;
                socialScrapeResults.facebook++;
              }
            }

            // Instagram
            const instagramMatch = html.match(/href=["'](https?:\/\/(www\.)?instagram\.com\/[^"'\s>]+)["']/i);
            if (instagramMatch) {
              const handle = instagramMatch[1].split('instagram.com/')[1]?.split('?')[0].split('/')[0];
              if (handle && handle.length > 0 && handle !== 'p' && handle !== 'reel') {
                socialLinks.instagram_handle = '@' + handle.replace('@', '');
                socialScrapeResults.instagram++;
              }
            }

            // LinkedIn
            const linkedinMatch = html.match(/href=["'](https?:\/\/(www\.)?linkedin\.com\/company\/[^"'\s>]+)["']/i);
            if (linkedinMatch) {
              const company = linkedinMatch[1].split('company/')[1]?.split('?')[0].split('/')[0];
              if (company && company.length > 0) {
                socialLinks.linkedin_company = company;
                socialScrapeResults.linkedin++;
              }
            }

            // Update lead if we found any social links
            if (Object.keys(socialLinks).length > 0) {
              const updates = [];
              const values = [];
              let paramIndex = 1;

              for (const [key, value] of Object.entries(socialLinks)) {
                updates.push(`${key} = $${paramIndex++}`);
                values.push(value);
              }

              values.push(lead.id);
              await dbQuery(
                `UPDATE outreach_leads SET ${updates.join(', ')} WHERE id = $${paramIndex}`,
                values
              );

              socialScrapeResults.found++;
              console.log(`âœ… Found social links for ${lead.business_name}: ${JSON.stringify(socialLinks)}`);
            }
          }

          socialScrapeResults.checked++;

          // Rate limit: 500ms between requests
          await new Promise(r => setTimeout(r, 500));
        } catch (scrapeError) {
          // Silently skip failed websites
          socialScrapeResults.checked++;
        }
      }

      results.phase9_social_scraping = socialScrapeResults;
      console.log(`ðŸ”— Phase 9 complete: ${socialScrapeResults.found}/${socialScrapeResults.checked} leads got social links`);
    } catch (e) {
      results.phase9_social_scraping = { error: e.message };
      console.error('Phase 9 error:', e.message);
    }

    // ===== FINAL SUMMARY =====
    const duration = Math.round((Date.now() - startTime) / 1000);
    console.log(`ðŸŒ™ NIGHT BLAST COMPLETE in ${duration}s`);

    res.json({
      success: true,
      duration_seconds: duration,
      summary: {
        leads_scraped: results.phase1_scraping?.leads_added || 0,
        emails_found: results.phase2_email_finding?.emails_found || 0,
        demos_generated: results.phase3_demo_generation?.demos_generated || 0,
        hot_lead_followups: results.phase4_hot_lead_followups?.sent || 0,
        second_followups: results.phase5_second_followups?.sent || 0,
        demo_followups: results.phase6_demo_followups?.sent || 0,
        social_links_found: results.phase9_social_scraping?.found || 0,
        social_twitter: results.phase9_social_scraping?.twitter || 0,
        social_facebook: results.phase9_social_scraping?.facebook || 0,
        social_instagram: results.phase9_social_scraping?.instagram || 0,
        social_linkedin: results.phase9_social_scraping?.linkedin || 0,
      },
      phases: results,
    });
  } catch (error) {
    console.error('Night blast critical error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      partial_results: results,
    });
  }
});

// POST /api/admin/send-cold-email - Send custom cold email to restaurant leads
app.post('/api/admin/send-cold-email', async (req, res) => {
  const { key } = req.query;
  if (key !== process.env.ADMIN_SECRET) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (!resend && !brevoApi) {
    return res.status(500).json({ error: 'Email provider not configured' });
  }

  const { to, name, reviews, type } = req.body;
  if (!to || !name) {
    return res.status(400).json({ error: 'to and name required' });
  }

  try {
    const subject = `${reviews || 'Ihre'} Bewertungen - Antworten Sie auf alle mit AI?`;
    const html = `
<!DOCTYPE html>
<html>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
  <p>Guten Tag,</p>

  <p>ich habe gesehen, dass <strong>${name}</strong> ${reviews ? `uber <strong>${reviews} Bewertungen</strong>` : 'viele Bewertungen'} auf TripAdvisor und Yelp hat${reviews ? ' - das ist beeindruckend!' : '.'}</p>

  <p>Aber Hand aufs Herz: Wie viele davon bleiben unbeantwortet?</p>

  <p>Mit <strong>ReviewResponder</strong> konnen Sie:</p>
  <ul>
    <li>AI-generierte, personalisierte Antworten in Sekunden erstellen</li>
    <li>Den richtigen Ton treffen (professionell, freundlich, oder entschuldigend)</li>
    <li>Zeit sparen und trotzdem jeden Gast wertschatzen</li>
  </ul>

  <p><strong>20 kostenlose Antworten pro Monat</strong> - ohne Kreditkarte, ohne Verpflichtung.</p>

  <p>Hier konnen Sie es sofort testen:<br>
  <a href="https://tryreviewresponder.com?utm_source=cold_email&utm_campaign=munich_restaurants&utm_content=${encodeURIComponent(name)}" style="color: #2563eb;">https://tryreviewresponder.com</a></p>

  <p>Falls Sie Fragen haben, antworten Sie einfach auf diese Email.</p>

  <p>Mit freundlichen Grussen,<br>
  Berend Mainz<br>
  <span style="color: #666;">ReviewResponder</span></p>

  <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
  <p style="font-size: 12px; color: #999;">
    Sie erhalten diese Email, weil Ihr Restaurant viele Online-Bewertungen hat.<br>
    <a href="https://tryreviewresponder.com/unsubscribe?email=${encodeURIComponent(to)}" style="color: #999;">Abmelden</a>
  </p>
</body>
</html>
    `;

    const result = await sendEmail({
      to: to,
      subject: subject,
      html: html,
      type: 'outreach',
      campaign: 'manual-cold-email',
      from: process.env.OUTREACH_FROM_EMAIL || FROM_EMAIL,
      replyTo: 'berend.jakob.mainz@gmail.com',
    });

    console.log(`Cold email sent to ${name} (${to}):`, result.messageId);
    res.json({ success: true, id: result.messageId, to, name, provider: result.provider });
  } catch (error) {
    console.error('Cold email error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Test email endpoint (admin only)
app.get('/api/admin/test-email', authenticateAdmin, async (req, res) => {
  const testEmail = req.query.to || 'berend.mainz@web.de';
  const provider = req.query.provider || 'auto'; // 'brevo', 'resend', or 'auto'

  try {
    let result;

    if (provider === 'brevo' && brevoApi) {
      // Direct Brevo test
      const sendSmtpEmail = new SibApiV3Sdk.SendSmtpEmail();
      sendSmtpEmail.subject = 'Brevo Test Email';
      sendSmtpEmail.htmlContent = `<h1>Brevo Test</h1><p>This is a test email sent via Brevo at ${new Date().toISOString()}</p>`;
      sendSmtpEmail.sender = {
        name: 'ReviewResponder Test',
        email: 'hello@tryreviewresponder.com',
      };
      sendSmtpEmail.to = [{ email: testEmail }];

      result = await brevoApi.sendTransacEmail(sendSmtpEmail);
      res.json({
        success: true,
        provider: 'brevo',
        messageId: result.body?.messageId || result.messageId,
        to: testEmail,
        note: 'Check spam folder if not in inbox',
      });
    } else if (provider === 'resend' && resend) {
      // Direct Resend test
      result = await resend.emails.send({
        from: FROM_EMAIL,
        to: testEmail,
        subject: 'Resend Test Email',
        html: `<h1>Resend Test</h1><p>This is a test email sent via Resend at ${new Date().toISOString()}</p>`,
      });
      res.json({
        success: true,
        provider: 'resend',
        messageId: result.id,
        to: testEmail,
      });
    } else {
      // Use central sendEmail function
      result = await sendEmail({
        to: testEmail,
        subject: 'Email System Test',
        html: `<h1>Email Test</h1><p>This is a test email sent via the unified email system at ${new Date().toISOString()}</p><p>Provider: auto-selected based on type</p>`,
        type: 'transactional',
        campaign: 'test',
      });
      res.json({
        success: true,
        provider: result.provider,
        messageId: result.messageId,
        to: testEmail,
      });
    }
  } catch (error) {
    console.error('Test email error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      errorDetails: error.response?.body || error.response?.data || null,
      provider: provider,
      brevoConfigured: !!brevoApi,
      resendConfigured: !!resend,
    });
  }
});

// Health check with database status
app.get('/api/health', async (req, res) => {
  let dbStatus = 'unknown';
  try {
    await pool.query('SELECT 1');
    dbStatus = 'connected';
    dbConnected = true;
  } catch (error) {
    console.error('Health check DB error:', error.message);
    dbStatus = 'disconnected';
    dbConnected = false;
  }

  res.json({
    status: dbStatus === 'connected' ? 'ok' : 'degraded',
    database: dbStatus,
    databaseUrl: process.env.DATABASE_URL ? 'configured' : 'MISSING',
    email: {
      ses: sesClient ? 'configured' : 'not configured',
      resend: resend ? 'configured' : 'not configured',
      brevo: brevoApi ? 'configured' : 'not configured',
      mailersend: mailerSendClient ? 'configured' : 'not configured',
      primary_provider: sesClient ? 'ses' : brevoApi ? 'brevo' : resend ? 'resend' : 'none',
    },
    timestamp: new Date().toISOString(),
  });
});

// ==========================================
// ANTI-SPAM ADMIN ENDPOINTS
// ==========================================

// GET /api/admin/anti-spam - Dashboard showing suppressions and frequency stats
app.get('/api/admin/anti-spam', async (req, res) => {
  const { key } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  try {
    // Get suppression stats
    const suppressions = await dbQuery(`
      SELECT reason, COUNT(*) as count
      FROM email_suppressions
      GROUP BY reason
      ORDER BY count DESC
    `);

    // Get recent suppressions
    const recentSuppressions = await dbQuery(`
      SELECT email_address, reason, details, created_at
      FROM email_suppressions
      ORDER BY created_at DESC
      LIMIT 20
    `);

    // Get emails approaching frequency limit (3+ in last 7 days)
    const frequencyWarnings = await dbQuery(`
      SELECT to_email, COUNT(*) as emails_this_week
      FROM email_logs
      WHERE type = 'outreach'
      AND sent_at > NOW() - INTERVAL '7 days'
      GROUP BY to_email
      HAVING COUNT(*) >= 3
      ORDER BY COUNT(*) DESC
      LIMIT 50
    `);

    // Get skip stats from today
    const todaySkips = await dbQuery(`
      SELECT
        COUNT(*) FILTER (WHERE status = 'skipped') as skipped_today,
        COUNT(*) FILTER (WHERE status = 'sent') as sent_today
      FROM email_logs
      WHERE type = 'outreach'
      AND sent_at > NOW() - INTERVAL '1 day'
    `);

    res.json({
      success: true,
      config: {
        max_emails_per_week: MAX_EMAILS_PER_WEEK,
        note: 'Anti-spam nur fÃ¼r Outreach Emails. Transaktionale Emails (Passwort, etc.) sind NICHT betroffen.'
      },
      stats: {
        total_suppressed: suppressions.rows.reduce((sum, r) => sum + parseInt(r.count), 0),
        by_reason: suppressions.rows,
        emails_approaching_limit: frequencyWarnings.rows.length,
        today: todaySkips.rows[0] || { skipped_today: 0, sent_today: 0 }
      },
      recent_suppressions: recentSuppressions.rows,
      frequency_warnings: frequencyWarnings.rows.slice(0, 10),
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// POST /api/admin/anti-spam/suppress - Manually suppress an email
app.post('/api/admin/anti-spam/suppress', async (req, res) => {
  const { key } = req.query;
  const { email, reason, details } = req.body;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    await suppressEmail(email, reason || 'manual', details || 'Added via admin');
    res.json({ success: true, suppressed: email, reason: reason || 'manual' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// DELETE /api/admin/anti-spam/unsuppress - Remove email from suppression list
app.delete('/api/admin/anti-spam/unsuppress', async (req, res) => {
  const { key, email } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  if (!email) {
    return res.status(400).json({ error: 'Email required' });
  }

  try {
    const result = await pool.query(
      'DELETE FROM email_suppressions WHERE LOWER(email_address) = LOWER($1)',
      [email]
    );
    res.json({
      success: true,
      removed: result.rowCount > 0,
      email
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// GET /api/admin/cleanup-test-data - Remove all test data from database
app.get('/api/admin/cleanup-test-data', async (req, res) => {
  const { key, dryrun } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  const isDryRun = dryrun === 'true';
  const results = { dryrun: isDryRun, deleted: {}, errors: [] };

  // Test email patterns to delete
  const testPatterns = [
    "email LIKE '%berend%'",
    "email LIKE '%@test.%'",
    "email LIKE '%@tryreviewresponder.com%'",
    "email LIKE 'reviewer@%'",
  ];
  const whereClause = testPatterns.join(' OR ');

  try {
    // 1. Outreach Clicks
    const clicksCount = await pool.query(
      `SELECT COUNT(*) FROM outreach_clicks WHERE ${whereClause}`
    );
    results.deleted.outreach_clicks = parseInt(clicksCount.rows[0].count);
    if (!isDryRun && results.deleted.outreach_clicks > 0) {
      await pool.query(`DELETE FROM outreach_clicks WHERE ${whereClause}`);
    }

    // 2. Outreach Tracking (and reset opened_at in outreach_emails)
    const trackingCount = await pool.query(
      `SELECT COUNT(*) FROM outreach_tracking WHERE ${whereClause}`
    );
    results.deleted.outreach_tracking = parseInt(trackingCount.rows[0].count);
    if (!isDryRun && results.deleted.outreach_tracking > 0) {
      // Reset opened_at for emails that were tracked by test accounts
      await pool.query(`UPDATE outreach_emails SET opened_at = NULL WHERE ${whereClause}`);
      await pool.query(`DELETE FROM outreach_tracking WHERE ${whereClause}`);
    }

    // 3. Outreach Emails
    const emailsCount = await pool.query(
      `SELECT COUNT(*) FROM outreach_emails WHERE ${whereClause}`
    );
    results.deleted.outreach_emails = parseInt(emailsCount.rows[0].count);
    if (!isDryRun && results.deleted.outreach_emails > 0) {
      await pool.query(`DELETE FROM outreach_emails WHERE ${whereClause}`);
    }

    // 4. Outreach Leads
    const leadsCount = await pool.query(`SELECT COUNT(*) FROM outreach_leads WHERE ${whereClause}`);
    results.deleted.outreach_leads = parseInt(leadsCount.rows[0].count);
    if (!isDryRun && results.deleted.outreach_leads > 0) {
      await pool.query(`DELETE FROM outreach_leads WHERE ${whereClause}`);
    }

    // 5. Email Logs (uses to_email)
    const toEmailPatterns = testPatterns.map(p => p.replace('email', 'to_email'));
    const toEmailWhere = toEmailPatterns.join(' OR ');
    const logsCount = await pool.query(`SELECT COUNT(*) FROM email_logs WHERE ${toEmailWhere}`);
    results.deleted.email_logs = parseInt(logsCount.rows[0].count);
    if (!isDryRun && results.deleted.email_logs > 0) {
      await pool.query(`DELETE FROM email_logs WHERE ${toEmailWhere}`);
    }

    // 6. Email Captures
    const capturesCount = await pool.query(
      `SELECT COUNT(*) FROM email_captures WHERE ${whereClause}`
    );
    results.deleted.email_captures = parseInt(capturesCount.rows[0].count);
    if (!isDryRun && results.deleted.email_captures > 0) {
      await pool.query(`DELETE FROM email_captures WHERE ${whereClause}`);
    }

    // 7. Competitor Leads
    const competitorCount = await pool.query(
      `SELECT COUNT(*) FROM competitor_leads WHERE ${whereClause}`
    );
    results.deleted.competitor_leads = parseInt(competitorCount.rows[0].count);
    if (!isDryRun && results.deleted.competitor_leads > 0) {
      await pool.query(`DELETE FROM competitor_leads WHERE ${whereClause}`);
    }

    // 8. Demo Generations (old unconverted demos)
    const demosCount = await pool.query(
      `SELECT COUNT(*) FROM demo_generations WHERE created_at < NOW() - INTERVAL '7 days' AND converted_at IS NULL`
    );
    results.deleted.demo_generations_old = parseInt(demosCount.rows[0].count);
    if (!isDryRun && results.deleted.demo_generations_old > 0) {
      await pool.query(
        `DELETE FROM demo_generations WHERE created_at < NOW() - INTERVAL '7 days' AND converted_at IS NULL`
      );
    }

    // 9. Users (test accounts) - Must delete all FK-dependent data first
    const usersCount = await pool.query(`SELECT COUNT(*) FROM users WHERE ${whereClause}`);
    results.deleted.users = parseInt(usersCount.rows[0].count);
    if (!isDryRun && results.deleted.users > 0) {
      // First get user IDs for cascade cleanup
      const testUsers = await pool.query(`SELECT id FROM users WHERE ${whereClause}`);
      const userIds = testUsers.rows.map(r => r.id);

      if (userIds.length > 0) {
        // Delete all FK-dependent data - each with try-catch to continue on error
        const safeDelete = async (table, query, params) => {
          try {
            const result = await pool.query(query, params);
            return result.rowCount || 0;
          } catch (e) {
            console.log(`Skipping ${table}: ${e.message}`);
            return 0;
          }
        };

        // Delete in reverse FK order
        await safeDelete(
          'referrals',
          `DELETE FROM referrals WHERE referrer_id = ANY($1) OR referred_user_id = ANY($1)`,
          [userIds]
        );
        await safeDelete(
          'affiliate_payouts',
          `DELETE FROM affiliate_payouts WHERE affiliate_id IN (SELECT id FROM affiliates WHERE user_id = ANY($1))`,
          [userIds]
        );
        await safeDelete('affiliates', `DELETE FROM affiliates WHERE user_id = ANY($1)`, [userIds]);
        await safeDelete('api_keys', `DELETE FROM api_keys WHERE user_id = ANY($1)`, [userIds]);
        await safeDelete(
          'team_members',
          `DELETE FROM team_members WHERE team_owner_id = ANY($1) OR member_user_id = ANY($1)`,
          [userIds]
        );
        await safeDelete('user_settings', `DELETE FROM user_settings WHERE user_id = ANY($1)`, [
          userIds,
        ]);
        results.deleted.responses = await safeDelete(
          'responses',
          `DELETE FROM responses WHERE user_id = ANY($1)`,
          [userIds]
        );
        results.deleted.templates = await safeDelete(
          'templates',
          `DELETE FROM templates WHERE user_id = ANY($1)`,
          [userIds]
        );
        await safeDelete('drip_emails', `DELETE FROM drip_emails WHERE user_id = ANY($1)`, [
          userIds,
        ]);
        await safeDelete(
          'pre_registration_drips',
          `DELETE FROM pre_registration_drips WHERE email IN (SELECT email FROM users WHERE id = ANY($1))`,
          [userIds]
        );
        await safeDelete(
          'linkedin_outreach',
          `DELETE FROM linkedin_outreach WHERE user_id = ANY($1)`,
          [userIds]
        );
        // Clear referred_by references
        await safeDelete(
          'users_referred',
          `UPDATE users SET referred_by = NULL WHERE referred_by = ANY($1)`,
          [userIds]
        );
        // Finally delete users
        await safeDelete('users', `DELETE FROM users WHERE id = ANY($1)`, [userIds]);
      }
    }

    // Calculate new totals
    const newTotals = {};
    const totalQueries = [
      { name: 'outreach_leads', query: 'SELECT COUNT(*) FROM outreach_leads' },
      { name: 'outreach_emails', query: 'SELECT COUNT(*) FROM outreach_emails' },
      { name: 'outreach_tracking', query: 'SELECT COUNT(*) FROM outreach_tracking' },
      { name: 'outreach_clicks', query: 'SELECT COUNT(*) FROM outreach_clicks' },
      { name: 'email_logs', query: 'SELECT COUNT(*) FROM email_logs' },
      { name: 'users', query: 'SELECT COUNT(*) FROM users' },
    ];

    for (const q of totalQueries) {
      const result = await pool.query(q.query);
      newTotals[q.name] = parseInt(result.rows[0].count);
    }
    results.new_totals = newTotals;

    // Calculate open/click rates
    const openRate = await pool.query(`
      SELECT
        COUNT(DISTINCT oe.id) as total_emails,
        COUNT(DISTINCT ot.email) as opened
      FROM outreach_emails oe
      LEFT JOIN outreach_tracking ot ON oe.email = ot.email
    `);
    const clickRate = await pool.query(`
      SELECT
        COUNT(DISTINCT oe.id) as total_emails,
        COUNT(DISTINCT oc.email) as clicked
      FROM outreach_emails oe
      LEFT JOIN outreach_clicks oc ON oe.email = oc.email
    `);

    results.new_metrics = {
      open_rate:
        openRate.rows[0].total_emails > 0
          ? ((openRate.rows[0].opened / openRate.rows[0].total_emails) * 100).toFixed(1) + '%'
          : '0%',
      click_rate:
        clickRate.rows[0].total_emails > 0
          ? ((clickRate.rows[0].clicked / clickRate.rows[0].total_emails) * 100).toFixed(1) + '%'
          : '0%',
    };

    res.json(results);
  } catch (error) {
    console.error('Cleanup error:', error);
    results.errors.push(error.message);
    res.status(500).json(results);
  }
});

// GET /api/admin/reset-test-opens - Reset opened_at for test emails
app.get('/api/admin/reset-test-opens', async (req, res) => {
  const { key, dryrun } = req.query;
  const adminSecret = process.env.ADMIN_SECRET;

  if (!adminSecret || !safeCompare(key, adminSecret)) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  const isDryRun = dryrun === 'true';

  try {
    // Count emails with opened_at for test patterns
    const testPatterns = [
      "email LIKE '%berend%'",
      "email LIKE '%@test.%'",
      "email LIKE '%@tryreviewresponder.com%'",
      "email LIKE 'reviewer@%'",
    ];
    const whereClause = testPatterns.join(' OR ');

    const countBefore = await pool.query(
      `SELECT COUNT(*) FROM outreach_emails WHERE opened_at IS NOT NULL AND (${whereClause})`
    );
    const totalOpened = await pool.query(
      `SELECT COUNT(*) FROM outreach_emails WHERE opened_at IS NOT NULL`
    );

    if (!isDryRun) {
      await pool.query(
        `UPDATE outreach_emails SET opened_at = NULL WHERE opened_at IS NOT NULL AND (${whereClause})`
      );
    }

    const totalOpenedAfter = await pool.query(
      `SELECT COUNT(*) FROM outreach_emails WHERE opened_at IS NOT NULL`
    );
    const totalEmails = await pool.query(`SELECT COUNT(*) FROM outreach_emails`);

    res.json({
      dryrun: isDryRun,
      test_opens_reset: parseInt(countBefore.rows[0].count),
      opens_before: parseInt(totalOpened.rows[0].count),
      opens_after: parseInt(totalOpenedAfter.rows[0].count),
      total_emails: parseInt(totalEmails.rows[0].count),
      new_open_rate:
        totalEmails.rows[0].count > 0
          ? ((totalOpenedAfter.rows[0].count / totalEmails.rows[0].count) * 100).toFixed(1) + '%'
          : '0%',
    });
  } catch (error) {
    console.error('Reset opens error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============== NIGHT-BLAST SCHEDULER ==============
// Automatic night-time sales automation - runs without external cron jobs
// Uses node-cron for in-process scheduling

// Helper function to call night-blast endpoint internally
async function runNightBlast(source) {
  console.log(`ðŸŒ™ [${source}] Starting Night-Blast at ${new Date().toISOString()}`);
  try {
    const baseUrl = process.env.BACKEND_URL || `http://localhost:${PORT}`;
    const response = await fetch(
      `${baseUrl}/api/cron/night-blast?secret=${process.env.CRON_SECRET}`,
      {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      }
    );
    const result = await response.json();
    console.log(
      `ðŸŒ™ [${source}] Night-Blast completed:`,
      JSON.stringify(result.summary || result, null, 2)
    );
    return result;
  } catch (error) {
    console.error(`ðŸŒ™ [${source}] Night-Blast error:`, error.message);
    return { error: error.message };
  }
}

// Schedule Night-Blast jobs (Berlin timezone = UTC+1, but using UTC for simplicity)
// These times are in UTC:
// - 21:00 UTC = 22:00 Berlin (Winter) / 23:00 Berlin (Summer)
// - 01:00 UTC = 02:00 Berlin (Winter) / 03:00 Berlin (Summer)
// - 05:00 UTC = 06:00 Berlin (Winter) / 07:00 Berlin (Summer)

// Night-Blast 1: 21:00 UTC (22:00 Berlin)
cron.schedule('0 21 * * *', () => runNightBlast('Scheduled-21:00-UTC'), {
  scheduled: true,
  timezone: 'UTC',
});

// Night-Blast 2: 01:00 UTC (02:00 Berlin)
cron.schedule('0 1 * * *', () => runNightBlast('Scheduled-01:00-UTC'), {
  scheduled: true,
  timezone: 'UTC',
});

// Night-Blast 3: 05:00 UTC (06:00 Berlin)
cron.schedule('0 5 * * *', () => runNightBlast('Scheduled-05:00-UTC'), {
  scheduled: true,
  timezone: 'UTC',
});

console.log('ðŸŒ™ Night-Blast Scheduler initialized: 21:00, 01:00, 05:00 UTC');

// ============== NIGHT-LOOP SCHEDULER ==============
// Automatic execution of hourly night tasks
// Helper function to call night-loop endpoint internally
async function runNightLoop(hour, source) {
  console.log(`ðŸŒ™ [${source}] Running Night-Loop Hour ${hour} at ${new Date().toISOString()}`);
  try {
    const baseUrl = process.env.BACKEND_URL || `http://localhost:${PORT}`;
    const response = await fetch(
      `${baseUrl}/api/cron/night-loop?secret=${process.env.CRON_SECRET}&hour=${hour}`,
      {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      }
    );
    const result = await response.json();
    console.log(
      `ðŸŒ™ [${source}] Night-Loop Hour ${hour} completed:`,
      JSON.stringify(result, null, 2).substring(0, 500)
    );
    return result;
  } catch (error) {
    console.error(`ðŸŒ™ [${source}] Night-Loop Hour ${hour} error:`, error.message);
    return { error: error.message };
  }
}

// Night-Loop Hour 0: Demo Expiration Emails (23:00 UTC = 00:00 Berlin)
cron.schedule('0 23 * * *', () => runNightLoop(0, 'Scheduled-23:00-UTC-Hour0'), {
  scheduled: true,
  timezone: 'UTC',
});

// Night-Loop Hour 2: Re-Engagement Magic Links (01:00 UTC = 02:00 Berlin)
// Note: Already overlaps with Night-Blast at 01:00, so night-loop runs A/B tests + magic links
cron.schedule('5 1 * * *', () => runNightLoop(2, 'Scheduled-01:05-UTC-Hour2'), {
  scheduled: true,
  timezone: 'UTC',
});

// ============================================================================
// ONBOARDING EMAILS - CRITICAL FOR USER ACTIVATION
// Based on First Principles Analysis: 66% of users never use the product
// This is THE bottleneck - not lead generation!
// ============================================================================

// Run onboarding emails 3x daily (morning, afternoon, evening)
// To catch users at different points after registration
async function runOnboardingEmails(source) {
  const baseUrl =
    process.env.BACKEND_URL || 'https://review-responder.onrender.com';
  console.log(`ðŸ“§ [Onboarding] Starting onboarding emails (${source})...`);

  try {
    const response = await fetch(
      `${baseUrl}/api/cron/onboarding-emails?secret=${process.env.CRON_SECRET}`,
      { method: 'GET', timeout: 120000 }
    );
    const result = await response.json();
    console.log(
      `ðŸ“§ [Onboarding] Complete: ${result.sent || 0} sent, ${result.skipped || 0} skipped`
    );
    return result;
  } catch (error) {
    console.error(`ðŸ“§ [Onboarding] Error:`, error.message);
    return { error: error.message };
  }
}

// 08:00 UTC = 09:00 Berlin - Morning check
cron.schedule('0 8 * * *', () => runOnboardingEmails('Scheduled-08:00-UTC'), {
  scheduled: true,
  timezone: 'UTC',
});

// 14:00 UTC = 15:00 Berlin - Afternoon check
cron.schedule('0 14 * * *', () => runOnboardingEmails('Scheduled-14:00-UTC'), {
  scheduled: true,
  timezone: 'UTC',
});

// 20:00 UTC = 21:00 Berlin - Evening check
cron.schedule('0 20 * * *', () => runOnboardingEmails('Scheduled-20:00-UTC'), {
  scheduled: true,
  timezone: 'UTC',
});

console.log('ðŸŒ™ Night-Loop Scheduler initialized: Hour 0 at 23:00 UTC, Hour 2 at 01:05 UTC');
console.log('ðŸ“§ Onboarding Emails Scheduler initialized: 08:00, 14:00, 20:00 UTC');

// GET /api/cron/upgrade-leads - Upgrade existing leads with emails and demos
// Phase 1: Find emails for leads without email (website scraping + patterns)
// Phase 2: Generate demos for leads with email but no demo
app.get('/api/cron/upgrade-leads', async (req, res) => {
  const cronSecret = req.query.secret || req.headers['x-cron-secret'];
  if (!safeCompare(cronSecret || '', process.env.CRON_SECRET || '')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const emailLimit = parseInt(req.query.email_limit) || 20;
  const demoLimit = parseInt(req.query.demo_limit) || 10;
  const sendEmails = req.query.send_emails === 'true';

  const results = {
    phase1_email_finding: { processed: 0, found: 0, failed: 0 },
    phase2_demo_generation: { processed: 0, success: 0, failed: 0, demos: [] },
    timestamp: new Date().toISOString()
  };

  try {
    // PHASE 1: Find/Upgrade emails for leads
    // Now also upgrades "low quality" emails (info@, contact@) to personal emails (owner@, firstname@)
    console.log('ðŸ“§ [Upgrade Leads] Phase 1: Email Finding & Upgrading...');

    // Find leads that need email OR have low-quality email
    const leadsNeedingEmail = await dbAll(
      `SELECT * FROM outreach_leads
       WHERE website IS NOT NULL AND website != ''
       AND google_reviews_count >= 50
       AND (
         email IS NULL
         OR email = ''
         OR email LIKE 'info@%'
         OR email LIKE 'contact@%'
         OR email LIKE 'hello@%'
         OR email LIKE 'support@%'
         OR email LIKE 'office@%'
         OR email LIKE 'mail@%'
         OR email LIKE 'service@%'
         OR email LIKE 'kontakt@%'
         OR email LIKE 'anfrage@%'
         OR email LIKE 'reservations@%'
         OR email LIKE 'booking@%'
       )
       ORDER BY google_reviews_count DESC
       LIMIT $1`,
      [emailLimit]
    );

    console.log(`Found ${leadsNeedingEmail.length} leads needing email upgrade`);

    for (const lead of leadsNeedingEmail) {
      results.phase1_email_finding.processed++;
      try {
        // Use the advanced findEmailForLead function (personal > owner > generic)
        const emailResult = await findEmailForLead(lead);

        if (emailResult?.email) {
          const newEmail = emailResult.email.toLowerCase();
          const existingEmail = lead.email?.toLowerCase();

          // Only update if new email is better than existing
          if (isEmailUpgrade(existingEmail, newEmail)) {
            await dbQuery(
              `UPDATE outreach_leads
               SET email = $1,
                   email_source = $2,
                   contact_name = COALESCE($3, contact_name)
               WHERE id = $4`,
              [newEmail, emailResult.source || 'upgrade_v2', emailResult.contactName || null, lead.id]
            );
            results.phase1_email_finding.found++;

            const upgradeType = existingEmail ? 'UPGRADED' : 'FOUND';
            const quality = isLowQualityEmail(newEmail) ? 'generic' : 'PERSONAL';
            console.log(`ðŸ“§ ${upgradeType} (${quality}): ${lead.business_name} | ${existingEmail || 'none'} â†’ ${newEmail}`);
          } else {
            console.log(`â­ï¸ Skip: ${lead.business_name} | ${existingEmail} already good quality`);
          }
        }
      } catch (err) {
        results.phase1_email_finding.failed++;
        console.error(`Email finding failed for ${lead.business_name}:`, err.message);
      }
    }

    // PHASE 2: Generate demos for leads with email but no demo
    console.log('ðŸŽ¯ [Upgrade Leads] Phase 2: Demo Generation...');
    const leadsNeedingDemo = await dbAll(
      `SELECT ol.* FROM outreach_leads ol
       LEFT JOIN demo_generations dg ON ol.id = dg.lead_id
       WHERE ol.email IS NOT NULL AND ol.email != ''
       AND dg.id IS NULL
       AND ol.google_reviews_count >= 30
       ORDER BY ol.google_reviews_count DESC
       LIMIT $1`,
      [demoLimit]
    );

    for (const lead of leadsNeedingDemo) {
      results.phase2_demo_generation.processed++;
      try {
        // Lookup place and get reviews
        const placeInfo = await lookupPlaceId(lead.business_name, lead.city);
        if (!placeInfo || !placeInfo.placeId) {
          console.log(`Could not find place for ${lead.business_name}, skipping`);
          results.phase2_demo_generation.failed++;
          continue;
        }

        const allReviews = await scrapeGoogleReviews(placeInfo.placeId, 20);

        // Get worst reviews for demo
        const targetReviews = allReviews
          .filter(r => r.rating <= 3)
          .sort((a, b) => a.rating - b.rating)
          .slice(0, 3);

        if (targetReviews.length === 0) {
          console.log(`No negative reviews for ${lead.business_name}, skipping`);
          continue;
        }

        // Generate AI responses
        const demos = [];
        for (const review of targetReviews) {
          const aiResponse = await generateDemoResponse(
            review,
            lead.business_name,
            lead.business_type,
            lead.city,
            placeInfo.rating,
            placeInfo.totalReviews
          );
          demos.push({
            review: {
              text: review.text,
              rating: review.rating,
              author: review.author,
              date: review.date,
              source: review.source || 'google',
              review_link: review.review_link || null,
            },
            ai_response: aiResponse,
          });
        }

        const demoToken = generateDemoToken();
        const demoUrl = `${process.env.FRONTEND_URL || 'https://tryreviewresponder.com'}/demo/${demoToken}`;

        // Save demo
        await dbQuery(
          `INSERT INTO demo_generations
           (business_name, google_place_id, city, google_rating, total_reviews, scraped_reviews, demo_token, generated_responses, lead_id)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
          [
            lead.business_name,
            placeInfo.placeId,
            lead.city,
            placeInfo.rating,
            placeInfo.totalReviews,
            JSON.stringify(allReviews),
            demoToken,
            JSON.stringify(demos),
            lead.id,
          ]
        );

        // Update lead with demo URL
        await dbQuery(
          `UPDATE outreach_leads SET demo_url = $1, demo_token = $2 WHERE id = $3`,
          [demoUrl, demoToken, lead.id]
        );

        results.phase2_demo_generation.success++;
        results.phase2_demo_generation.demos.push({
          business: lead.business_name,
          city: lead.city,
          demo_url: demoUrl,
          reviews_count: demos.length
        });

        console.log(`ðŸŽ¯ Generated demo for ${lead.business_name}: ${demoUrl}`);

        // Optional: Send email with demo
        if (sendEmails && lead.email) {
          try {
            await sendDemoEmail(lead.email, lead.business_name, demos, demoToken, placeInfo.totalReviews);
            await dbQuery('UPDATE demo_generations SET email_sent_at = NOW() WHERE demo_token = $1', [demoToken]);
            console.log(`ðŸ“§ Sent demo email to ${lead.email}`);
          } catch (emailError) {
            console.error(`Email failed for ${lead.email}:`, emailError.message);
          }
        }
      } catch (err) {
        results.phase2_demo_generation.failed++;
        console.error(`Demo generation failed for ${lead.business_name}:`, err.message);
      }
    }

    console.log('âœ… [Upgrade Leads] Complete:', JSON.stringify(results, null, 2));
    res.json({
      success: true,
      ...results,
      summary: {
        emails_found: `${results.phase1_email_finding.found}/${results.phase1_email_finding.processed}`,
        demos_generated: `${results.phase2_demo_generation.success}/${results.phase2_demo_generation.processed}`,
      }
    });

  } catch (error) {
    console.error('Upgrade leads error:', error);
    res.status(500).json({ error: 'Failed to upgrade leads', details: error.message });
  }
});

// Start server
initDatabase()
  .then(() => {
    app.listen(PORT, () => {
      console.log(`âœ… Server running on port ${PORT}`);
      console.log(
        'ðŸŒ™ Night-Blast jobs scheduled: 21:00, 01:00, 05:00 UTC (22:00, 02:00, 06:00 Berlin)'
      );
    });
  })
  .catch(err => {
    console.error('Failed to initialize database:', err);
    process.exit(1);
  });
